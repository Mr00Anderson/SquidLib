<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Noise.HastyPointHash (squidlib-util 3.0.0-SNAPSHOT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: squidpony.squidmath, class: Noise, class: HastyPointHash">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Noise.HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">squidpony.squidmath</a></div>
<h1 title="Class Noise.HastyPointHash" class="title">Class Noise.HastyPointHash</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Object</a>
<div class="inheritance">squidpony.squidmath.Noise.HastyPointHash</div>
</div>
<section class="description">
<dl>
<dt>Enclosing class:</dt>
<dd><a href="Noise.html" title="class in squidpony.squidmath">Noise</a></dd>
</dl>
<hr>
<pre>public static final class <a href="../../src-html/squidpony/squidmath/Noise.html#line.869">Noise.HastyPointHash</a>
extends <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></pre>
<div class="block">A group of similar methods for getting hashes of points based on long coordinates in 2, 3, 4, or 6 dimensions and
 a long for state; like <a href="Noise.PointHash.html" title="class in squidpony.squidmath"><code>Noise.PointHash</code></a> but optimized for speed rather than quality. This implementation has
 high enough quality to be useful as a source of random numbers based on positions, but would likely not be a good
 option in a hash table (or at least not as good as the tailored implementation of <a href="Coord.html#hashCode()"><code>Coord.hashCode()</code></a>, for
 instance). At low dimensions, this is a little faster than <a href="Noise.PointHash.html" title="class in squidpony.squidmath"><code>Noise.PointHash</code></a>, but this class doesn't slow down
 much at all as more dimensions are used, while PointHash and most other implementations do slow down.
 <br>
 Also includes permutation tables for noise implementations that don't mind wrapping after 256 integer positions
 have been hashed; these tables are based on <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3594&rep=rep1&type=pdf">this paper</a>,
 with credit to Andrew Kensler, Aaron Knoll and Peter Shirley.</div>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_u">perm_u</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_v">perm_v</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_w">perm_w</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_x">perm_x</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_y">perm_y</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#perm_z">perm_z</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">HastyPointHash</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256(long,long,long,long,long,long,long)">hash256</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash256_alt(long,long,long,long,long)">hash256_alt</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash32(long,long,long,long,long,long,long)">hash32</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hash64(long,long,long,long,long,long,long)">hash64</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashAll(long,long,long,long,long,long,long)">hashAll</a></span>&#8203;(long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</code></th>
<td class="colLast">
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang" class="externalLink">clone</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang" class="externalLink">equals</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang" class="externalLink">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang" class="externalLink">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang" class="externalLink">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang" class="externalLink">notify</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang" class="externalLink">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang" class="externalLink">toString</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long,int)" title="class or interface in java.lang" class="externalLink">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="perm_x">perm_x</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_x</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="perm_y">perm_y</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_y</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="perm_z">perm_z</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_z</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="perm_w">perm_w</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_w</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="perm_u">perm_u</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_u</a></span></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="perm_v">perm_v</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.872">perm_v</a></span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;()">HastyPointHash</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.869">HastyPointHash</a></span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.932">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.957">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.984">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hashAll(long,long,long,long,long,long,long)">hashAll</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">long</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1014">hashAll</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1041">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1066">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1093">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256(long,long,long,long,long,long,long)">hash256</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1123">hash256</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1150">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1175">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1202">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash32(long,long,long,long,long,long,long)">hash32</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1232">hash32</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1260">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1285">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1312">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash64(long,long,long,long,long,long,long)">hash64</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1342">hash64</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;u,
long&nbsp;v,
long&nbsp;s)</span></div>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="hash256_alt(long,long,long,long,long)">hash256_alt</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName"><a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1353">hash256_alt</a></span>&#8203;(<span class="arguments">long&nbsp;x,
long&nbsp;y,
long&nbsp;z,
long&nbsp;w,
long&nbsp;seed)</span></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Noise.HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2012&#x2013;2019. All rights reserved.</small></p>
</footer>
</body>
</html>
