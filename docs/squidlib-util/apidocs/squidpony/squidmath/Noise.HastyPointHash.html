<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Noise.HastyPointHash (squidlib-util 3.0.0-SNAPSHOT)</title>
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Noise.HastyPointHash (squidlib-util 3.0.0-SNAPSHOT)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Noise.HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../squidpony/squidmath/Noise.Basic1D.html" title="class in squidpony.squidmath"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../squidpony/squidmath/Noise.IntPointHash.html" title="class in squidpony.squidmath"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?squidpony/squidmath/Noise.HastyPointHash.html" target="_top">Frames</a></li>
<li><a href="Noise.HastyPointHash.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">squidpony.squidmath</div>
<h2 title="Class Noise.HastyPointHash" class="title">Class Noise.HastyPointHash</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>squidpony.squidmath.Noise.HastyPointHash</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Enclosing class:</dt>
<dd><a href="../../squidpony/squidmath/Noise.html" title="class in squidpony.squidmath">Noise</a></dd>
</dl>
<hr>
<br>
<pre>public static final class <a href="../../src-html/squidpony/squidmath/Noise.html#line.869">Noise.HastyPointHash</a>
extends <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
<div class="block">A group of similar methods for getting hashes of points based on long coordinates in 2, 3, 4, or 6 dimensions and
 a long for state; like <a href="../../squidpony/squidmath/Noise.PointHash.html" title="class in squidpony.squidmath"><code>Noise.PointHash</code></a> but optimized for speed rather than quality. This implementation has
 high enough quality to be useful as a source of random numbers based on positions, but would likely not be a good
 option in a hash table (or at least not as good as the tailored implementation of <a href="../../squidpony/squidmath/Coord.html#hashCode--"><code>Coord.hashCode()</code></a>, for
 instance). At low dimensions, this is a little faster than <a href="../../squidpony/squidmath/Noise.PointHash.html" title="class in squidpony.squidmath"><code>Noise.PointHash</code></a>, but this class doesn't slow down
 much at all as more dimensions are used, while PointHash and most other implementations do slow down.
 <br>
 Also includes permutation tables for noise implementations that don't mind wrapping after 256 integer positions
 have been hashed; these tables are based on <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.3594&rep=rep1&type=pdf">this paper</a>,
 with credit to Andrew Kensler, Aaron Knoll and Peter Shirley.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_u">perm_u</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_v">perm_v</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_w">perm_w</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_x">perm_x</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_y">perm_y</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#perm_z">perm_z</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#HastyPointHash--">HastyPointHash</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash256_alt-long-long-long-long-long-">hash256_alt</a></span>(long&nbsp;x,
           long&nbsp;y,
           long&nbsp;z,
           long&nbsp;w,
           long&nbsp;seed)</code>&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash256-long-long-long-">hash256</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;s)</code>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash256-long-long-long-long-">hash256</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;s)</code>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash256-long-long-long-long-long-">hash256</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;w,
       long&nbsp;s)</code>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash256-long-long-long-long-long-long-long-">hash256</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;w,
       long&nbsp;u,
       long&nbsp;v,
       long&nbsp;s)</code>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash32-long-long-long-">hash32</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;s)</code>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash32-long-long-long-long-">hash32</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;s)</code>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash32-long-long-long-long-long-">hash32</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;w,
      long&nbsp;s)</code>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash32-long-long-long-long-long-long-long-">hash32</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;w,
      long&nbsp;u,
      long&nbsp;v,
      long&nbsp;s)</code>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash64-long-long-long-">hash64</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;s)</code>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash64-long-long-long-long-">hash64</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;s)</code>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash64-long-long-long-long-long-">hash64</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;w,
      long&nbsp;s)</code>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hash64-long-long-long-long-long-long-long-">hash64</a></span>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z,
      long&nbsp;w,
      long&nbsp;u,
      long&nbsp;v,
      long&nbsp;s)</code>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hashAll-long-long-long-">hashAll</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;s)</code>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hashAll-long-long-long-long-">hashAll</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;s)</code>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hashAll-long-long-long-long-long-">hashAll</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;w,
       long&nbsp;s)</code>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../squidpony/squidmath/Noise.HastyPointHash.html#hashAll-long-long-long-long-long-long-long-">hashAll</a></span>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z,
       long&nbsp;w,
       long&nbsp;u,
       long&nbsp;v,
       long&nbsp;s)</code>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang">clone</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang">equals</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#finalize--" title="class or interface in java.lang">finalize</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang">hashCode</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang">toString</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="perm_x">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perm_x</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.873">perm_x</a></pre>
</li>
</ul>
<a name="perm_y">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perm_y</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.874">perm_y</a></pre>
</li>
</ul>
<a name="perm_z">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perm_z</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.875">perm_z</a></pre>
</li>
</ul>
<a name="perm_w">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perm_w</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.876">perm_w</a></pre>
</li>
</ul>
<a name="perm_u">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perm_u</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.877">perm_u</a></pre>
</li>
</ul>
<a name="perm_v">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>perm_v</h4>
<pre>public static final&nbsp;int[] <a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.878">perm_v</a></pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="HastyPointHash--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>HastyPointHash</h4>
<pre>public&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.869">HastyPointHash</a>()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="hashAll-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashAll</h4>
<pre>public static&nbsp;long&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.932">hashAll</a>(long&nbsp;x,
                           long&nbsp;y,
                           long&nbsp;s)</pre>
<div class="block">Gets a 64-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y point with the given state</dd>
</dl>
</li>
</ul>
<a name="hashAll-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashAll</h4>
<pre>public static&nbsp;long&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.957">hashAll</a>(long&nbsp;x,
                           long&nbsp;y,
                           long&nbsp;z,
                           long&nbsp;s)</pre>
<div class="block">Gets a 64-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z point with the given state</dd>
</dl>
</li>
</ul>
<a name="hashAll-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashAll</h4>
<pre>public static&nbsp;long&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.984">hashAll</a>(long&nbsp;x,
                           long&nbsp;y,
                           long&nbsp;z,
                           long&nbsp;w,
                           long&nbsp;s)</pre>
<div class="block">Gets a 64-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</li>
</ul>
<a name="hashAll-long-long-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashAll</h4>
<pre>public static&nbsp;long&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1014">hashAll</a>(long&nbsp;x,
                           long&nbsp;y,
                           long&nbsp;z,
                           long&nbsp;w,
                           long&nbsp;u,
                           long&nbsp;v,
                           long&nbsp;s)</pre>
<div class="block">Gets a 64-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>64-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash256-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash256</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1041">hash256</a>(long&nbsp;x,
                          long&nbsp;y,
                          long&nbsp;s)</pre>
<div class="block">Gets an 8-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash256-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash256</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1066">hash256</a>(long&nbsp;x,
                          long&nbsp;y,
                          long&nbsp;z,
                          long&nbsp;s)</pre>
<div class="block">Gets an 8-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash256-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash256</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1093">hash256</a>(long&nbsp;x,
                          long&nbsp;y,
                          long&nbsp;z,
                          long&nbsp;w,
                          long&nbsp;s)</pre>
<div class="block">Gets an 8-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash256-long-long-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash256</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1123">hash256</a>(long&nbsp;x,
                          long&nbsp;y,
                          long&nbsp;z,
                          long&nbsp;w,
                          long&nbsp;u,
                          long&nbsp;v,
                          long&nbsp;s)</pre>
<div class="block">Gets an 8-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>8-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash32-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash32</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1150">hash32</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;s)</pre>
<div class="block">Gets a 5-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash32-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash32</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1175">hash32</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;s)</pre>
<div class="block">Gets a 5-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash32-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash32</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1202">hash32</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;w,
                         long&nbsp;s)</pre>
<div class="block">Gets a 5-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash32-long-long-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash32</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1232">hash32</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;w,
                         long&nbsp;u,
                         long&nbsp;v,
                         long&nbsp;s)</pre>
<div class="block">Gets a 5-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>5-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash64-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash64</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1260">hash64</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;s)</pre>
<div class="block">Gets a 6-bit point hash of a 2D point (x and y are both longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash64-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash64</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1285">hash64</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;s)</pre>
<div class="block">Gets a 6-bit point hash of a 3D point (x, y, and z are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>s</code> - the state/seed; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash64-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash64</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1312">hash64</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;w,
                         long&nbsp;s)</pre>
<div class="block">Gets a 6-bit point hash of a 4D point (x, y, z, and w are all longs) and a state/seed as a long. This point
 hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash64-long-long-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hash64</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1342">hash64</a>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;w,
                         long&nbsp;u,
                         long&nbsp;v,
                         long&nbsp;s)</pre>
<div class="block">Gets a 6-bit point hash of a 6D point (x, y, z, w, u, and v are all longs) and a state/seed as a long. This
 point hash has close to the best speed of any algorithms tested, and though its quality is mediocre for
 traditional uses of hashing (such as hash tables), it's sufficiently random to act as a positional RNG.
 <br>
 This uses a technique related to the one used by Martin Roberts for his golden-ratio-based sub-random
 sequences, where each axis is multiplied by a different constant, and the choice of constants depends on the
 number of axes but is always related to a generalized form of golden ratios, repeatedly dividing 1.0 by the
 generalized ratio. See
 <a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Roberts' article</a>
 for some more information on how he uses this, but we do things differently because we want random-seeming
 results instead of separated sub-random results.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x position; any long</dd>
<dd><code>y</code> - y position; any long</dd>
<dd><code>z</code> - z position; any long</dd>
<dd><code>w</code> - w position; any long</dd>
<dd><code>u</code> - u position; any long</dd>
<dd><code>v</code> - v position; any long</dd>
<dd><code>s</code> - the state; any long</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>6-bit hash of the x,y,z,w,u,v point with the given state</dd>
</dl>
</li>
</ul>
<a name="hash256_alt-long-long-long-long-long-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>hash256_alt</h4>
<pre>public static&nbsp;int&nbsp;<a href="../../src-html/squidpony/squidmath/Noise.HastyPointHash.html#line.1353">hash256_alt</a>(long&nbsp;x,
                              long&nbsp;y,
                              long&nbsp;z,
                              long&nbsp;w,
                              long&nbsp;seed)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Noise.HastyPointHash.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../squidpony/squidmath/Noise.Basic1D.html" title="class in squidpony.squidmath"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../squidpony/squidmath/Noise.IntPointHash.html" title="class in squidpony.squidmath"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?squidpony/squidmath/Noise.HastyPointHash.html" target="_top">Frames</a></li>
<li><a href="Noise.HastyPointHash.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012&#x2013;2019. All rights reserved.</small></p>
</body>
</html>
