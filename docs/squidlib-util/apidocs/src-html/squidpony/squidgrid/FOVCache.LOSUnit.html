<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: squidpony.squidgrid, class: FOVCache, class: LOSUnit">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">package squidpony.squidgrid;</a>
<span class="sourceLineNo">002</span><a id="line.2"></a>
<span class="sourceLineNo">003</span><a id="line.3">import squidpony.annotation.GwtIncompatible;</a>
<span class="sourceLineNo">004</span><a id="line.4">import squidpony.squidgrid.mapping.DungeonUtility;</a>
<span class="sourceLineNo">005</span><a id="line.5">import squidpony.squidmath.Coord;</a>
<span class="sourceLineNo">006</span><a id="line.6">import squidpony.squidmath.NumberTools;</a>
<span class="sourceLineNo">007</span><a id="line.7">import squidpony.squidmath.OrderedMap;</a>
<span class="sourceLineNo">008</span><a id="line.8">import squidpony.squidmath.ShortVLA;</a>
<span class="sourceLineNo">009</span><a id="line.9"></a>
<span class="sourceLineNo">010</span><a id="line.10">import java.util.*;</a>
<span class="sourceLineNo">011</span><a id="line.11">import java.util.concurrent.*;</a>
<span class="sourceLineNo">012</span><a id="line.12"></a>
<span class="sourceLineNo">013</span><a id="line.13">import static squidpony.squidmath.CoordPacker.*;</a>
<span class="sourceLineNo">014</span><a id="line.14"></a>
<span class="sourceLineNo">015</span><a id="line.15">/**</a>
<span class="sourceLineNo">016</span><a id="line.16"> * A combined FOV calculator, partial LOS calculator, FOV/LOS compressor, and tool to store/query/extract compressed</a>
<span class="sourceLineNo">017</span><a id="line.17"> * FOV/LOS data; it is less generally-useful than it sounds, and using {@link FOV} is usually easier and faster.</a>
<span class="sourceLineNo">018</span><a id="line.18"> * This class operates on one level map at a time and stores FOV maps for all cells in a memory-efficient way,</a>
<span class="sourceLineNo">019</span><a id="line.19"> * though it is likely to take too long to process large maps to be useful on those unless run before the player gets</a>
<span class="sourceLineNo">020</span><a id="line.20"> * to that map. (Large here means more than 10,000 total cells, or 100 width * 100 height, but this rough upper bound is</a>
<span class="sourceLineNo">021</span><a id="line.21"> * based on the capability of the machine running the calculations, and should be expected to be much lower on, for</a>
<span class="sourceLineNo">022</span><a id="line.22"> * instance, older dual-core phones than newer quad-core desktops). There are a few ways to ensure FOVCache is done</a>
<span class="sourceLineNo">023</span><a id="line.23"> * processing a map by the time a player gets to that map; the recommended approach for games with clearly defined,</a>
<span class="sourceLineNo">024</span><a id="line.24"> * separate levels is to generate the first level as part of game startup, run cacheAll() immediately afterward (this</a>
<span class="sourceLineNo">025</span><a id="line.25"> * will start calculation on a second thread), and when the map needs to be displayed (because gameplay has started and</a>
<span class="sourceLineNo">026</span><a id="line.26"> * any character creation steps are done), to call the caching method's counterpart, awaitCache(), which will cause</a>
<span class="sourceLineNo">027</span><a id="line.27"> * gameplay to be essentially frozen until the cache completes (you could display a loading message before calling it).</a>
<span class="sourceLineNo">028</span><a id="line.28"> * The next part is more interesting; you should generate the second level immediately after the awaiting method</a>
<span class="sourceLineNo">029</span><a id="line.29"> * finishes, before the player has approached the second level, and create another FOVCache object using the second</a>
<span class="sourceLineNo">030</span><a id="line.30"> * level as its map, then call cacheAll() on the second level's FOVCache. This will calculate the cache, as before, on</a>
<span class="sourceLineNo">031</span><a id="line.31"> * another thread, and you should call the appropriate awaiting method when the player is entering the second level</a>
<span class="sourceLineNo">032</span><a id="line.32"> * (descending or ascending a staircase, for example). This time, as long as the player spent more than a few seconds on</a>
<span class="sourceLineNo">033</span><a id="line.33"> * the first level for most maps, the cache should be pre-calculated and awaiting should take no time. When the game is</a>
<span class="sourceLineNo">034</span><a id="line.34"> * closed or the player quits, you should call destroy() on this FOVCache to avoid threads possibly lingering after the</a>
<span class="sourceLineNo">035</span><a id="line.35"> * game should have ended.</a>
<span class="sourceLineNo">036</span><a id="line.36"> * &lt;br&gt;</a>
<span class="sourceLineNo">037</span><a id="line.37"> * The FOV calculation this class performs includes a post-processing stage that guarantees symmetry for both LOS and</a>
<span class="sourceLineNo">038</span><a id="line.38"> * FOV. This works by checking every cell that is within the maximum radius for each non-wall cell, and if any cell A</a>
<span class="sourceLineNo">039</span><a id="line.39"> * can see cell B, but cell B can not yet see A, then B's cached FOV map will be altered so it can see A. The other</a>
<span class="sourceLineNo">040</span><a id="line.40"> * post-processing step provides distant lighting; if lights have been passed to the constructor as a Map of Coord keys</a>
<span class="sourceLineNo">041</span><a id="line.41"> * to Integer values, then the Coords in that Map that are walkable squares will emit light up to a radius equal to</a>
<span class="sourceLineNo">042</span><a id="line.42"> * their value in that Map. Cells with distant lighting will always be in FOV if they could be seen at up to radius</a>
<span class="sourceLineNo">043</span><a id="line.43"> * equal to maxLOSRadius, which defaults to 62 and is calculated for every FOVCache as an LOS cache. Calculating distant</a>
<span class="sourceLineNo">044</span><a id="line.44"> * lighting adds a somewhat substantial amount of time to each caching attempt, estimated at tripling the amount of time</a>
<span class="sourceLineNo">045</span><a id="line.45"> * used in cases where there are very many lights in a large dungeon (in a 100x100 dungeon, with one light per 5x5 area</a>
<span class="sourceLineNo">046</span><a id="line.46"> * when the center of that area is walkable, for example), but the lighting is expected to be much less of a performance</a>
<span class="sourceLineNo">047</span><a id="line.47"> * hindrance on smaller maps (80x40, 60x60, anything smaller, etc.) or when there are simply less lights to process</a>
<span class="sourceLineNo">048</span><a id="line.48"> * (because distant lighting is meant to go beyond nearby cells, it needs to run through essentially all lights for every</a>
<span class="sourceLineNo">049</span><a id="line.49"> * cell it processes, and even though adding the lit area to FOV is very efficient and does not require recalculating</a>
<span class="sourceLineNo">050</span><a id="line.50"> * FOV, having lots of lights means lots of work per cell).</a>
<span class="sourceLineNo">051</span><a id="line.51"> * &lt;br&gt;</a>
<span class="sourceLineNo">052</span><a id="line.52"> * This class extends FOV and can be used as a replacement for FOV in some cases. Generally, FOVCache provides methods</a>
<span class="sourceLineNo">053</span><a id="line.53"> * that allow faster manipulation and checks of certain values (such as a simple case of whether a cell can be seen from</a>
<span class="sourceLineNo">054</span><a id="line.54"> * another cell at a given FOV radius), but will fall back to Shadowcasting FOV (without using the cache) if any calls</a>
<span class="sourceLineNo">055</span><a id="line.55"> * to FOV methods are made that have not had their needed information cached. Uncached calls to FOV will not have some</a>
<span class="sourceLineNo">056</span><a id="line.56"> * of the niceties FOVCache can provide, like distant lights. If different light levels are needed (which Shadowcasting</a>
<span class="sourceLineNo">057</span><a id="line.57"> * does not provide), you can call Graded variants on the FOV methods, which will fall back to a Ripple FOV instead and</a>
<span class="sourceLineNo">058</span><a id="line.58"> * will have values between 0.0 and 1.0 instead of only those two extremes.</a>
<span class="sourceLineNo">059</span><a id="line.59"> * &lt;br&gt;</a>
<span class="sourceLineNo">060</span><a id="line.60"> * Conservation of memory usage is a primary concern for this class; storing a full 2D array for every cell on a map</a>
<span class="sourceLineNo">061</span><a id="line.61"> * that is even moderately large uses outrageous amounts of RAM, and attempting that naive approach on a 256x256 map</a>
<span class="sourceLineNo">062</span><a id="line.62"> * would use more than 4 GB of RAM for purely the data from storing bytes or booleans, not including the JVM's overhead</a>
<span class="sourceLineNo">063</span><a id="line.63"> * of between 12 and 19 bytes for every array. Using smaller maps helps both this class and any other approach (less</a>
<span class="sourceLineNo">064</span><a id="line.64"> * cells to store FOV for), and at least for FOVCache, using smaller maxRadius values can reduce memory usage as well.</a>
<span class="sourceLineNo">065</span><a id="line.65"> * For a normal 100x100 map, storing one byte[][] for every cell, and storing a 2D array of those (which has a minimal</a>
<span class="sourceLineNo">066</span><a id="line.66"> * effect on memory consumption vs. a 1D array in this case), the resulting byte[][][][] will use 112,161,616 bytes of</a>
<span class="sourceLineNo">067</span><a id="line.67"> * RAM, approximately 110 MB; this would still need an additional step of processing when used to limit a requested</a>
<span class="sourceLineNo">068</span><a id="line.68"> * FOV map stored in it to the appropriate vision range. To contrast, the current version of FOVCache on the same size</a>
<span class="sourceLineNo">069</span><a id="line.69"> * of map, caching 12 separate FOV radii, uses approximately 6.2 MB. Tests run on ten 100x100 dungeons ran the gamut</a>
<span class="sourceLineNo">070</span><a id="line.70"> * between 6,049,760 and 6,404,336 bytes (the layout of the dungeon doesn't affect memory usage of the naive case, but</a>
<span class="sourceLineNo">071</span><a id="line.71"> * it does have a small effect on the compressed version). To actually use the compressed maps does take an additional</a>
<span class="sourceLineNo">072</span><a id="line.72"> * processing step, but careful benchmarking indicates running FOV for a roughly 12 radius (Radius.SQUARE kind) area</a>
<span class="sourceLineNo">073</span><a id="line.73"> * takes twice as long as simply extracting a cached FOV map, and the advantage for the cache is greater for larger FOV</a>
<span class="sourceLineNo">074</span><a id="line.74"> * radii (but the cache also uses slightly more memory). This compares against the fastest FOV type, Shadowcasting, but</a>
<span class="sourceLineNo">075</span><a id="line.75"> * to get distance information from an FOV you need to use either the customized FOV algorithm in this class (Slope</a>
<span class="sourceLineNo">076</span><a id="line.76"> * Shadowcasting), or to use the Ripple FOV type. Ripple does respect translucent objects, which neither shadowcasting</a>
<span class="sourceLineNo">077</span><a id="line.77"> * nor this class' slope shadowcasting does, but getting 16 FOV levels from the cache for every walkable cell on a</a>
<span class="sourceLineNo">078</span><a id="line.78"> * 100x100 dungeon map takes approximately 19 ms while running Ripple FOV for the same set of cells takes over 700 ms.</a>
<span class="sourceLineNo">079</span><a id="line.79"> * Benchmarks are conducted using JMH, a tool developed by the OpenJDK team, in a Maven module called</a>
<span class="sourceLineNo">080</span><a id="line.80"> * squidlib-performance that is not distributed with SquidLib but is available if you download the SquidLib source code.</a>
<span class="sourceLineNo">081</span><a id="line.81"> * However, because the benchmarks don't take the initial calculations into account, they can be somewhat misleading;</a>
<span class="sourceLineNo">082</span><a id="line.82"> * there's also overhead and complexity involved with the background threads this uses. Newer benchmarks that test some</a>
<span class="sourceLineNo">083</span><a id="line.83"> * more recent additions to FOV, like {@link FOV#reuseFOV(double[][], double[][], int, int, double)}, show those methods</a>
<span class="sourceLineNo">084</span><a id="line.84"> * as faster than retrieving a compressed FOV map from FOVCache, largely because they can avoid creating garbage.</a>
<span class="sourceLineNo">085</span><a id="line.85"> *</a>
<span class="sourceLineNo">086</span><a id="line.86"> * @see squidpony.squidmath.CoordPacker has various utilities for operating on compressed data of this kind.</a>
<span class="sourceLineNo">087</span><a id="line.87"> * Created by Tommy Ettinger on 10/7/2015.</a>
<span class="sourceLineNo">088</span><a id="line.88"> * @author Tommy Ettinger</a>
<span class="sourceLineNo">089</span><a id="line.89"> */</a>
<span class="sourceLineNo">090</span><a id="line.90">@GwtIncompatible</a>
<span class="sourceLineNo">091</span><a id="line.91">public class FOVCache extends FOV {</a>
<span class="sourceLineNo">092</span><a id="line.92"></a>
<span class="sourceLineNo">093</span><a id="line.93">    protected int maxRadius, maxLOSRadius;</a>
<span class="sourceLineNo">094</span><a id="line.94">    protected int width;</a>
<span class="sourceLineNo">095</span><a id="line.95">    protected int height;</a>
<span class="sourceLineNo">096</span><a id="line.96">    protected int mapLimit;</a>
<span class="sourceLineNo">097</span><a id="line.97">    protected int limit;</a>
<span class="sourceLineNo">098</span><a id="line.98">    protected double[][] resMap;</a>
<span class="sourceLineNo">099</span><a id="line.99">    protected Radius radiusKind;</a>
<span class="sourceLineNo">100</span><a id="line.100">    protected short[][][] cache;</a>
<span class="sourceLineNo">101</span><a id="line.101">    protected short[][][] tmpCache;</a>
<span class="sourceLineNo">102</span><a id="line.102">    protected short[][] losCache;</a>
<span class="sourceLineNo">103</span><a id="line.103">    protected boolean complete, qualityComplete, refreshComplete;</a>
<span class="sourceLineNo">104</span><a id="line.104">    protected FOV fov, gradedFOV;</a>
<span class="sourceLineNo">105</span><a id="line.105">    protected short[][] ALL_WALLS;</a>
<span class="sourceLineNo">106</span><a id="line.106">    protected short[] wallMap;</a>
<span class="sourceLineNo">107</span><a id="line.107">    protected double[][] atan2Cache, directionAngles;</a>
<span class="sourceLineNo">108</span><a id="line.108">    protected short[][] distanceCache;</a>
<span class="sourceLineNo">109</span><a id="line.109">    protected Coord[][] waves;</a>
<span class="sourceLineNo">110</span><a id="line.110">    protected final int NUM_THREADS;</a>
<span class="sourceLineNo">111</span><a id="line.111">    private ExecutorService executor;</a>
<span class="sourceLineNo">112</span><a id="line.112">    protected double fovPermissiveness;</a>
<span class="sourceLineNo">113</span><a id="line.113">    protected OrderedMap&lt;Coord, Integer&gt; lights;</a>
<span class="sourceLineNo">114</span><a id="line.114">    protected Coord[] lightSources;</a>
<span class="sourceLineNo">115</span><a id="line.115">    protected int[] lightBrightnesses;</a>
<span class="sourceLineNo">116</span><a id="line.116">    private double[][] levels;</a>
<span class="sourceLineNo">117</span><a id="line.117">    protected double decay;</a>
<span class="sourceLineNo">118</span><a id="line.118">    private Thread performanceThread = null, qualityThread = null;</a>
<span class="sourceLineNo">119</span><a id="line.119">    private static final double HALF_PI = Math.PI * 0.5, QUARTER_PI = Math.PI * 0.25125,</a>
<span class="sourceLineNo">120</span><a id="line.120">            SLIVER_PI = Math.PI * 0.05, PI2 = Math.PI * 2;</a>
<span class="sourceLineNo">121</span><a id="line.121"></a>
<span class="sourceLineNo">122</span><a id="line.122">    /**</a>
<span class="sourceLineNo">123</span><a id="line.123">     * Create an FOVCache for a given map (as a char[][]), caching all FOV radii from 0 up to and including maxRadius,</a>
<span class="sourceLineNo">124</span><a id="line.124">     * using the given Radius enum to determine FOV shape.  Upon calling cacheAllPerformance() or cacheAll(),</a>
<span class="sourceLineNo">125</span><a id="line.125">     * (collectively, the caching methods), the object this creates will run a medium-quality, fairly permissive FOV</a>
<span class="sourceLineNo">126</span><a id="line.126">     * calculation for every cell on the map using 8 threads, and if cacheAll() was called, will then ensure</a>
<span class="sourceLineNo">127</span><a id="line.127">     * symmetry (if cell A can see cell B, then it will make cell B able to see cell A even if it couldn't in an earlier</a>
<span class="sourceLineNo">128</span><a id="line.128">     * step). At the same time as the first caching method call, this will calculate Line of Sight at maxLOSRadius (here</a>
<span class="sourceLineNo">129</span><a id="line.129">     * it is given a default of 62) for all cells. Walls will always have no cells in their FOV or LOS.</a>
<span class="sourceLineNo">130</span><a id="line.130">     * @param map a char[][] as returned by SquidLib's map generators</a>
<span class="sourceLineNo">131</span><a id="line.131">     * @param maxRadius the longest radius that will possibly need to be cached for FOV; LOS is separate</a>
<span class="sourceLineNo">132</span><a id="line.132">     * @param radiusKind a Radius enum that determines the shape of each FOV area</a>
<span class="sourceLineNo">133</span><a id="line.133">     */</a>
<span class="sourceLineNo">134</span><a id="line.134">    public FOVCache(char[][] map, int maxRadius, Radius radiusKind)</a>
<span class="sourceLineNo">135</span><a id="line.135">    {</a>
<span class="sourceLineNo">136</span><a id="line.136">        if(map == null || map.length == 0)</a>
<span class="sourceLineNo">137</span><a id="line.137">            throw new UnsupportedOperationException("The map used by FOVCache must not be null or empty");</a>
<span class="sourceLineNo">138</span><a id="line.138">        init();</a>
<span class="sourceLineNo">139</span><a id="line.139">        NUM_THREADS = 8;</a>
<span class="sourceLineNo">140</span><a id="line.140">        executor = Executors.newFixedThreadPool(NUM_THREADS);</a>
<span class="sourceLineNo">141</span><a id="line.141">        width = map.length;</a>
<span class="sourceLineNo">142</span><a id="line.142">        height = map[0].length;</a>
<span class="sourceLineNo">143</span><a id="line.143">        if(width &gt; 256 || height &gt; 256)</a>
<span class="sourceLineNo">144</span><a id="line.144">            throw new UnsupportedOperationException("Map size is too large to efficiently cache, aborting");</a>
<span class="sourceLineNo">145</span><a id="line.145">        mapLimit = width * height;</a>
<span class="sourceLineNo">146</span><a id="line.146">        if(maxRadius &lt;= 0 || maxRadius &gt;= 63)</a>
<span class="sourceLineNo">147</span><a id="line.147">            throw new UnsupportedOperationException("FOV radius is incorrect. Must be 0 &lt; maxRadius &lt; 63");</a>
<span class="sourceLineNo">148</span><a id="line.148">        fov = new FOV(FOV.SHADOW);</a>
<span class="sourceLineNo">149</span><a id="line.149">        gradedFOV = new FOV(RIPPLE);</a>
<span class="sourceLineNo">150</span><a id="line.150">        resMap = DungeonUtility.generateResistances(map);</a>
<span class="sourceLineNo">151</span><a id="line.151">        this.maxRadius = Math.max(1, maxRadius);</a>
<span class="sourceLineNo">152</span><a id="line.152">        this.maxLOSRadius = 62;</a>
<span class="sourceLineNo">153</span><a id="line.153">        decay = 1.0 / maxRadius;</a>
<span class="sourceLineNo">154</span><a id="line.154">        this.radiusKind = radiusKind;</a>
<span class="sourceLineNo">155</span><a id="line.155">        fovPermissiveness = 0.9;</a>
<span class="sourceLineNo">156</span><a id="line.156">        lights = new OrderedMap&lt;&gt;();</a>
<span class="sourceLineNo">157</span><a id="line.157">        cache = new short[mapLimit][][];</a>
<span class="sourceLineNo">158</span><a id="line.158">        tmpCache = new short[mapLimit][][];</a>
<span class="sourceLineNo">159</span><a id="line.159">        losCache = new short[mapLimit][];</a>
<span class="sourceLineNo">160</span><a id="line.160">        ALL_WALLS = new short[maxRadius + 1][];</a>
<span class="sourceLineNo">161</span><a id="line.161">        for (int i = 0; i &lt; maxRadius + 1; i++) {</a>
<span class="sourceLineNo">162</span><a id="line.162">            ALL_WALLS[i] = ALL_WALL;</a>
<span class="sourceLineNo">163</span><a id="line.163">        }</a>
<span class="sourceLineNo">164</span><a id="line.164">        limit = 0x10000;</a>
<span class="sourceLineNo">165</span><a id="line.165">        if(height &lt;= 128) {</a>
<span class="sourceLineNo">166</span><a id="line.166">            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">167</span><a id="line.167">            if (width &lt;= 128) {</a>
<span class="sourceLineNo">168</span><a id="line.168">                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">169</span><a id="line.169">                if (width &lt;= 64) {</a>
<span class="sourceLineNo">170</span><a id="line.170">                    limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">171</span><a id="line.171">                    if (height &lt;= 64) {</a>
<span class="sourceLineNo">172</span><a id="line.172">                        limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">173</span><a id="line.173">                        if (height &lt;= 32) {</a>
<span class="sourceLineNo">174</span><a id="line.174">                            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">175</span><a id="line.175">                            if (width &lt;= 32) {</a>
<span class="sourceLineNo">176</span><a id="line.176">                                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">177</span><a id="line.177">                            }</a>
<span class="sourceLineNo">178</span><a id="line.178">                        }</a>
<span class="sourceLineNo">179</span><a id="line.179">                    }</a>
<span class="sourceLineNo">180</span><a id="line.180">                }</a>
<span class="sourceLineNo">181</span><a id="line.181">            }</a>
<span class="sourceLineNo">182</span><a id="line.182">        }</a>
<span class="sourceLineNo">183</span><a id="line.183">        preloadMeasurements();</a>
<span class="sourceLineNo">184</span><a id="line.184">        complete = false;</a>
<span class="sourceLineNo">185</span><a id="line.185">    }</a>
<span class="sourceLineNo">186</span><a id="line.186"></a>
<span class="sourceLineNo">187</span><a id="line.187">    /**</a>
<span class="sourceLineNo">188</span><a id="line.188">     * Create an FOVCache for a given map (as a char[][]), caching all FOV radii from 0 up to and including maxRadius,</a>
<span class="sourceLineNo">189</span><a id="line.189">     * using the given Radius enum to determine FOV shape.  Upon calling cacheAllPerformance() or cacheAll(),</a>
<span class="sourceLineNo">190</span><a id="line.190">     * (collectively, the caching methods), the object this creates will run a medium-quality, fairly permissive FOV</a>
<span class="sourceLineNo">191</span><a id="line.191">     * calculation for every cell on the map using a number of threads equal to threadCount, and if cacheAll()</a>
<span class="sourceLineNo">192</span><a id="line.192">     * was called, will then ensure symmetry (if cell A can see cell B, then it will make cell B able to see cell A even</a>
<span class="sourceLineNo">193</span><a id="line.193">     * if it couldn't in an earlier step). At the same time as the first caching method call, this will calculate Line</a>
<span class="sourceLineNo">194</span><a id="line.194">     * of Sight at maximum range (given by maxLOSRadius) for all cells. Walls will always have no cells in their FOV or</a>
<span class="sourceLineNo">195</span><a id="line.195">     * in their LOS.</a>
<span class="sourceLineNo">196</span><a id="line.196">     * @param map a char[][] as returned by SquidLib's map generators</a>
<span class="sourceLineNo">197</span><a id="line.197">     * @param maxRadius the longest radius that will possibly need to be cached for FOV; LOS is separate</a>
<span class="sourceLineNo">198</span><a id="line.198">     * @param maxLOSRadius the longest radius that will possibly need to be cached for LOS, must be less than 63</a>
<span class="sourceLineNo">199</span><a id="line.199">     * @param radiusKind a Radius enum that determines the shape of each FOV area</a>
<span class="sourceLineNo">200</span><a id="line.200">     * @param threadCount how many threads to use during the full-map calculations</a>
<span class="sourceLineNo">201</span><a id="line.201">     */</a>
<span class="sourceLineNo">202</span><a id="line.202">    public FOVCache(char[][] map, int maxRadius, int maxLOSRadius, Radius radiusKind, int threadCount)</a>
<span class="sourceLineNo">203</span><a id="line.203">    {</a>
<span class="sourceLineNo">204</span><a id="line.204">        if(map == null || map.length == 0)</a>
<span class="sourceLineNo">205</span><a id="line.205">            throw new UnsupportedOperationException("The map used by FOVCache must not be null or empty");</a>
<span class="sourceLineNo">206</span><a id="line.206">        init();</a>
<span class="sourceLineNo">207</span><a id="line.207">        NUM_THREADS = threadCount;</a>
<span class="sourceLineNo">208</span><a id="line.208">        executor = Executors.newFixedThreadPool(NUM_THREADS);</a>
<span class="sourceLineNo">209</span><a id="line.209">        width = map.length;</a>
<span class="sourceLineNo">210</span><a id="line.210">        height = map[0].length;</a>
<span class="sourceLineNo">211</span><a id="line.211">        if(width &gt; 256 || height &gt; 256)</a>
<span class="sourceLineNo">212</span><a id="line.212">            throw new UnsupportedOperationException("Map size is too large to efficiently cache, aborting");</a>
<span class="sourceLineNo">213</span><a id="line.213">        mapLimit = width * height;</a>
<span class="sourceLineNo">214</span><a id="line.214">        if(maxRadius &lt;= 0 || maxRadius &gt;= 63)</a>
<span class="sourceLineNo">215</span><a id="line.215">            throw new UnsupportedOperationException("FOV radius is incorrect. Must be 0 &lt; maxRadius &lt; 63");</a>
<span class="sourceLineNo">216</span><a id="line.216">        if(maxLOSRadius &lt;= 0 || maxLOSRadius &gt;= 63)</a>
<span class="sourceLineNo">217</span><a id="line.217">            throw new UnsupportedOperationException("LOS radius is incorrect. Must be 0 &lt; maxLOSRadius &lt; 63");</a>
<span class="sourceLineNo">218</span><a id="line.218">        fov = new FOV(FOV.SHADOW);</a>
<span class="sourceLineNo">219</span><a id="line.219">        gradedFOV = new FOV(RIPPLE);</a>
<span class="sourceLineNo">220</span><a id="line.220">        resMap = DungeonUtility.generateResistances(map);</a>
<span class="sourceLineNo">221</span><a id="line.221">        this.maxRadius = Math.max(1, maxRadius);</a>
<span class="sourceLineNo">222</span><a id="line.222">        this.maxLOSRadius = Math.max(1, maxLOSRadius);</a>
<span class="sourceLineNo">223</span><a id="line.223">        decay = 1.0 / maxRadius;</a>
<span class="sourceLineNo">224</span><a id="line.224">        this.radiusKind = radiusKind;</a>
<span class="sourceLineNo">225</span><a id="line.225">        fovPermissiveness = 0.9;</a>
<span class="sourceLineNo">226</span><a id="line.226">        lights = new OrderedMap&lt;&gt;();</a>
<span class="sourceLineNo">227</span><a id="line.227">        cache = new short[mapLimit][][];</a>
<span class="sourceLineNo">228</span><a id="line.228">        tmpCache = new short[mapLimit][][];</a>
<span class="sourceLineNo">229</span><a id="line.229">        losCache = new short[mapLimit][];</a>
<span class="sourceLineNo">230</span><a id="line.230">        ALL_WALLS = new short[maxRadius][];</a>
<span class="sourceLineNo">231</span><a id="line.231">        for (int i = 0; i &lt; maxRadius; i++) {</a>
<span class="sourceLineNo">232</span><a id="line.232">            ALL_WALLS[i] = ALL_WALL;</a>
<span class="sourceLineNo">233</span><a id="line.233">        }</a>
<span class="sourceLineNo">234</span><a id="line.234">        limit = 0x10000;</a>
<span class="sourceLineNo">235</span><a id="line.235">        if(height &lt;= 128) {</a>
<span class="sourceLineNo">236</span><a id="line.236">            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">237</span><a id="line.237">            if (width &lt;= 128) {</a>
<span class="sourceLineNo">238</span><a id="line.238">                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">239</span><a id="line.239">                if (width &lt;= 64) {</a>
<span class="sourceLineNo">240</span><a id="line.240">                    limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">241</span><a id="line.241">                    if (height &lt;= 64) {</a>
<span class="sourceLineNo">242</span><a id="line.242">                        limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">243</span><a id="line.243">                        if (height &lt;= 32) {</a>
<span class="sourceLineNo">244</span><a id="line.244">                            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">245</span><a id="line.245">                            if (width &lt;= 32) {</a>
<span class="sourceLineNo">246</span><a id="line.246">                                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">247</span><a id="line.247">                            }</a>
<span class="sourceLineNo">248</span><a id="line.248">                        }</a>
<span class="sourceLineNo">249</span><a id="line.249">                    }</a>
<span class="sourceLineNo">250</span><a id="line.250">                }</a>
<span class="sourceLineNo">251</span><a id="line.251">            }</a>
<span class="sourceLineNo">252</span><a id="line.252">        }</a>
<span class="sourceLineNo">253</span><a id="line.253">        preloadMeasurements();</a>
<span class="sourceLineNo">254</span><a id="line.254">        complete = false;</a>
<span class="sourceLineNo">255</span><a id="line.255">    }</a>
<span class="sourceLineNo">256</span><a id="line.256"></a>
<span class="sourceLineNo">257</span><a id="line.257">    /**</a>
<span class="sourceLineNo">258</span><a id="line.258">     * Create an FOVCache for a given map (as a char[][]), caching all FOV radii from 0 up to and including maxRadius,</a>
<span class="sourceLineNo">259</span><a id="line.259">     * using the given Radius enum to determine FOV shape.  Upon calling cacheAllPerformance() or cacheAll(),</a>
<span class="sourceLineNo">260</span><a id="line.260">     * (collectively, the caching methods), the object this creates will run a medium-quality, fairly permissive FOV</a>
<span class="sourceLineNo">261</span><a id="line.261">     * calculation for every cell on the map using a number of threads equal to threadCount, and if cacheAll()</a>
<span class="sourceLineNo">262</span><a id="line.262">     * was called, will then ensure symmetry (if cell A can see cell B, then it will make cell B able to see cell A even</a>
<span class="sourceLineNo">263</span><a id="line.263">     * if it couldn't in an earlier step). At the same time as the first caching method call, this will calculate Line</a>
<span class="sourceLineNo">264</span><a id="line.264">     * of Sight at maximum range (given by maxLOSRadius) for all cells. Walls will always have no cells in their FOV or</a>
<span class="sourceLineNo">265</span><a id="line.265">     * in their LOS. This constructor also allows you to initialize light sources in the level using the lights</a>
<span class="sourceLineNo">266</span><a id="line.266">     * parameter; any Coord keys should correspond to walkable cells (or they will be ignored), and the values will be</a>
<span class="sourceLineNo">267</span><a id="line.267">     * the range those cells should light up..</a>
<span class="sourceLineNo">268</span><a id="line.268">     * @param map a char[][] as returned by SquidLib's map generators</a>
<span class="sourceLineNo">269</span><a id="line.269">     * @param maxRadius the longest radius that will possibly need to be cached for FOV; LOS is separate</a>
<span class="sourceLineNo">270</span><a id="line.270">     * @param maxLOSRadius the longest radius that will possibly need to be cached for LOS, must be less than 63</a>
<span class="sourceLineNo">271</span><a id="line.271">     * @param radiusKind a Radius enum that determines the shape of each FOV area</a>
<span class="sourceLineNo">272</span><a id="line.272">     * @param threadCount how many threads to use during the full-map calculations</a>
<span class="sourceLineNo">273</span><a id="line.273">     * @param lights a Map of Coords (which should be walkable) to the radii they should light (not for moving lights)</a>
<span class="sourceLineNo">274</span><a id="line.274">     */</a>
<span class="sourceLineNo">275</span><a id="line.275">    public FOVCache(char[][] map, int maxRadius, int maxLOSRadius, Radius radiusKind, int threadCount, Map&lt;Coord, Integer&gt; lights)</a>
<span class="sourceLineNo">276</span><a id="line.276">    {</a>
<span class="sourceLineNo">277</span><a id="line.277">        if(map == null || map.length == 0)</a>
<span class="sourceLineNo">278</span><a id="line.278">            throw new UnsupportedOperationException("The map used by FOVCache must not be null or empty");</a>
<span class="sourceLineNo">279</span><a id="line.279">        init();</a>
<span class="sourceLineNo">280</span><a id="line.280">        NUM_THREADS = threadCount;</a>
<span class="sourceLineNo">281</span><a id="line.281">        executor = Executors.newFixedThreadPool(NUM_THREADS);</a>
<span class="sourceLineNo">282</span><a id="line.282">        width = map.length;</a>
<span class="sourceLineNo">283</span><a id="line.283">        height = map[0].length;</a>
<span class="sourceLineNo">284</span><a id="line.284">        if(width &gt; 256 || height &gt; 256)</a>
<span class="sourceLineNo">285</span><a id="line.285">            throw new UnsupportedOperationException("Map size is too large to efficiently cache, aborting");</a>
<span class="sourceLineNo">286</span><a id="line.286">        mapLimit = width * height;</a>
<span class="sourceLineNo">287</span><a id="line.287">        if(maxRadius &lt;= 0 || maxRadius &gt;= 63)</a>
<span class="sourceLineNo">288</span><a id="line.288">            throw new UnsupportedOperationException("FOV radius is incorrect. Must be 0 &lt; maxRadius &lt; 63");</a>
<span class="sourceLineNo">289</span><a id="line.289">        if(maxLOSRadius &lt;= 0 || maxLOSRadius &gt;= 63)</a>
<span class="sourceLineNo">290</span><a id="line.290">            throw new UnsupportedOperationException("LOS radius is incorrect. Must be 0 &lt; maxLOSRadius &lt; 63");</a>
<span class="sourceLineNo">291</span><a id="line.291">        fov = new FOV(FOV.SHADOW);</a>
<span class="sourceLineNo">292</span><a id="line.292">        gradedFOV = new FOV(RIPPLE);</a>
<span class="sourceLineNo">293</span><a id="line.293">        resMap = DungeonUtility.generateResistances(map);</a>
<span class="sourceLineNo">294</span><a id="line.294">        this.maxRadius = Math.max(1, maxRadius);</a>
<span class="sourceLineNo">295</span><a id="line.295">        this.maxLOSRadius = Math.max(1, maxLOSRadius);</a>
<span class="sourceLineNo">296</span><a id="line.296">        decay = 1.0 / maxRadius;</a>
<span class="sourceLineNo">297</span><a id="line.297">        this.radiusKind = radiusKind;</a>
<span class="sourceLineNo">298</span><a id="line.298">        fovPermissiveness = 0.9;</a>
<span class="sourceLineNo">299</span><a id="line.299">        this.lights = new OrderedMap&lt;&gt;(lights);</a>
<span class="sourceLineNo">300</span><a id="line.300">        cache = new short[mapLimit][][];</a>
<span class="sourceLineNo">301</span><a id="line.301">        tmpCache = new short[mapLimit][][];</a>
<span class="sourceLineNo">302</span><a id="line.302">        losCache = new short[mapLimit][];</a>
<span class="sourceLineNo">303</span><a id="line.303">        ALL_WALLS = new short[maxRadius][];</a>
<span class="sourceLineNo">304</span><a id="line.304">        for (int i = 0; i &lt; maxRadius; i++) {</a>
<span class="sourceLineNo">305</span><a id="line.305">            ALL_WALLS[i] = ALL_WALL;</a>
<span class="sourceLineNo">306</span><a id="line.306">        }</a>
<span class="sourceLineNo">307</span><a id="line.307">        limit = 0x10000;</a>
<span class="sourceLineNo">308</span><a id="line.308">        if(height &lt;= 128) {</a>
<span class="sourceLineNo">309</span><a id="line.309">            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">310</span><a id="line.310">            if (width &lt;= 128) {</a>
<span class="sourceLineNo">311</span><a id="line.311">                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">312</span><a id="line.312">                if (width &lt;= 64) {</a>
<span class="sourceLineNo">313</span><a id="line.313">                    limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">314</span><a id="line.314">                    if (height &lt;= 64) {</a>
<span class="sourceLineNo">315</span><a id="line.315">                        limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">316</span><a id="line.316">                        if (height &lt;= 32) {</a>
<span class="sourceLineNo">317</span><a id="line.317">                            limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">318</span><a id="line.318">                            if (width &lt;= 32) {</a>
<span class="sourceLineNo">319</span><a id="line.319">                                limit &gt;&gt;= 1;</a>
<span class="sourceLineNo">320</span><a id="line.320">                            }</a>
<span class="sourceLineNo">321</span><a id="line.321">                        }</a>
<span class="sourceLineNo">322</span><a id="line.322">                    }</a>
<span class="sourceLineNo">323</span><a id="line.323">                }</a>
<span class="sourceLineNo">324</span><a id="line.324">            }</a>
<span class="sourceLineNo">325</span><a id="line.325">        }</a>
<span class="sourceLineNo">326</span><a id="line.326">        preloadMeasurements();</a>
<span class="sourceLineNo">327</span><a id="line.327">        complete = false;</a>
<span class="sourceLineNo">328</span><a id="line.328">    }</a>
<span class="sourceLineNo">329</span><a id="line.329"></a>
<span class="sourceLineNo">330</span><a id="line.330">    private void preloadLights()</a>
<span class="sourceLineNo">331</span><a id="line.331">    {</a>
<span class="sourceLineNo">332</span><a id="line.332"></a>
<span class="sourceLineNo">333</span><a id="line.333">        Iterator&lt;Coord&gt; it = lights.keySet().iterator();</a>
<span class="sourceLineNo">334</span><a id="line.334">        Coord pos;</a>
<span class="sourceLineNo">335</span><a id="line.335">        while (it.hasNext())</a>
<span class="sourceLineNo">336</span><a id="line.336">        {</a>
<span class="sourceLineNo">337</span><a id="line.337">            pos = it.next();</a>
<span class="sourceLineNo">338</span><a id="line.338">            if(resMap[pos.x][pos.y] &gt;= 1.0)</a>
<span class="sourceLineNo">339</span><a id="line.339">                it.remove();</a>
<span class="sourceLineNo">340</span><a id="line.340">        }</a>
<span class="sourceLineNo">341</span><a id="line.341"></a>
<span class="sourceLineNo">342</span><a id="line.342">        lightSources = lights.keySet().toArray(new Coord[lights.size()]);</a>
<span class="sourceLineNo">343</span><a id="line.343">        lightBrightnesses = new int[lights.size()];</a>
<span class="sourceLineNo">344</span><a id="line.344">        for (int i = 0; i &lt; lightSources.length; i++) {</a>
<span class="sourceLineNo">345</span><a id="line.345">            lightBrightnesses[i] = lights.get(lightSources[i]);</a>
<span class="sourceLineNo">346</span><a id="line.346">        }</a>
<span class="sourceLineNo">347</span><a id="line.347">    }</a>
<span class="sourceLineNo">348</span><a id="line.348"></a>
<span class="sourceLineNo">349</span><a id="line.349">    private void preloadMeasurements()</a>
<span class="sourceLineNo">350</span><a id="line.350">    {</a>
<span class="sourceLineNo">351</span><a id="line.351">        levels = new double[maxRadius + 1][maxRadius + 1];</a>
<span class="sourceLineNo">352</span><a id="line.352">        //levels[maxRadius][maxRadius] = 1.0;</a>
<span class="sourceLineNo">353</span><a id="line.353">        for (int i = 1; i &lt;= maxRadius; i++) {</a>
<span class="sourceLineNo">354</span><a id="line.354">            System.arraycopy(generateLightLevels(i), 0, levels[i], maxRadius - i + 1, i);</a>
<span class="sourceLineNo">355</span><a id="line.355">        }</a>
<span class="sourceLineNo">356</span><a id="line.356">        boolean[][] walls = new boolean[width][height];</a>
<span class="sourceLineNo">357</span><a id="line.357">        for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">358</span><a id="line.358">            for (int j = 0; j &lt; height; j++) {</a>
<span class="sourceLineNo">359</span><a id="line.359">                walls[i][j] = resMap[i][j] &gt;= 1.0;</a>
<span class="sourceLineNo">360</span><a id="line.360">            }</a>
<span class="sourceLineNo">361</span><a id="line.361">        }</a>
<span class="sourceLineNo">362</span><a id="line.362">        wallMap = pack(walls);</a>
<span class="sourceLineNo">363</span><a id="line.363"></a>
<span class="sourceLineNo">364</span><a id="line.364">        preloadLights();</a>
<span class="sourceLineNo">365</span><a id="line.365"></a>
<span class="sourceLineNo">366</span><a id="line.366">        atan2Cache = new double[maxRadius * 2 + 1][maxRadius * 2 + 1];</a>
<span class="sourceLineNo">367</span><a id="line.367">        distanceCache = new short[maxRadius * 2 + 1][maxRadius * 2 + 1];</a>
<span class="sourceLineNo">368</span><a id="line.368">        waves = new Coord[maxRadius + 1][];</a>
<span class="sourceLineNo">369</span><a id="line.369">        waves[0] = new Coord[]{Coord.get(maxRadius, maxRadius)};</a>
<span class="sourceLineNo">370</span><a id="line.370"></a>
<span class="sourceLineNo">371</span><a id="line.371">        ShortVLA[] positionsAtDistance = new ShortVLA[maxRadius + 1];</a>
<span class="sourceLineNo">372</span><a id="line.372">        for (int i = 0; i &lt; maxRadius + 1; i++) {</a>
<span class="sourceLineNo">373</span><a id="line.373">            positionsAtDistance[i] = new ShortVLA(i * 8 + 1);</a>
<span class="sourceLineNo">374</span><a id="line.374">        }</a>
<span class="sourceLineNo">375</span><a id="line.375">        short tmp, inverse_tmp;</a>
<span class="sourceLineNo">376</span><a id="line.376">        for (int i = 0; i &lt;= maxRadius; i++) {</a>
<span class="sourceLineNo">377</span><a id="line.377">            for (int j = 0; j &lt;= maxRadius; j++) {</a>
<span class="sourceLineNo">378</span><a id="line.378">                tmp = distance(i, j);</a>
<span class="sourceLineNo">379</span><a id="line.379">                inverse_tmp = (short)(maxRadius + 1 - tmp / 2);</a>
<span class="sourceLineNo">380</span><a id="line.380"></a>
<span class="sourceLineNo">381</span><a id="line.381">                atan2Cache[maxRadius + i][maxRadius + j] = NumberTools.atan2(j, i);</a>
<span class="sourceLineNo">382</span><a id="line.382">                if(atan2Cache[maxRadius + i][maxRadius + j] &lt; 0)</a>
<span class="sourceLineNo">383</span><a id="line.383">                    atan2Cache[maxRadius + i][maxRadius + j] += PI2;</a>
<span class="sourceLineNo">384</span><a id="line.384">                if(tmp &gt; 0) {</a>
<span class="sourceLineNo">385</span><a id="line.385">                    atan2Cache[maxRadius - i][maxRadius + j] = NumberTools.atan2(j, -i);</a>
<span class="sourceLineNo">386</span><a id="line.386">                    if(atan2Cache[maxRadius - i][maxRadius + j] &lt; 0)</a>
<span class="sourceLineNo">387</span><a id="line.387">                        atan2Cache[maxRadius - i][maxRadius + j] += PI2;</a>
<span class="sourceLineNo">388</span><a id="line.388"></a>
<span class="sourceLineNo">389</span><a id="line.389">                    atan2Cache[maxRadius + i][maxRadius - j] = NumberTools.atan2(-j, i);</a>
<span class="sourceLineNo">390</span><a id="line.390">                    if(atan2Cache[maxRadius + i][maxRadius - j] &lt; 0)</a>
<span class="sourceLineNo">391</span><a id="line.391">                        atan2Cache[maxRadius + i][maxRadius - j] += PI2;</a>
<span class="sourceLineNo">392</span><a id="line.392"></a>
<span class="sourceLineNo">393</span><a id="line.393">                    atan2Cache[maxRadius - i][maxRadius - j] = NumberTools.atan2(-j, -i);</a>
<span class="sourceLineNo">394</span><a id="line.394">                    if(atan2Cache[maxRadius - i][maxRadius - j] &lt; 0)</a>
<span class="sourceLineNo">395</span><a id="line.395">                        atan2Cache[maxRadius - i][maxRadius - j] += PI2;</a>
<span class="sourceLineNo">396</span><a id="line.396"></a>
<span class="sourceLineNo">397</span><a id="line.397">                }</a>
<span class="sourceLineNo">398</span><a id="line.398">                if(tmp / 2 &lt;= maxRadius &amp;&amp; inverse_tmp &gt; 0) {</a>
<span class="sourceLineNo">399</span><a id="line.399">                    distanceCache[maxRadius + i][maxRadius + j] = inverse_tmp;</a>
<span class="sourceLineNo">400</span><a id="line.400">                    if (tmp &gt; 0) {</a>
<span class="sourceLineNo">401</span><a id="line.401">                        distanceCache[maxRadius - i][maxRadius + j] = inverse_tmp;</a>
<span class="sourceLineNo">402</span><a id="line.402">                        distanceCache[maxRadius + i][maxRadius - j] = inverse_tmp;</a>
<span class="sourceLineNo">403</span><a id="line.403">                        distanceCache[maxRadius - i][maxRadius - j] = inverse_tmp;</a>
<span class="sourceLineNo">404</span><a id="line.404">                        positionsAtDistance[tmp / 2].add(zEncode((short) (maxRadius + i), (short) (maxRadius + j)));</a>
<span class="sourceLineNo">405</span><a id="line.405">                        if (i &gt; 0)</a>
<span class="sourceLineNo">406</span><a id="line.406">                            positionsAtDistance[tmp / 2].add(zEncode((short) (maxRadius - i), (short) (maxRadius + j)));</a>
<span class="sourceLineNo">407</span><a id="line.407">                        if (j &gt; 0)</a>
<span class="sourceLineNo">408</span><a id="line.408">                            positionsAtDistance[tmp / 2].add(zEncode((short) (maxRadius + i), (short) (maxRadius - j)));</a>
<span class="sourceLineNo">409</span><a id="line.409">                        if(i &gt; 0 &amp;&amp; j &gt; 0)</a>
<span class="sourceLineNo">410</span><a id="line.410">                            positionsAtDistance[tmp / 2].add(zEncode((short) (maxRadius - i), (short) (maxRadius - j)));</a>
<span class="sourceLineNo">411</span><a id="line.411"></a>
<span class="sourceLineNo">412</span><a id="line.412">                    }else {</a>
<span class="sourceLineNo">413</span><a id="line.413">                        positionsAtDistance[0].add(zEncode((short) maxRadius, (short) maxRadius));</a>
<span class="sourceLineNo">414</span><a id="line.414">                    }</a>
<span class="sourceLineNo">415</span><a id="line.415">                }</a>
<span class="sourceLineNo">416</span><a id="line.416">            }</a>
<span class="sourceLineNo">417</span><a id="line.417">        }</a>
<span class="sourceLineNo">418</span><a id="line.418">        short[][] positionsZ = new short[maxRadius + 1][];</a>
<span class="sourceLineNo">419</span><a id="line.419">        for (int i = 0; i &lt;= maxRadius; i++) {</a>
<span class="sourceLineNo">420</span><a id="line.420">            positionsZ[i] = positionsAtDistance[i].toArray();</a>
<span class="sourceLineNo">421</span><a id="line.421">            waves[i] = new Coord[positionsZ[i].length];</a>
<span class="sourceLineNo">422</span><a id="line.422">            for (int j = 0; j &lt; waves[i].length; j++) {</a>
<span class="sourceLineNo">423</span><a id="line.423">                waves[i][j] = zDecode(positionsZ[i][j]);</a>
<span class="sourceLineNo">424</span><a id="line.424">            }</a>
<span class="sourceLineNo">425</span><a id="line.425">        }</a>
<span class="sourceLineNo">426</span><a id="line.426">        directionAngles = new double[3][3];</a>
<span class="sourceLineNo">427</span><a id="line.427">        directionAngles[0][0] = NumberTools.atan2(1,1);</a>
<span class="sourceLineNo">428</span><a id="line.428">        directionAngles[0][1] = NumberTools.atan2(0,1);</a>
<span class="sourceLineNo">429</span><a id="line.429">        directionAngles[0][2] = NumberTools.atan2(-1,1) + PI2;</a>
<span class="sourceLineNo">430</span><a id="line.430">        directionAngles[1][0] = NumberTools.atan2(1,0);</a>
<span class="sourceLineNo">431</span><a id="line.431">        directionAngles[1][1] = 0;</a>
<span class="sourceLineNo">432</span><a id="line.432">        directionAngles[1][2] = NumberTools.atan2(-1,0) + PI2;</a>
<span class="sourceLineNo">433</span><a id="line.433">        directionAngles[2][0] = NumberTools.atan2(1,-1);</a>
<span class="sourceLineNo">434</span><a id="line.434">        directionAngles[2][1] = NumberTools.atan2(0,-1);</a>
<span class="sourceLineNo">435</span><a id="line.435">        directionAngles[2][2] = NumberTools.atan2(-1,-1) + PI2;</a>
<span class="sourceLineNo">436</span><a id="line.436">    }</a>
<span class="sourceLineNo">437</span><a id="line.437"></a>
<span class="sourceLineNo">438</span><a id="line.438">    /**</a>
<span class="sourceLineNo">439</span><a id="line.439">     * Packs FOV for a point as a center, and returns it to be stored.</a>
<span class="sourceLineNo">440</span><a id="line.440">     * @param index an int that stores the x,y center of FOV as calculated by: x + y * width</a>
<span class="sourceLineNo">441</span><a id="line.441">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">442</span><a id="line.442">     */</a>
<span class="sourceLineNo">443</span><a id="line.443">    protected long storeCellFOV(int index) {</a>
<span class="sourceLineNo">444</span><a id="line.444">        long startTime = System.currentTimeMillis();</a>
<span class="sourceLineNo">445</span><a id="line.445">        cache[index] = calculatePackedSlopeShadowFOV(index % width, index / width);</a>
<span class="sourceLineNo">446</span><a id="line.446">        //cache[index] = calculatePackedExternalFOV(index % width, index / width);</a>
<span class="sourceLineNo">447</span><a id="line.447">        return System.currentTimeMillis() - startTime;</a>
<span class="sourceLineNo">448</span><a id="line.448">    }</a>
<span class="sourceLineNo">449</span><a id="line.449"></a>
<span class="sourceLineNo">450</span><a id="line.450">    /**</a>
<span class="sourceLineNo">451</span><a id="line.451">     * Packs FOV for a point as a center, and returns it to be stored.</a>
<span class="sourceLineNo">452</span><a id="line.452">     * @param index an int that stores the x,y center of FOV as calculated by: x + y * width</a>
<span class="sourceLineNo">453</span><a id="line.453">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">454</span><a id="line.454">     */</a>
<span class="sourceLineNo">455</span><a id="line.455">    protected long storeCellLOS(int index) {</a>
<span class="sourceLineNo">456</span><a id="line.456">        long startTime = System.currentTimeMillis();</a>
<span class="sourceLineNo">457</span><a id="line.457">        losCache[index] = calculatePackedLOS(index % width, index / width);</a>
<span class="sourceLineNo">458</span><a id="line.458">        return System.currentTimeMillis() - startTime;</a>
<span class="sourceLineNo">459</span><a id="line.459">    }</a>
<span class="sourceLineNo">460</span><a id="line.460"></a>
<span class="sourceLineNo">461</span><a id="line.461">    /**</a>
<span class="sourceLineNo">462</span><a id="line.462">     * Uses previously cached FOV and makes it symmetrical. Also handles distant lights</a>
<span class="sourceLineNo">463</span><a id="line.463">     * @param index an int that stores the x,y center of FOV as calculated by: x + y * width</a>
<span class="sourceLineNo">464</span><a id="line.464">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">465</span><a id="line.465">     */</a>
<span class="sourceLineNo">466</span><a id="line.466">    protected long storeCellSymmetry(int index) {</a>
<span class="sourceLineNo">467</span><a id="line.467">        long startTime = System.currentTimeMillis();</a>
<span class="sourceLineNo">468</span><a id="line.468">        tmpCache[index] = improveQuality(index % width, index / width);</a>
<span class="sourceLineNo">469</span><a id="line.469">        return System.currentTimeMillis() - startTime;</a>
<span class="sourceLineNo">470</span><a id="line.470">    }</a>
<span class="sourceLineNo">471</span><a id="line.471"></a>
<span class="sourceLineNo">472</span><a id="line.472">    /**</a>
<span class="sourceLineNo">473</span><a id="line.473">     * Packs FOV for the given viewer's X and Y as a center, and returns the packed data to be stored.</a>
<span class="sourceLineNo">474</span><a id="line.474">     * @param viewerX an int less than 256 and less than width</a>
<span class="sourceLineNo">475</span><a id="line.475">     * @param viewerY an int less than 256 and less than height</a>
<span class="sourceLineNo">476</span><a id="line.476">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">477</span><a id="line.477">     */</a>
<span class="sourceLineNo">478</span><a id="line.478">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">479</span><a id="line.479">        private short[][] calculatePackedExternalFOV(int viewerX, int viewerY)</a>
<span class="sourceLineNo">480</span><a id="line.480">    {</a>
<span class="sourceLineNo">481</span><a id="line.481">        if(viewerX &lt; 0 || viewerY &lt; 0 || viewerX &gt;= width || viewerY &gt;= height)</a>
<span class="sourceLineNo">482</span><a id="line.482">            return ALL_WALLS;</a>
<span class="sourceLineNo">483</span><a id="line.483">        if(resMap[viewerX][viewerY] &gt;= 1.0)</a>
<span class="sourceLineNo">484</span><a id="line.484">        {</a>
<span class="sourceLineNo">485</span><a id="line.485">            return ALL_WALLS;</a>
<span class="sourceLineNo">486</span><a id="line.486">        }</a>
<span class="sourceLineNo">487</span><a id="line.487">        long on = 0, current = 0;</a>
<span class="sourceLineNo">488</span><a id="line.488">        ShortVLA[] packing = new ShortVLA[maxRadius];</a>
<span class="sourceLineNo">489</span><a id="line.489">        int[] skip = new int[maxRadius];</a>
<span class="sourceLineNo">490</span><a id="line.490">        short x, y;</a>
<span class="sourceLineNo">491</span><a id="line.491">        short[][] packed = new short[maxRadius][];</a>
<span class="sourceLineNo">492</span><a id="line.492">        double[][] fovMap;</a>
<span class="sourceLineNo">493</span><a id="line.493">        for(int l = 0; l &lt; maxRadius; l++) {</a>
<span class="sourceLineNo">494</span><a id="line.494"></a>
<span class="sourceLineNo">495</span><a id="line.495">            fovMap = fov.calculateFOV(resMap, viewerX, viewerY, l + 1, radiusKind);</a>
<span class="sourceLineNo">496</span><a id="line.496">            packing[l] = new ShortVLA(64);</a>
<span class="sourceLineNo">497</span><a id="line.497">            for (int i = 0, ml = 0; i &lt; limit &amp;&amp; ml &lt; mapLimit; i++, skip[l]++) {</a>
<span class="sourceLineNo">498</span><a id="line.498"></a>
<span class="sourceLineNo">499</span><a id="line.499">                x = hilbertX[i];</a>
<span class="sourceLineNo">500</span><a id="line.500">                y = hilbertY[i];</a>
<span class="sourceLineNo">501</span><a id="line.501">                if (x &gt;= width || y &gt;= height) {</a>
<span class="sourceLineNo">502</span><a id="line.502">                    if ((on &amp; (1L &lt;&lt; l)) != 0L) {</a>
<span class="sourceLineNo">503</span><a id="line.503">                        on ^= 1L &lt;&lt; l;</a>
<span class="sourceLineNo">504</span><a id="line.504">                        packing[l].add((short) skip[l]);</a>
<span class="sourceLineNo">505</span><a id="line.505">                        skip[l] = 0;</a>
<span class="sourceLineNo">506</span><a id="line.506">                    }</a>
<span class="sourceLineNo">507</span><a id="line.507">                    continue;</a>
<span class="sourceLineNo">508</span><a id="line.508">                }</a>
<span class="sourceLineNo">509</span><a id="line.509">                ml++;</a>
<span class="sourceLineNo">510</span><a id="line.510">                // sets the bit at position l in current to 1 if the following is true, 0 if it is false:</a>
<span class="sourceLineNo">511</span><a id="line.511">                //     fovMap[x][y] &gt; levels[l]</a>
<span class="sourceLineNo">512</span><a id="line.512">                // looks more complicated than it is.</a>
<span class="sourceLineNo">513</span><a id="line.513">                current ^= ((fovMap[x][y] &gt; 0.0 ? -1 : 0) ^ current) &amp; (1 &lt;&lt; l);</a>
<span class="sourceLineNo">514</span><a id="line.514">                if (((current &gt;&gt; l) &amp; 1L) != ((on &gt;&gt; l) &amp; 1L)) {</a>
<span class="sourceLineNo">515</span><a id="line.515">                    packing[l].add((short) skip[l]);</a>
<span class="sourceLineNo">516</span><a id="line.516">                    skip[l] = 0;</a>
<span class="sourceLineNo">517</span><a id="line.517">                    on = current;</a>
<span class="sourceLineNo">518</span><a id="line.518"></a>
<span class="sourceLineNo">519</span><a id="line.519">                    // sets the bit at position l in on to the same as the bit at position l in current.</a>
<span class="sourceLineNo">520</span><a id="line.520">                    on ^= (-((current &gt;&gt; l) &amp; 1L) ^ on) &amp; (1L &lt;&lt; l);</a>
<span class="sourceLineNo">521</span><a id="line.521"></a>
<span class="sourceLineNo">522</span><a id="line.522">                }</a>
<span class="sourceLineNo">523</span><a id="line.523">            }</a>
<span class="sourceLineNo">524</span><a id="line.524"></a>
<span class="sourceLineNo">525</span><a id="line.525">            if (((on &gt;&gt; l) &amp; 1L) == 1L)</a>
<span class="sourceLineNo">526</span><a id="line.526">                packing[l].add((short) skip[l]);</a>
<span class="sourceLineNo">527</span><a id="line.527">            if(packing[l].size == 0)</a>
<span class="sourceLineNo">528</span><a id="line.528">                packed[l] = ALL_WALL;</a>
<span class="sourceLineNo">529</span><a id="line.529">            else</a>
<span class="sourceLineNo">530</span><a id="line.530">                packed[l] = packing[l].toArray();</a>
<span class="sourceLineNo">531</span><a id="line.531">        }</a>
<span class="sourceLineNo">532</span><a id="line.532">        return packed;</a>
<span class="sourceLineNo">533</span><a id="line.533">    }</a>
<span class="sourceLineNo">534</span><a id="line.534"></a>
<span class="sourceLineNo">535</span><a id="line.535">    /**</a>
<span class="sourceLineNo">536</span><a id="line.536">     * Packs FOV for the given viewer's X and Y as a center, and returns the packed data to be stored.</a>
<span class="sourceLineNo">537</span><a id="line.537">     * @param viewerX an int less than 256 and less than width</a>
<span class="sourceLineNo">538</span><a id="line.538">     * @param viewerY an int less than 256 and less than height</a>
<span class="sourceLineNo">539</span><a id="line.539">     * @return a packed FOV map for radius equal to maxLOSRadius</a>
<span class="sourceLineNo">540</span><a id="line.540">     */</a>
<span class="sourceLineNo">541</span><a id="line.541">    public short[] calculatePackedLOS(int viewerX, int viewerY)</a>
<span class="sourceLineNo">542</span><a id="line.542">    {</a>
<span class="sourceLineNo">543</span><a id="line.543">        if(viewerX &lt; 0 || viewerY &lt; 0 || viewerX &gt;= width || viewerY &gt;= height)</a>
<span class="sourceLineNo">544</span><a id="line.544">            return ALL_WALL;</a>
<span class="sourceLineNo">545</span><a id="line.545">        if(resMap[viewerX][viewerY] &gt;= 1.0)</a>
<span class="sourceLineNo">546</span><a id="line.546">        {</a>
<span class="sourceLineNo">547</span><a id="line.547">            return ALL_WALL;</a>
<span class="sourceLineNo">548</span><a id="line.548">        }</a>
<span class="sourceLineNo">549</span><a id="line.549">        return pack(fov.calculateFOV(resMap, viewerX, viewerY, maxLOSRadius, radiusKind));</a>
<span class="sourceLineNo">550</span><a id="line.550">    }</a>
<span class="sourceLineNo">551</span><a id="line.551"></a>
<span class="sourceLineNo">552</span><a id="line.552">    /**</a>
<span class="sourceLineNo">553</span><a id="line.553">     * Packs FOV for the given viewer's X and Y as a center, and returns the packed data to be stored.</a>
<span class="sourceLineNo">554</span><a id="line.554">     * @param viewerX an int less than 256 and less than width</a>
<span class="sourceLineNo">555</span><a id="line.555">     * @param viewerY an int less than 256 and less than height</a>
<span class="sourceLineNo">556</span><a id="line.556">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">557</span><a id="line.557">     */</a>
<span class="sourceLineNo">558</span><a id="line.558">    public short[][] calculatePackedSlopeShadowFOV(int viewerX, int viewerY) {</a>
<span class="sourceLineNo">559</span><a id="line.559">        if (viewerX &lt; 0 || viewerY &lt; 0 || viewerX &gt;= width || viewerY &gt;= height)</a>
<span class="sourceLineNo">560</span><a id="line.560">            return ALL_WALLS;</a>
<span class="sourceLineNo">561</span><a id="line.561">        if (resMap[viewerX][viewerY] &gt;= 1.0) {</a>
<span class="sourceLineNo">562</span><a id="line.562">            return ALL_WALLS;</a>
<span class="sourceLineNo">563</span><a id="line.563">        }</a>
<span class="sourceLineNo">564</span><a id="line.564">        return packMulti(slopeShadowFOV(viewerX, viewerY), maxRadius + 1);</a>
<span class="sourceLineNo">565</span><a id="line.565">    }</a>
<span class="sourceLineNo">566</span><a id="line.566"></a>
<span class="sourceLineNo">567</span><a id="line.567">    /**</a>
<span class="sourceLineNo">568</span><a id="line.568">     * Packs FOV for the given viewer's X and Y as a center, and returns the packed data to be stored.</a>
<span class="sourceLineNo">569</span><a id="line.569">     * @param viewerX an int less than 256 and less than width</a>
<span class="sourceLineNo">570</span><a id="line.570">     * @param viewerY an int less than 256 and less than height</a>
<span class="sourceLineNo">571</span><a id="line.571">     * @return a multi-packed series of progressively wider FOV radii</a>
<span class="sourceLineNo">572</span><a id="line.572">     */</a>
<span class="sourceLineNo">573</span><a id="line.573">    public short[][] calculatePackedWaveFOV(int viewerX, int viewerY) {</a>
<span class="sourceLineNo">574</span><a id="line.574">        if (viewerX &lt; 0 || viewerY &lt; 0 || viewerX &gt;= width || viewerY &gt;= height)</a>
<span class="sourceLineNo">575</span><a id="line.575">            return ALL_WALLS;</a>
<span class="sourceLineNo">576</span><a id="line.576">        if (resMap[viewerX][viewerY] &gt;= 1.0) {</a>
<span class="sourceLineNo">577</span><a id="line.577">            return ALL_WALLS;</a>
<span class="sourceLineNo">578</span><a id="line.578">        }</a>
<span class="sourceLineNo">579</span><a id="line.579">        return packMulti(waveFOV(viewerX, viewerY), maxRadius + 1);</a>
<span class="sourceLineNo">580</span><a id="line.580">    }</a>
<span class="sourceLineNo">581</span><a id="line.581">    public short[][] getCacheEntry(int x, int y)</a>
<span class="sourceLineNo">582</span><a id="line.582">    {</a>
<span class="sourceLineNo">583</span><a id="line.583">        return cache[x + y * width];</a>
<span class="sourceLineNo">584</span><a id="line.584">    }</a>
<span class="sourceLineNo">585</span><a id="line.585">    public short[] getCacheEntry(int x, int y, int radius)</a>
<span class="sourceLineNo">586</span><a id="line.586">    {</a>
<span class="sourceLineNo">587</span><a id="line.587">        return cache[x + y * width][maxRadius - radius];</a>
<span class="sourceLineNo">588</span><a id="line.588">    }</a>
<span class="sourceLineNo">589</span><a id="line.589"></a>
<span class="sourceLineNo">590</span><a id="line.590">    public short[] getLOSEntry(int x, int y)</a>
<span class="sourceLineNo">591</span><a id="line.591">    {</a>
<span class="sourceLineNo">592</span><a id="line.592">        return losCache[x + y * width];</a>
<span class="sourceLineNo">593</span><a id="line.593">    }</a>
<span class="sourceLineNo">594</span><a id="line.594"></a>
<span class="sourceLineNo">595</span><a id="line.595">    public boolean queryCache(int visionRange, int viewerX, int viewerY, int targetX, int targetY)</a>
<span class="sourceLineNo">596</span><a id="line.596">    {</a>
<span class="sourceLineNo">597</span><a id="line.597">        return queryPacked(cache[viewerX + viewerY  * width][maxRadius - visionRange], targetX, targetY);</a>
<span class="sourceLineNo">598</span><a id="line.598">    }</a>
<span class="sourceLineNo">599</span><a id="line.599">    public boolean isCellVisible(int visionRange, int viewerX, int viewerY, int targetX, int targetY)</a>
<span class="sourceLineNo">600</span><a id="line.600">    {</a>
<span class="sourceLineNo">601</span><a id="line.601">        return queryPacked(cache[viewerX + viewerY  * width][maxRadius - visionRange], targetX, targetY) ||</a>
<span class="sourceLineNo">602</span><a id="line.602">                queryPacked(cache[targetX + targetY  * width][maxRadius - visionRange], viewerX, viewerY);</a>
<span class="sourceLineNo">603</span><a id="line.603">    }</a>
<span class="sourceLineNo">604</span><a id="line.604">    public boolean queryLOS(int viewerX, int viewerY, int targetX, int targetY)</a>
<span class="sourceLineNo">605</span><a id="line.605">    {</a>
<span class="sourceLineNo">606</span><a id="line.606">        return queryPacked(losCache[viewerX + viewerY  * width], targetX, targetY);</a>
<span class="sourceLineNo">607</span><a id="line.607">    }</a>
<span class="sourceLineNo">608</span><a id="line.608"></a>
<span class="sourceLineNo">609</span><a id="line.609">    public static long arrayMemoryUsage(int length, long bytesPerItem)</a>
<span class="sourceLineNo">610</span><a id="line.610">    {</a>
<span class="sourceLineNo">611</span><a id="line.611">        return (((bytesPerItem * length + 12 - 1) &gt;&gt; 3) + 1) &lt;&lt; 3;</a>
<span class="sourceLineNo">612</span><a id="line.612">    }</a>
<span class="sourceLineNo">613</span><a id="line.613">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">614</span><a id="line.614">        public static long arrayMemoryUsage2D(int xSize, int ySize, long bytesPerItem)</a>
<span class="sourceLineNo">615</span><a id="line.615">    {</a>
<span class="sourceLineNo">616</span><a id="line.616">        return arrayMemoryUsage(xSize, (((bytesPerItem * ySize + 12 - 1) &gt;&gt; 3) + 1) &lt;&lt; 3);</a>
<span class="sourceLineNo">617</span><a id="line.617">    }</a>
<span class="sourceLineNo">618</span><a id="line.618">    public static int arrayMemoryUsageJagged(short[][] arr)</a>
<span class="sourceLineNo">619</span><a id="line.619">    {</a>
<span class="sourceLineNo">620</span><a id="line.620">        int ctr = 0;</a>
<span class="sourceLineNo">621</span><a id="line.621">        for (int i = 0; i &lt; arr.length; i++) {</a>
<span class="sourceLineNo">622</span><a id="line.622">            ctr += arrayMemoryUsage(arr[i].length, 2);</a>
<span class="sourceLineNo">623</span><a id="line.623">        }</a>
<span class="sourceLineNo">624</span><a id="line.624">        return (((ctr + 12 - 1) &gt;&gt; 3) + 1) &lt;&lt; 3;</a>
<span class="sourceLineNo">625</span><a id="line.625">    }</a>
<span class="sourceLineNo">626</span><a id="line.626">    public long approximateMemoryUsage()</a>
<span class="sourceLineNo">627</span><a id="line.627">    {</a>
<span class="sourceLineNo">628</span><a id="line.628">        long ctr = 0;</a>
<span class="sourceLineNo">629</span><a id="line.629">        for (int i = 0; i &lt; cache.length; i++) {</a>
<span class="sourceLineNo">630</span><a id="line.630">            ctr += arrayMemoryUsageJagged(cache[i]);</a>
<span class="sourceLineNo">631</span><a id="line.631">        }</a>
<span class="sourceLineNo">632</span><a id="line.632">        ctr = (((ctr + 12L - 1L) &gt;&gt; 3) + 1L) &lt;&lt; 3;</a>
<span class="sourceLineNo">633</span><a id="line.633">        ctr += (((arrayMemoryUsageJagged(losCache) + 12L - 1L) &gt;&gt; 3) + 1L) &lt;&lt; 3;</a>
<span class="sourceLineNo">634</span><a id="line.634">        return ctr;</a>
<span class="sourceLineNo">635</span><a id="line.635">    }</a>
<span class="sourceLineNo">636</span><a id="line.636"></a>
<span class="sourceLineNo">637</span><a id="line.637">    /*</a>
<span class="sourceLineNo">638</span><a id="line.638">    //needs rewrite, must store the angle a ray traveled at to get around an obstacle, and propagate it to the end of</a>
<span class="sourceLineNo">639</span><a id="line.639">    //the ray. It should check if the angle theta for a given point is too different from the angle in angleMap.</a>
<span class="sourceLineNo">640</span><a id="line.640">    private byte[][] waveFOVWIP(int viewerX, int viewerY) {</a>
<span class="sourceLineNo">641</span><a id="line.641">        byte[][] gradientMap = new byte[width][height];</a>
<span class="sourceLineNo">642</span><a id="line.642">        double[][] angleMap = new double[2 * maxRadius + 1][2 * maxRadius + 1];</a>
<span class="sourceLineNo">643</span><a id="line.643">        for (int i = 0; i &lt; angleMap.length; i++) {</a>
<span class="sourceLineNo">644</span><a id="line.644">            Arrays.fill(angleMap[i], -20);</a>
<span class="sourceLineNo">645</span><a id="line.645">        }</a>
<span class="sourceLineNo">646</span><a id="line.646">        gradientMap[viewerX][viewerY] = (byte)(2 * maxRadius);</a>
<span class="sourceLineNo">647</span><a id="line.647">        Direction[] dirs = (radiusKind == Radius.DIAMOND || radiusKind == Radius.OCTAHEDRON)</a>
<span class="sourceLineNo">648</span><a id="line.648">                ? Direction.CARDINALS : Direction.OUTWARDS;</a>
<span class="sourceLineNo">649</span><a id="line.649">        int cx, cy, ccwAdjX, ccwAdjY, cwAdjX, cwAdjY, ccwGridX, ccwGridY, cwGridX, cwGridY;</a>
<span class="sourceLineNo">650</span><a id="line.650">        Coord pt;</a>
<span class="sourceLineNo">651</span><a id="line.651">        double theta, angleCW, angleCCW;</a>
<span class="sourceLineNo">652</span><a id="line.652">        byte dist;</a>
<span class="sourceLineNo">653</span><a id="line.653">        boolean blockedCCW, blockedCW, isStraightCCW;</a>
<span class="sourceLineNo">654</span><a id="line.654">        for(int w = 0; w &lt; waves.length; w++)</a>
<span class="sourceLineNo">655</span><a id="line.655">        {</a>
<span class="sourceLineNo">656</span><a id="line.656">            for(int c = 0; c &lt; waves[w].length; c++)</a>
<span class="sourceLineNo">657</span><a id="line.657">            {</a>
<span class="sourceLineNo">658</span><a id="line.658">                pt = waves[w][c];</a>
<span class="sourceLineNo">659</span><a id="line.659">                cx = viewerX - maxRadius + pt.x;</a>
<span class="sourceLineNo">660</span><a id="line.660">                cy = viewerY - maxRadius + pt.y;</a>
<span class="sourceLineNo">661</span><a id="line.661">                if(cx &lt; width &amp;&amp; cx &gt;= 0 &amp;&amp; cy &lt; height &amp;&amp; cy &gt;= 0)</a>
<span class="sourceLineNo">662</span><a id="line.662">                {</a>
<span class="sourceLineNo">663</span><a id="line.663">                    theta = atan2Cache[pt.x][pt.y];</a>
<span class="sourceLineNo">664</span><a id="line.664">                    dist = (byte)(distanceCache[pt.x][pt.y ]);</a>
<span class="sourceLineNo">665</span><a id="line.665"></a>
<span class="sourceLineNo">666</span><a id="line.666">                    if(w &lt;= 0)</a>
<span class="sourceLineNo">667</span><a id="line.667">                    {</a>
<span class="sourceLineNo">668</span><a id="line.668">                        gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">669</span><a id="line.669">                    }</a>
<span class="sourceLineNo">670</span><a id="line.670">                    else {</a>
<span class="sourceLineNo">671</span><a id="line.671">                        switch ((int) Math.floor(theta / QUARTER_PI)) {</a>
<span class="sourceLineNo">672</span><a id="line.672"></a>
<span class="sourceLineNo">673</span><a id="line.673">                            //positive x, postive y (lower on screen), closer to x-axis</a>
<span class="sourceLineNo">674</span><a id="line.674">                            case 0:</a>
<span class="sourceLineNo">675</span><a id="line.675">                                cwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">676</span><a id="line.676">                                cwAdjY = pt.y;</a>
<span class="sourceLineNo">677</span><a id="line.677">                                angleCW = directionAngles[0][1];</a>
<span class="sourceLineNo">678</span><a id="line.678">                                isStraightCCW = false;</a>
<span class="sourceLineNo">679</span><a id="line.679">                                ccwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">680</span><a id="line.680">                                ccwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">681</span><a id="line.681">                                angleCCW = directionAngles[0][0];</a>
<span class="sourceLineNo">682</span><a id="line.682">                                break;</a>
<span class="sourceLineNo">683</span><a id="line.683">                            //positive x, postive y (lower on screen), closer to y-axis</a>
<span class="sourceLineNo">684</span><a id="line.684">                            case 1:</a>
<span class="sourceLineNo">685</span><a id="line.685">                                cwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">686</span><a id="line.686">                                cwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">687</span><a id="line.687">                                angleCW = directionAngles[0][0];</a>
<span class="sourceLineNo">688</span><a id="line.688">                                ccwAdjX = pt.x;</a>
<span class="sourceLineNo">689</span><a id="line.689">                                ccwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">690</span><a id="line.690">                                angleCCW = directionAngles[1][0];</a>
<span class="sourceLineNo">691</span><a id="line.691">                                isStraightCCW = true;</a>
<span class="sourceLineNo">692</span><a id="line.692">                                break;</a>
<span class="sourceLineNo">693</span><a id="line.693">                            //negative x, postive y (lower on screen), closer to y-axis</a>
<span class="sourceLineNo">694</span><a id="line.694">                            case 2:</a>
<span class="sourceLineNo">695</span><a id="line.695">                                cwAdjX = pt.x;</a>
<span class="sourceLineNo">696</span><a id="line.696">                                cwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">697</span><a id="line.697">                                angleCW = directionAngles[1][0];</a>
<span class="sourceLineNo">698</span><a id="line.698">                                isStraightCCW = false;</a>
<span class="sourceLineNo">699</span><a id="line.699">                                ccwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">700</span><a id="line.700">                                ccwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">701</span><a id="line.701">                                angleCCW = directionAngles[2][0];</a>
<span class="sourceLineNo">702</span><a id="line.702">                                break;</a>
<span class="sourceLineNo">703</span><a id="line.703">                            //negative x, postive y (lower on screen), closer to x-axis</a>
<span class="sourceLineNo">704</span><a id="line.704">                            case 3:</a>
<span class="sourceLineNo">705</span><a id="line.705">                                cwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">706</span><a id="line.706">                                cwAdjY = pt.y - 1;</a>
<span class="sourceLineNo">707</span><a id="line.707">                                angleCW = directionAngles[2][0];</a>
<span class="sourceLineNo">708</span><a id="line.708">                                ccwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">709</span><a id="line.709">                                ccwAdjY = pt.y;</a>
<span class="sourceLineNo">710</span><a id="line.710">                                angleCCW = directionAngles[2][1];</a>
<span class="sourceLineNo">711</span><a id="line.711">                                isStraightCCW = true;</a>
<span class="sourceLineNo">712</span><a id="line.712">                                break;</a>
<span class="sourceLineNo">713</span><a id="line.713"></a>
<span class="sourceLineNo">714</span><a id="line.714">                            //negative x, negative y (higher on screen), closer to x-axis</a>
<span class="sourceLineNo">715</span><a id="line.715">                            case 4:</a>
<span class="sourceLineNo">716</span><a id="line.716">                                cwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">717</span><a id="line.717">                                cwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">718</span><a id="line.718">                                angleCW = directionAngles[2][2];</a>
<span class="sourceLineNo">719</span><a id="line.719">                                ccwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">720</span><a id="line.720">                                ccwAdjY = pt.y;</a>
<span class="sourceLineNo">721</span><a id="line.721">                                angleCCW = directionAngles[2][1];</a>
<span class="sourceLineNo">722</span><a id="line.722">                                isStraightCCW = false;</a>
<span class="sourceLineNo">723</span><a id="line.723">                                break;</a>
<span class="sourceLineNo">724</span><a id="line.724">                            //negative x, negative y (higher on screen), closer to y-axis</a>
<span class="sourceLineNo">725</span><a id="line.725">                            case 5:</a>
<span class="sourceLineNo">726</span><a id="line.726">                                cwAdjX = pt.x + 1;</a>
<span class="sourceLineNo">727</span><a id="line.727">                                cwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">728</span><a id="line.728">                                angleCW = directionAngles[2][2];</a>
<span class="sourceLineNo">729</span><a id="line.729">                                ccwAdjX = pt.x;</a>
<span class="sourceLineNo">730</span><a id="line.730">                                ccwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">731</span><a id="line.731">                                angleCCW = directionAngles[1][2];</a>
<span class="sourceLineNo">732</span><a id="line.732">                                isStraightCCW = true;</a>
<span class="sourceLineNo">733</span><a id="line.733">                                break;</a>
<span class="sourceLineNo">734</span><a id="line.734">                            //positive x, negative y (higher on screen), closer to y-axis</a>
<span class="sourceLineNo">735</span><a id="line.735">                            case 6:</a>
<span class="sourceLineNo">736</span><a id="line.736">                                cwAdjX = pt.x;</a>
<span class="sourceLineNo">737</span><a id="line.737">                                cwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">738</span><a id="line.738">                                angleCW = directionAngles[1][2];</a>
<span class="sourceLineNo">739</span><a id="line.739">                                isStraightCCW = false;</a>
<span class="sourceLineNo">740</span><a id="line.740">                                ccwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">741</span><a id="line.741">                                ccwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">742</span><a id="line.742">                                angleCCW = directionAngles[0][2];</a>
<span class="sourceLineNo">743</span><a id="line.743">                                break;</a>
<span class="sourceLineNo">744</span><a id="line.744">                            //positive x, negative y (higher on screen), closer to x-axis</a>
<span class="sourceLineNo">745</span><a id="line.745">                            default:</a>
<span class="sourceLineNo">746</span><a id="line.746">                                cwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">747</span><a id="line.747">                                cwAdjY = pt.y + 1;</a>
<span class="sourceLineNo">748</span><a id="line.748">                                angleCW = directionAngles[0][2];</a>
<span class="sourceLineNo">749</span><a id="line.749">                                ccwAdjX = pt.x - 1;</a>
<span class="sourceLineNo">750</span><a id="line.750">                                ccwAdjY = pt.y;</a>
<span class="sourceLineNo">751</span><a id="line.751">                                angleCCW = directionAngles[0][1];</a>
<span class="sourceLineNo">752</span><a id="line.752">                                isStraightCCW = true;</a>
<span class="sourceLineNo">753</span><a id="line.753">                                break;</a>
<span class="sourceLineNo">754</span><a id="line.754">                        }</a>
<span class="sourceLineNo">755</span><a id="line.755">                        /*</a>
<span class="sourceLineNo">756</span><a id="line.756">                        angleCCW = (((Math.abs(atan2Cache[ccwAdjX][ccwAdjY] - angleCCW) &gt; Math.PI)</a>
<span class="sourceLineNo">757</span><a id="line.757">                                ? atan2Cache[ccwAdjX][ccwAdjY] + angleCCW + PI2</a>
<span class="sourceLineNo">758</span><a id="line.758">                                : atan2Cache[ccwAdjX][ccwAdjY] + angleCCW)</a>
<span class="sourceLineNo">759</span><a id="line.759">                                * 0.5) % PI2;</a>
<span class="sourceLineNo">760</span><a id="line.760">                                //(angleCCW + atan2Cache[ccwAdjX][ccwAdjY]) * 0.5;</a>
<span class="sourceLineNo">761</span><a id="line.761">                        angleCW = (((Math.abs(atan2Cache[cwAdjX][cwAdjY] - angleCW) &gt; Math.PI)</a>
<span class="sourceLineNo">762</span><a id="line.762">                                ? atan2Cache[cwAdjX][cwAdjY] + angleCW + PI2</a>
<span class="sourceLineNo">763</span><a id="line.763">                                : atan2Cache[cwAdjX][cwAdjY] + angleCW)</a>
<span class="sourceLineNo">764</span><a id="line.764">                                * 0.5) % PI2;</a>
<span class="sourceLineNo">765</span><a id="line.765">                                //(angleCW + atan2Cache[cwAdjX][cwAdjY]) * 0.5;</a>
<span class="sourceLineNo">766</span><a id="line.766"></a>
<span class="sourceLineNo">767</span><a id="line.767">                         * /</a>
<span class="sourceLineNo">768</span><a id="line.768">                        angleCCW = atan2Cache[ccwAdjX][ccwAdjY];</a>
<span class="sourceLineNo">769</span><a id="line.769">                        //(angleCCW + atan2Cache[ccwAdjX][ccwAdjY]) * 0.5;</a>
<span class="sourceLineNo">770</span><a id="line.770">                        angleCW = atan2Cache[cwAdjX][cwAdjY];</a>
<span class="sourceLineNo">771</span><a id="line.771">                        //(angleCW + atan2Cache[cwAdjX][cwAdjY]) * 0.5;</a>
<span class="sourceLineNo">772</span><a id="line.772"></a>
<span class="sourceLineNo">773</span><a id="line.773"></a>
<span class="sourceLineNo">774</span><a id="line.774">                        cwGridX = cwAdjX + viewerX - maxRadius;</a>
<span class="sourceLineNo">775</span><a id="line.775">                        ccwGridX = ccwAdjX + viewerX - maxRadius;</a>
<span class="sourceLineNo">776</span><a id="line.776">                        cwGridY = cwAdjY + viewerY - maxRadius;</a>
<span class="sourceLineNo">777</span><a id="line.777">                        ccwGridY = ccwAdjY + viewerY - maxRadius;</a>
<span class="sourceLineNo">778</span><a id="line.778"></a>
<span class="sourceLineNo">779</span><a id="line.779">                        blockedCW = cwGridX &gt;= width || cwGridY &gt;= height || cwGridX &lt; 0 || cwGridY &lt; 0 ||</a>
<span class="sourceLineNo">780</span><a id="line.780">                                resMap[cwGridX][cwGridY] &gt; 0.5 ||</a>
<span class="sourceLineNo">781</span><a id="line.781">                                angleMap[cwAdjX][cwAdjY] &gt;= PI2;</a>
<span class="sourceLineNo">782</span><a id="line.782">                        blockedCCW = ccwGridX &gt;= width || ccwGridY &gt;= height || ccwGridX &lt; 0 || ccwGridY &lt; 0 ||</a>
<span class="sourceLineNo">783</span><a id="line.783">                                resMap[ccwGridX][ccwGridY] &gt; 0.5 ||</a>
<span class="sourceLineNo">784</span><a id="line.784">                                angleMap[ccwAdjX][ccwAdjY] &gt;= PI2;</a>
<span class="sourceLineNo">785</span><a id="line.785"></a>
<span class="sourceLineNo">786</span><a id="line.786">                        if (blockedCW &amp;&amp; blockedCCW) {</a>
<span class="sourceLineNo">787</span><a id="line.787">                            angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">788</span><a id="line.788">                            continue;</a>
<span class="sourceLineNo">789</span><a id="line.789">                        }</a>
<span class="sourceLineNo">790</span><a id="line.790">                        if (theta % (HALF_PI - 0.00125) &lt; 0.005)</a>
<span class="sourceLineNo">791</span><a id="line.791">                            if (isStraightCCW) {</a>
<span class="sourceLineNo">792</span><a id="line.792">                                if (blockedCCW) {</a>
<span class="sourceLineNo">793</span><a id="line.793">                                    angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">794</span><a id="line.794">                                    gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">795</span><a id="line.795">                                    continue;</a>
<span class="sourceLineNo">796</span><a id="line.796">                                }</a>
<span class="sourceLineNo">797</span><a id="line.797">                                else</a>
<span class="sourceLineNo">798</span><a id="line.798">                                    angleMap[pt.x][pt.y] = theta;</a>
<span class="sourceLineNo">799</span><a id="line.799">                            } else {</a>
<span class="sourceLineNo">800</span><a id="line.800">                                if (blockedCW) {</a>
<span class="sourceLineNo">801</span><a id="line.801">                                    angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">802</span><a id="line.802">                                    gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">803</span><a id="line.803">                                    continue;</a>
<span class="sourceLineNo">804</span><a id="line.804">                                }</a>
<span class="sourceLineNo">805</span><a id="line.805">                                else</a>
<span class="sourceLineNo">806</span><a id="line.806">                                    angleMap[pt.x][pt.y] = theta;</a>
<span class="sourceLineNo">807</span><a id="line.807">                            }</a>
<span class="sourceLineNo">808</span><a id="line.808">                        else if(theta % (QUARTER_PI  - 0.0025) &lt; 0.005)</a>
<span class="sourceLineNo">809</span><a id="line.809">                            if (isStraightCCW) {</a>
<span class="sourceLineNo">810</span><a id="line.810">                                if (blockedCW) {</a>
<span class="sourceLineNo">811</span><a id="line.811">                                    angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">812</span><a id="line.812">                                    gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">813</span><a id="line.813">                                    continue;</a>
<span class="sourceLineNo">814</span><a id="line.814">                                }</a>
<span class="sourceLineNo">815</span><a id="line.815">                                else</a>
<span class="sourceLineNo">816</span><a id="line.816">                                    angleMap[pt.x][pt.y] = theta;</a>
<span class="sourceLineNo">817</span><a id="line.817">                            } else {</a>
<span class="sourceLineNo">818</span><a id="line.818">                                if (blockedCCW) {</a>
<span class="sourceLineNo">819</span><a id="line.819">                                    angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">820</span><a id="line.820">                                    gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">821</span><a id="line.821">                                    continue;</a>
<span class="sourceLineNo">822</span><a id="line.822">                                }</a>
<span class="sourceLineNo">823</span><a id="line.823">                                else</a>
<span class="sourceLineNo">824</span><a id="line.824">                                    angleMap[pt.x][pt.y] = theta;</a>
<span class="sourceLineNo">825</span><a id="line.825">                            }</a>
<span class="sourceLineNo">826</span><a id="line.826">                        else {</a>
<span class="sourceLineNo">827</span><a id="line.827">                            if (blockedCW) {</a>
<span class="sourceLineNo">828</span><a id="line.828">                                angleMap[pt.x][pt.y] = angleMap[ccwAdjX][ccwAdjY];</a>
<span class="sourceLineNo">829</span><a id="line.829">//                                angleMap[pt.x][pt.y] = Math.max(angleMap[ccwAdjX][ccwAdjY],</a>
<span class="sourceLineNo">830</span><a id="line.830">//                                (theta - (angleCCW - theta + PI2) % PI2 * 0.5 + PI2) % PI2);</a>
<span class="sourceLineNo">831</span><a id="line.831">//                                        (theta - angleCCW &gt; Math.PI)</a>
<span class="sourceLineNo">832</span><a id="line.832">//                                                ? (theta - (angleCCW - theta + PI2) * 0.5) % PI2</a>
<span class="sourceLineNo">833</span><a id="line.833">//                                                : theta - (angleCCW - theta + PI2) % PI2 * 0.5;</a>
<span class="sourceLineNo">834</span><a id="line.834">                                //angleMap[pt.x][pt.y] = angleCCW;</a>
<span class="sourceLineNo">835</span><a id="line.835"></a>
<span class="sourceLineNo">836</span><a id="line.836">                                // (((Math.abs(theta - angleCCW) &gt; Math.PI)</a>
<span class="sourceLineNo">837</span><a id="line.837">                                //        ? theta + angleCCW + PI2</a>
<span class="sourceLineNo">838</span><a id="line.838">                                //        : theta + angleCCW)</a>
<span class="sourceLineNo">839</span><a id="line.839">                                //        * 0.5) % PI2;</a>
<span class="sourceLineNo">840</span><a id="line.840">                                //angleMap[cwAdjX - viewerX + maxRadius][cwAdjY - viewerY + maxRadius];</a>
<span class="sourceLineNo">841</span><a id="line.841">                                //Math.abs(angleMap[cwAdjX - viewerX + maxRadius][cwAdjY - viewerY + maxRadius] -</a>
<span class="sourceLineNo">842</span><a id="line.842"></a>
<span class="sourceLineNo">843</span><a id="line.843">                                //angleMap[pt.x][pt.y] = Math.abs(theta - angleCCW) +</a>
<span class="sourceLineNo">844</span><a id="line.844">                                //        angleMap[cwAdjX - viewerX + maxRadius][cwAdjY - viewerY + maxRadius];</a>
<span class="sourceLineNo">845</span><a id="line.845"></a>
<span class="sourceLineNo">846</span><a id="line.846">                            } else if (blockedCCW) {</a>
<span class="sourceLineNo">847</span><a id="line.847">                                angleMap[pt.x][pt.y] = angleMap[cwAdjX][cwAdjY];</a>
<span class="sourceLineNo">848</span><a id="line.848">//                                        angleMap[pt.x][pt.y] = Math.max(angleMap[cwAdjX][cwAdjY],</a>
<span class="sourceLineNo">849</span><a id="line.849">//                                        (theta + (theta - angleCW + PI2) % PI2 * 0.5 + PI2) % PI2);</a>
<span class="sourceLineNo">850</span><a id="line.850">//                                        (angleCW - theta &gt; Math.PI)</a>
<span class="sourceLineNo">851</span><a id="line.851">//                                                ? theta + (theta - angleCW + PI2) % PI2 * 0.5</a>
<span class="sourceLineNo">852</span><a id="line.852">//                                                : (theta + (theta - angleCW + PI2) * 0.5) % PI2;</a>
<span class="sourceLineNo">853</span><a id="line.853">                                        //angleCW;</a>
<span class="sourceLineNo">854</span><a id="line.854"></a>
<span class="sourceLineNo">855</span><a id="line.855">                                //angleMap[ccwAdjX - viewerX + maxRadius][ccwAdjY - viewerY + maxRadius];</a>
<span class="sourceLineNo">856</span><a id="line.856">                                //angleMap[ccwAdjX - viewerX + maxRadius][ccwAdjY - viewerY + maxRadius]</a>
<span class="sourceLineNo">857</span><a id="line.857">                            }</a>
<span class="sourceLineNo">858</span><a id="line.858">                            else</a>
<span class="sourceLineNo">859</span><a id="line.859">                            {</a>
<span class="sourceLineNo">860</span><a id="line.860">                                double cwTemp = angleMap[cwAdjX][cwAdjY], ccwTemp = angleMap[ccwAdjX][ccwAdjY];</a>
<span class="sourceLineNo">861</span><a id="line.861">                                if(cwTemp &lt; 0)</a>
<span class="sourceLineNo">862</span><a id="line.862">                                    cwTemp = (atan2Cache[cwAdjX][cwAdjY]);</a>
<span class="sourceLineNo">863</span><a id="line.863">                                if(ccwTemp &lt; 0)</a>
<span class="sourceLineNo">864</span><a id="line.864">                                    ccwTemp = (atan2Cache[ccwAdjX][ccwAdjY]);</a>
<span class="sourceLineNo">865</span><a id="line.865">                                if(cwTemp != atan2Cache[cwAdjX][cwAdjY] &amp;&amp;</a>
<span class="sourceLineNo">866</span><a id="line.866">                                        ccwTemp != atan2Cache[ccwAdjX][ccwAdjY])</a>
<span class="sourceLineNo">867</span><a id="line.867">                                    angleMap[pt.x][pt.y] = 0.5 * (cwTemp + ccwTemp);</a>
<span class="sourceLineNo">868</span><a id="line.868">                                else if(ccwTemp != atan2Cache[ccwAdjX][ccwAdjY])</a>
<span class="sourceLineNo">869</span><a id="line.869">                                    angleMap[pt.x][pt.y] = ccwTemp;</a>
<span class="sourceLineNo">870</span><a id="line.870">                                else if(cwTemp != atan2Cache[cwAdjX][cwAdjY])</a>
<span class="sourceLineNo">871</span><a id="line.871">                                    angleMap[pt.x][pt.y] = cwTemp;</a>
<span class="sourceLineNo">872</span><a id="line.872">                                else</a>
<span class="sourceLineNo">873</span><a id="line.873">                                    angleMap[pt.x][pt.y] = theta;</a>
<span class="sourceLineNo">874</span><a id="line.874">                            }</a>
<span class="sourceLineNo">875</span><a id="line.875">                            /*</a>
<span class="sourceLineNo">876</span><a id="line.876"></a>
<span class="sourceLineNo">877</span><a id="line.877">                            else if (!blockedCW)</a>
<span class="sourceLineNo">878</span><a id="line.878">                                angleMap[pt.x][pt.y] = (angleMap[cwAdjX][cwAdjY] != atan2Cache[cwAdjX][cwAdjY])</a>
<span class="sourceLineNo">879</span><a id="line.879">                                        ? angleMap[cwAdjX][cwAdjY]</a>
<span class="sourceLineNo">880</span><a id="line.880">                                        : theta;</a>
<span class="sourceLineNo">881</span><a id="line.881">                            else</a>
<span class="sourceLineNo">882</span><a id="line.882">                                angleMap[pt.x][pt.y] = (angleMap[ccwAdjX][ccwAdjY] != atan2Cache[ccwAdjX][ccwAdjY])</a>
<span class="sourceLineNo">883</span><a id="line.883">                                        ? angleMap[ccwAdjX][ccwAdjY]</a>
<span class="sourceLineNo">884</span><a id="line.884">                                        : theta;</a>
<span class="sourceLineNo">885</span><a id="line.885">                             * /</a>
<span class="sourceLineNo">886</span><a id="line.886">                        }</a>
<span class="sourceLineNo">887</span><a id="line.887">                        if(Math.abs(angleMap[pt.x][pt.y] - theta) &lt;= 0.001 || resMap[pt.x][pt.y] &gt; 0.5)</a>
<span class="sourceLineNo">888</span><a id="line.888">                            gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">889</span><a id="line.889">                        else</a>
<span class="sourceLineNo">890</span><a id="line.890">                            angleMap[pt.x][pt.y] = PI2 * 2;</a>
<span class="sourceLineNo">891</span><a id="line.891">                    }</a>
<span class="sourceLineNo">892</span><a id="line.892">                }</a>
<span class="sourceLineNo">893</span><a id="line.893">            }</a>
<span class="sourceLineNo">894</span><a id="line.894">        }</a>
<span class="sourceLineNo">895</span><a id="line.895"></a>
<span class="sourceLineNo">896</span><a id="line.896">        return gradientMap;</a>
<span class="sourceLineNo">897</span><a id="line.897">    }</a>
<span class="sourceLineNo">898</span><a id="line.898">    */</a>
<span class="sourceLineNo">899</span><a id="line.899">    public byte[][] waveFOV(int viewerX, int viewerY) {</a>
<span class="sourceLineNo">900</span><a id="line.900">        byte[][] gradientMap = new byte[width][height];</a>
<span class="sourceLineNo">901</span><a id="line.901">        double[][] angleMap = new double[2 * maxRadius + 1][2 * maxRadius + 1];</a>
<span class="sourceLineNo">902</span><a id="line.902">        gradientMap[viewerX][viewerY] = (byte)(1 + maxRadius);</a>
<span class="sourceLineNo">903</span><a id="line.903">        int cx, cy, nearCWx, nearCWy, nearCCWx, nearCCWy;</a>
<span class="sourceLineNo">904</span><a id="line.904">        Coord pt;</a>
<span class="sourceLineNo">905</span><a id="line.905">        double theta, angleCW, angleCCW, straight;</a>
<span class="sourceLineNo">906</span><a id="line.906">        byte dist;</a>
<span class="sourceLineNo">907</span><a id="line.907">        boolean blockedCCW, blockedCW;</a>
<span class="sourceLineNo">908</span><a id="line.908">        for(int w = 0; w &lt; waves.length; w++)</a>
<span class="sourceLineNo">909</span><a id="line.909">        {</a>
<span class="sourceLineNo">910</span><a id="line.910">            for(int c = 0; c &lt; waves[w].length; c++)</a>
<span class="sourceLineNo">911</span><a id="line.911">            {</a>
<span class="sourceLineNo">912</span><a id="line.912">                pt = waves[w][c];</a>
<span class="sourceLineNo">913</span><a id="line.913">                cx = viewerX - maxRadius + pt.x;</a>
<span class="sourceLineNo">914</span><a id="line.914">                cy = viewerY - maxRadius + pt.y;</a>
<span class="sourceLineNo">915</span><a id="line.915">                if(cx &lt; width &amp;&amp; cx &gt;= 0 &amp;&amp; cy &lt; height &amp;&amp; cy &gt;= 0)</a>
<span class="sourceLineNo">916</span><a id="line.916">                {</a>
<span class="sourceLineNo">917</span><a id="line.917">                    theta = atan2Cache[pt.x][pt.y];</a>
<span class="sourceLineNo">918</span><a id="line.918">                    dist = (byte) distanceCache[pt.x][pt.y ];</a>
<span class="sourceLineNo">919</span><a id="line.919"></a>
<span class="sourceLineNo">920</span><a id="line.920">                    if(w &lt;= 0)</a>
<span class="sourceLineNo">921</span><a id="line.921">                    {</a>
<span class="sourceLineNo">922</span><a id="line.922">                        gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">923</span><a id="line.923">                    }</a>
<span class="sourceLineNo">924</span><a id="line.924">                    else {</a>
<span class="sourceLineNo">925</span><a id="line.925">                        switch ((int) Math.floor(theta / QUARTER_PI)) {</a>
<span class="sourceLineNo">926</span><a id="line.926"></a>
<span class="sourceLineNo">927</span><a id="line.927">                            //positive x, postive y, closer to x-axis</a>
<span class="sourceLineNo">928</span><a id="line.928">                            case 0:</a>
<span class="sourceLineNo">929</span><a id="line.929">                                nearCCWx = pt.x - 1;</a>
<span class="sourceLineNo">930</span><a id="line.930">                                nearCCWy = pt.y;</a>
<span class="sourceLineNo">931</span><a id="line.931">                                angleCCW = directionAngles[0][1]; //atan2Cache[nearCCWx][nearCCWy];</a>
<span class="sourceLineNo">932</span><a id="line.932">                                straight = angleCCW;</a>
<span class="sourceLineNo">933</span><a id="line.933">                                nearCWx = pt.x - 1;</a>
<span class="sourceLineNo">934</span><a id="line.934">                                nearCWy = pt.y - 1;</a>
<span class="sourceLineNo">935</span><a id="line.935">                                angleCW = directionAngles[0][0]; //atan2Cache[nearCWx][nearCWy];</a>
<span class="sourceLineNo">936</span><a id="line.936">                                break;</a>
<span class="sourceLineNo">937</span><a id="line.937">                            //positive x, postive y, closer to y-axis</a>
<span class="sourceLineNo">938</span><a id="line.938">                            case 1:</a>
<span class="sourceLineNo">939</span><a id="line.939">                                nearCWx = pt.x;</a>
<span class="sourceLineNo">940</span><a id="line.940">                                nearCWy = pt.y - 1;</a>
<span class="sourceLineNo">941</span><a id="line.941">                                angleCW = directionAngles[1][0];</a>
<span class="sourceLineNo">942</span><a id="line.942">                                straight = angleCW;</a>
<span class="sourceLineNo">943</span><a id="line.943">                                nearCCWx = pt.x - 1;</a>
<span class="sourceLineNo">944</span><a id="line.944">                                nearCCWy = pt.y - 1;</a>
<span class="sourceLineNo">945</span><a id="line.945">                                angleCCW = directionAngles[0][0];</a>
<span class="sourceLineNo">946</span><a id="line.946">                                break;</a>
<span class="sourceLineNo">947</span><a id="line.947">                            //negative x, postive y, closer to y-axis</a>
<span class="sourceLineNo">948</span><a id="line.948">                            case 2:</a>
<span class="sourceLineNo">949</span><a id="line.949">                                nearCCWx = pt.x;</a>
<span class="sourceLineNo">950</span><a id="line.950">                                nearCCWy = pt.y - 1;</a>
<span class="sourceLineNo">951</span><a id="line.951">                                angleCCW = directionAngles[1][0];</a>
<span class="sourceLineNo">952</span><a id="line.952">                                straight = angleCCW;</a>
<span class="sourceLineNo">953</span><a id="line.953">                                nearCWx = pt.x + 1;</a>
<span class="sourceLineNo">954</span><a id="line.954">                                nearCWy = pt.y - 1;</a>
<span class="sourceLineNo">955</span><a id="line.955">                                angleCW = directionAngles[2][0];</a>
<span class="sourceLineNo">956</span><a id="line.956">                                break;</a>
<span class="sourceLineNo">957</span><a id="line.957">                            //negative x, postive y, closer to x-axis</a>
<span class="sourceLineNo">958</span><a id="line.958">                            case 3:</a>
<span class="sourceLineNo">959</span><a id="line.959">                                nearCCWx = pt.x + 1;</a>
<span class="sourceLineNo">960</span><a id="line.960">                                nearCCWy = pt.y;</a>
<span class="sourceLineNo">961</span><a id="line.961">                                angleCCW = directionAngles[2][1];</a>
<span class="sourceLineNo">962</span><a id="line.962">                                straight = angleCCW;</a>
<span class="sourceLineNo">963</span><a id="line.963">                                nearCWx = pt.x + 1;</a>
<span class="sourceLineNo">964</span><a id="line.964">                                nearCWy = pt.y - 1;</a>
<span class="sourceLineNo">965</span><a id="line.965">                                angleCW = directionAngles[2][0];</a>
<span class="sourceLineNo">966</span><a id="line.966">                                break;</a>
<span class="sourceLineNo">967</span><a id="line.967"></a>
<span class="sourceLineNo">968</span><a id="line.968">                            //negative x, negative y, closer to x-axis</a>
<span class="sourceLineNo">969</span><a id="line.969">                            case 4:</a>
<span class="sourceLineNo">970</span><a id="line.970">                                nearCWx = pt.x + 1;</a>
<span class="sourceLineNo">971</span><a id="line.971">                                nearCWy = pt.y;</a>
<span class="sourceLineNo">972</span><a id="line.972">                                angleCW = -directionAngles[2][1];</a>
<span class="sourceLineNo">973</span><a id="line.973">                                straight = angleCW;</a>
<span class="sourceLineNo">974</span><a id="line.974">                                nearCCWx = pt.x + 1;</a>
<span class="sourceLineNo">975</span><a id="line.975">                                nearCCWy = pt.y + 1;</a>
<span class="sourceLineNo">976</span><a id="line.976">                                angleCCW = directionAngles[2][2];</a>
<span class="sourceLineNo">977</span><a id="line.977"></a>
<span class="sourceLineNo">978</span><a id="line.978">                                break;</a>
<span class="sourceLineNo">979</span><a id="line.979">                            //negative x, negative y, closer to y-axis</a>
<span class="sourceLineNo">980</span><a id="line.980">                            case 5:</a>
<span class="sourceLineNo">981</span><a id="line.981">                                nearCWx = pt.x;</a>
<span class="sourceLineNo">982</span><a id="line.982">                                nearCWy = pt.y + 1;</a>
<span class="sourceLineNo">983</span><a id="line.983">                                angleCW = directionAngles[1][2];</a>
<span class="sourceLineNo">984</span><a id="line.984">                                straight = angleCW;</a>
<span class="sourceLineNo">985</span><a id="line.985">                                nearCCWx = pt.x + 1;</a>
<span class="sourceLineNo">986</span><a id="line.986">                                nearCCWy = pt.y + 1;</a>
<span class="sourceLineNo">987</span><a id="line.987">                                angleCCW = directionAngles[2][2];</a>
<span class="sourceLineNo">988</span><a id="line.988">                                break;</a>
<span class="sourceLineNo">989</span><a id="line.989">                            //positive x, negative y, closer to y-axis</a>
<span class="sourceLineNo">990</span><a id="line.990">                            case 6:</a>
<span class="sourceLineNo">991</span><a id="line.991">                                nearCCWx = pt.x;</a>
<span class="sourceLineNo">992</span><a id="line.992">                                nearCCWy = pt.y + 1;</a>
<span class="sourceLineNo">993</span><a id="line.993">                                angleCCW = directionAngles[1][2];</a>
<span class="sourceLineNo">994</span><a id="line.994">                                straight = angleCCW;</a>
<span class="sourceLineNo">995</span><a id="line.995">                                nearCWx = pt.x - 1;</a>
<span class="sourceLineNo">996</span><a id="line.996">                                nearCWy = pt.y + 1;</a>
<span class="sourceLineNo">997</span><a id="line.997">                                angleCW = directionAngles[0][2];</a>
<span class="sourceLineNo">998</span><a id="line.998">                                break;</a>
<span class="sourceLineNo">999</span><a id="line.999">                            //positive x, negative y, closer to x-axis</a>
<span class="sourceLineNo">1000</span><a id="line.1000">                            default:</a>
<span class="sourceLineNo">1001</span><a id="line.1001">                                nearCWx = pt.x - 1;</a>
<span class="sourceLineNo">1002</span><a id="line.1002">                                nearCWy = pt.y;</a>
<span class="sourceLineNo">1003</span><a id="line.1003">                                angleCW = directionAngles[0][1];</a>
<span class="sourceLineNo">1004</span><a id="line.1004">                                straight = angleCW;</a>
<span class="sourceLineNo">1005</span><a id="line.1005">                                nearCCWx = pt.x - 1;</a>
<span class="sourceLineNo">1006</span><a id="line.1006">                                nearCCWy = pt.y + 1;</a>
<span class="sourceLineNo">1007</span><a id="line.1007">                                angleCCW = directionAngles[0][2];</a>
<span class="sourceLineNo">1008</span><a id="line.1008">                                break;</a>
<span class="sourceLineNo">1009</span><a id="line.1009">                        }</a>
<span class="sourceLineNo">1010</span><a id="line.1010">                        nearCCWx += viewerX - maxRadius;</a>
<span class="sourceLineNo">1011</span><a id="line.1011">                        nearCWx += viewerX - maxRadius;</a>
<span class="sourceLineNo">1012</span><a id="line.1012">                        nearCCWy += viewerY - maxRadius;</a>
<span class="sourceLineNo">1013</span><a id="line.1013">                        nearCWy += viewerY - maxRadius;</a>
<span class="sourceLineNo">1014</span><a id="line.1014"></a>
<span class="sourceLineNo">1015</span><a id="line.1015">                        blockedCCW = resMap[nearCCWx][nearCCWy] &gt; 0.5 ||</a>
<span class="sourceLineNo">1016</span><a id="line.1016">                                angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius] &gt;= PI2;</a>
<span class="sourceLineNo">1017</span><a id="line.1017">                        blockedCW = resMap[nearCWx][nearCWy] &gt; 0.5 ||</a>
<span class="sourceLineNo">1018</span><a id="line.1018">                                angleMap[nearCWx - viewerX + maxRadius][nearCWy - viewerY + maxRadius] &gt;= PI2;</a>
<span class="sourceLineNo">1019</span><a id="line.1019"></a>
<span class="sourceLineNo">1020</span><a id="line.1020">                        if( theta == 0 || theta == Math.PI || (Math.abs(theta) - HALF_PI &lt; 0.005 &amp;&amp; Math.abs(theta) - HALF_PI &gt; -0.005))</a>
<span class="sourceLineNo">1021</span><a id="line.1021">                            angleMap[pt.x][pt.y] = (straight == angleCCW)</a>
<span class="sourceLineNo">1022</span><a id="line.1022">                                    ?  (blockedCCW)</a>
<span class="sourceLineNo">1023</span><a id="line.1023">                                    ? PI2</a>
<span class="sourceLineNo">1024</span><a id="line.1024">                                    : angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius]</a>
<span class="sourceLineNo">1025</span><a id="line.1025">                                    : (blockedCW)</a>
<span class="sourceLineNo">1026</span><a id="line.1026">                                    ? PI2</a>
<span class="sourceLineNo">1027</span><a id="line.1027">                                    : angleMap[nearCWx - viewerX + maxRadius][nearCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1028</span><a id="line.1028">                        else {</a>
<span class="sourceLineNo">1029</span><a id="line.1029">                            if (blockedCW &amp;&amp; blockedCCW) {</a>
<span class="sourceLineNo">1030</span><a id="line.1030">                                angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">1031</span><a id="line.1031">                                continue;</a>
<span class="sourceLineNo">1032</span><a id="line.1032">                            }</a>
<span class="sourceLineNo">1033</span><a id="line.1033">                            if (blockedCW) {</a>
<span class="sourceLineNo">1034</span><a id="line.1034">                                angleMap[pt.x][pt.y] = Math.abs(theta - angleCCW) + SLIVER_PI;</a>
<span class="sourceLineNo">1035</span><a id="line.1035">                                //angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1036</span><a id="line.1036">                                //Math.abs(angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius] -</a>
<span class="sourceLineNo">1037</span><a id="line.1037"></a>
<span class="sourceLineNo">1038</span><a id="line.1038"></a>
<span class="sourceLineNo">1039</span><a id="line.1039">                                //angleMap[pt.x][pt.y] = Math.abs(theta - angleCCW) +</a>
<span class="sourceLineNo">1040</span><a id="line.1040">                                //        angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1041</span><a id="line.1041"></a>
<span class="sourceLineNo">1042</span><a id="line.1042">                            } else if (blockedCCW) {</a>
<span class="sourceLineNo">1043</span><a id="line.1043">                                angleMap[pt.x][pt.y] = Math.abs(angleCW - theta) + SLIVER_PI;</a>
<span class="sourceLineNo">1044</span><a id="line.1044">                                //angleMap[nearCWx - viewerX + maxRadius][nearCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1045</span><a id="line.1045">                                //angleMap[nearCWx - viewerX + maxRadius][nearCWy - viewerY + maxRadius]</a>
<span class="sourceLineNo">1046</span><a id="line.1046">                            }</a>
<span class="sourceLineNo">1047</span><a id="line.1047">                            if (!blockedCW)</a>
<span class="sourceLineNo">1048</span><a id="line.1048">                                angleMap[pt.x][pt.y] += 0.5 *</a>
<span class="sourceLineNo">1049</span><a id="line.1049">                                        angleMap[nearCWx - viewerX + maxRadius][nearCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1050</span><a id="line.1050">                            if (!blockedCCW)</a>
<span class="sourceLineNo">1051</span><a id="line.1051">                                angleMap[pt.x][pt.y] += 0.5 *</a>
<span class="sourceLineNo">1052</span><a id="line.1052">                                        angleMap[nearCCWx - viewerX + maxRadius][nearCCWy - viewerY + maxRadius];</a>
<span class="sourceLineNo">1053</span><a id="line.1053">                        }</a>
<span class="sourceLineNo">1054</span><a id="line.1054">                        if(angleMap[pt.x][pt.y] &lt;= fovPermissiveness)</a>
<span class="sourceLineNo">1055</span><a id="line.1055">                            gradientMap[cx][cy] = dist;</a>
<span class="sourceLineNo">1056</span><a id="line.1056">                        else</a>
<span class="sourceLineNo">1057</span><a id="line.1057">                            angleMap[pt.x][pt.y] = PI2;</a>
<span class="sourceLineNo">1058</span><a id="line.1058">                    }</a>
<span class="sourceLineNo">1059</span><a id="line.1059">                }</a>
<span class="sourceLineNo">1060</span><a id="line.1060">            }</a>
<span class="sourceLineNo">1061</span><a id="line.1061">        }</a>
<span class="sourceLineNo">1062</span><a id="line.1062"></a>
<span class="sourceLineNo">1063</span><a id="line.1063">        return gradientMap;</a>
<span class="sourceLineNo">1064</span><a id="line.1064">    }</a>
<span class="sourceLineNo">1065</span><a id="line.1065"></a>
<span class="sourceLineNo">1066</span><a id="line.1066">    public byte[][] slopeShadowFOV(int viewerX, int viewerY)</a>
<span class="sourceLineNo">1067</span><a id="line.1067">    {</a>
<span class="sourceLineNo">1068</span><a id="line.1068">        byte[][] lightMap = new byte[width][height];</a>
<span class="sourceLineNo">1069</span><a id="line.1069">        lightMap[viewerX][viewerY] = (byte)(1 + maxRadius);</a>
<span class="sourceLineNo">1070</span><a id="line.1070"></a>
<span class="sourceLineNo">1071</span><a id="line.1071">        for (Direction d : Direction.DIAGONALS) {</a>
<span class="sourceLineNo">1072</span><a id="line.1072">            slopeShadowCast(1, 1.0, 0.0, 0, d.deltaX, d.deltaY, 0, viewerX, viewerY, lightMap);</a>
<span class="sourceLineNo">1073</span><a id="line.1073">            slopeShadowCast(1, 1.0, 0.0, d.deltaX, 0, 0, d.deltaY, viewerX, viewerY, lightMap);</a>
<span class="sourceLineNo">1074</span><a id="line.1074">        }</a>
<span class="sourceLineNo">1075</span><a id="line.1075">        return lightMap;</a>
<span class="sourceLineNo">1076</span><a id="line.1076">    }</a>
<span class="sourceLineNo">1077</span><a id="line.1077"></a>
<span class="sourceLineNo">1078</span><a id="line.1078">    private byte[][] slopeShadowCast(int row, double start, double end, int xx, int xy, int yx, int yy,</a>
<span class="sourceLineNo">1079</span><a id="line.1079">                                     int viewerX, int viewerY, byte[][] lightMap) {</a>
<span class="sourceLineNo">1080</span><a id="line.1080">        double newStart = 0;</a>
<span class="sourceLineNo">1081</span><a id="line.1081">        if (start &lt; end) {</a>
<span class="sourceLineNo">1082</span><a id="line.1082">            return lightMap;</a>
<span class="sourceLineNo">1083</span><a id="line.1083">        }</a>
<span class="sourceLineNo">1084</span><a id="line.1084">        int width = lightMap.length;</a>
<span class="sourceLineNo">1085</span><a id="line.1085">        int height = lightMap[0].length;</a>
<span class="sourceLineNo">1086</span><a id="line.1086"></a>
<span class="sourceLineNo">1087</span><a id="line.1087">        boolean blocked = false;</a>
<span class="sourceLineNo">1088</span><a id="line.1088">        int dist;</a>
<span class="sourceLineNo">1089</span><a id="line.1089">        for (int distance = row; distance &lt;= maxRadius &amp;&amp; !blocked; distance++) {</a>
<span class="sourceLineNo">1090</span><a id="line.1090">            int deltaY = -distance;</a>
<span class="sourceLineNo">1091</span><a id="line.1091">            for (int deltaX = -distance; deltaX &lt;= 0; deltaX++) {</a>
<span class="sourceLineNo">1092</span><a id="line.1092">                int currentX = viewerX + deltaX * xx + deltaY * xy;</a>
<span class="sourceLineNo">1093</span><a id="line.1093">                int currentY = viewerY + deltaX * yx + deltaY * yy;</a>
<span class="sourceLineNo">1094</span><a id="line.1094">                double leftSlope = (deltaX - 0.5f) / (deltaY + 0.5f);</a>
<span class="sourceLineNo">1095</span><a id="line.1095">                double rightSlope = (deltaX + 0.5f) / (deltaY - 0.5f);</a>
<span class="sourceLineNo">1096</span><a id="line.1096"></a>
<span class="sourceLineNo">1097</span><a id="line.1097">                if (!(currentX &gt;= 0 &amp;&amp; currentY &gt;= 0 &amp;&amp; currentX &lt; width &amp;&amp; currentY &lt; height</a>
<span class="sourceLineNo">1098</span><a id="line.1098">                        &amp;&amp; currentX - viewerX + maxRadius &gt;= 0 &amp;&amp; currentX - viewerX &lt;= maxRadius</a>
<span class="sourceLineNo">1099</span><a id="line.1099">                        &amp;&amp; currentY - viewerY + maxRadius &gt;= 0 &amp;&amp; currentY - viewerY &lt;= maxRadius)</a>
<span class="sourceLineNo">1100</span><a id="line.1100">                        || start &lt; rightSlope) {</a>
<span class="sourceLineNo">1101</span><a id="line.1101">                    continue;</a>
<span class="sourceLineNo">1102</span><a id="line.1102">                } else if (end &gt; leftSlope) {</a>
<span class="sourceLineNo">1103</span><a id="line.1103">                    break;</a>
<span class="sourceLineNo">1104</span><a id="line.1104">                }</a>
<span class="sourceLineNo">1105</span><a id="line.1105"></a>
<span class="sourceLineNo">1106</span><a id="line.1106">                dist = distanceCache[currentX - viewerX + maxRadius][currentY - viewerY + maxRadius];</a>
<span class="sourceLineNo">1107</span><a id="line.1107">                //check if it's within the lightable area and light if needed</a>
<span class="sourceLineNo">1108</span><a id="line.1108">                if (dist &lt;= maxRadius) {</a>
<span class="sourceLineNo">1109</span><a id="line.1109">                    lightMap[currentX][currentY] = (byte) dist;</a>
<span class="sourceLineNo">1110</span><a id="line.1110">                }</a>
<span class="sourceLineNo">1111</span><a id="line.1111"></a>
<span class="sourceLineNo">1112</span><a id="line.1112">                if (blocked) { //previous cell was a blocking one</a>
<span class="sourceLineNo">1113</span><a id="line.1113">                    if (resMap[currentX][currentY] &gt;= 0.5) {//hit a wall</a>
<span class="sourceLineNo">1114</span><a id="line.1114">                        newStart = rightSlope;</a>
<span class="sourceLineNo">1115</span><a id="line.1115">                    } else {</a>
<span class="sourceLineNo">1116</span><a id="line.1116">                        blocked = false;</a>
<span class="sourceLineNo">1117</span><a id="line.1117">                        start = newStart;</a>
<span class="sourceLineNo">1118</span><a id="line.1118">                    }</a>
<span class="sourceLineNo">1119</span><a id="line.1119">                } else {</a>
<span class="sourceLineNo">1120</span><a id="line.1120">                    if (resMap[currentX][currentY] &gt;= 0.5 &amp;&amp; distance &lt; maxRadius) {//hit a wall within sight line</a>
<span class="sourceLineNo">1121</span><a id="line.1121">                        blocked = true;</a>
<span class="sourceLineNo">1122</span><a id="line.1122">                        lightMap = slopeShadowCast(distance + 1, start, leftSlope, xx, xy, yx, yy, viewerX, viewerY, lightMap);</a>
<span class="sourceLineNo">1123</span><a id="line.1123">                        newStart = rightSlope;</a>
<span class="sourceLineNo">1124</span><a id="line.1124">                    }</a>
<span class="sourceLineNo">1125</span><a id="line.1125">                }</a>
<span class="sourceLineNo">1126</span><a id="line.1126">            }</a>
<span class="sourceLineNo">1127</span><a id="line.1127">        }</a>
<span class="sourceLineNo">1128</span><a id="line.1128">        return lightMap;</a>
<span class="sourceLineNo">1129</span><a id="line.1129">    }</a>
<span class="sourceLineNo">1130</span><a id="line.1130"></a>
<span class="sourceLineNo">1131</span><a id="line.1131"></a>
<span class="sourceLineNo">1132</span><a id="line.1132">    public short[][] improveQuality(int viewerX, int viewerY) {</a>
<span class="sourceLineNo">1133</span><a id="line.1133">        if(!complete) throw new IllegalStateException(</a>
<span class="sourceLineNo">1134</span><a id="line.1134">                "cacheAllPerformance() must be called before improveQuality() to fill the cache.");</a>
<span class="sourceLineNo">1135</span><a id="line.1135"></a>
<span class="sourceLineNo">1136</span><a id="line.1136">        if (viewerX &lt; 0 || viewerY &lt; 0 || viewerX &gt;= width || viewerY &gt;= height)</a>
<span class="sourceLineNo">1137</span><a id="line.1137">            return ALL_WALLS;</a>
<span class="sourceLineNo">1138</span><a id="line.1138">        if (resMap[viewerX][viewerY] &gt;= 1.0) {</a>
<span class="sourceLineNo">1139</span><a id="line.1139">            return ALL_WALLS;</a>
<span class="sourceLineNo">1140</span><a id="line.1140">        }</a>
<span class="sourceLineNo">1141</span><a id="line.1141">        short myHilbert = (short)posToHilbert(viewerX, viewerY);</a>
<span class="sourceLineNo">1142</span><a id="line.1142">        ShortVLA packing = new ShortVLA(128);</a>
<span class="sourceLineNo">1143</span><a id="line.1143">        short[][] packed = new short[maxRadius + 1][], cached = cache[viewerX + viewerY * width];</a>
<span class="sourceLineNo">1144</span><a id="line.1144">        short[] losCached = losCache[viewerX + viewerY * width];</a>
<span class="sourceLineNo">1145</span><a id="line.1145"></a>
<span class="sourceLineNo">1146</span><a id="line.1146">        ///*</a>
<span class="sourceLineNo">1147</span><a id="line.1147">        //short[] perimeter = allPackedHilbert(fringe(losCached, 2, width, height));</a>
<span class="sourceLineNo">1148</span><a id="line.1148">        int xr = Math.max(0, viewerX - 1 - maxLOSRadius), yr = Math.max(0, viewerY - 1 - maxLOSRadius),</a>
<span class="sourceLineNo">1149</span><a id="line.1149">                wr = Math.min(width - 1 - viewerX, maxLOSRadius * 2 + 3),</a>
<span class="sourceLineNo">1150</span><a id="line.1150">                hr = Math.min(height - 1 - viewerY, maxLOSRadius * 2 + 3);</a>
<span class="sourceLineNo">1151</span><a id="line.1151">        short[] perimeter = rectangleHilbert(xr, yr, wr, hr);</a>
<span class="sourceLineNo">1152</span><a id="line.1152">        short p_x, p_y;</a>
<span class="sourceLineNo">1153</span><a id="line.1153">        for (int i = 0; i &lt; perimeter.length; i++) {</a>
<span class="sourceLineNo">1154</span><a id="line.1154">            p_x = hilbertX[perimeter[i] &amp; 0xffff];</a>
<span class="sourceLineNo">1155</span><a id="line.1155">            p_y = hilbertY[perimeter[i] &amp; 0xffff];</a>
<span class="sourceLineNo">1156</span><a id="line.1156">            if (queryPackedHilbert(losCache[p_x + p_y * width], myHilbert))</a>
<span class="sourceLineNo">1157</span><a id="line.1157">                packing.add(perimeter[i]);</a>
<span class="sourceLineNo">1158</span><a id="line.1158">        }</a>
<span class="sourceLineNo">1159</span><a id="line.1159">        //*/</a>
<span class="sourceLineNo">1160</span><a id="line.1160">        /*</a>
<span class="sourceLineNo">1161</span><a id="line.1161">        boolean[][] losUnpacked = unpack(losCached, width, height);</a>
<span class="sourceLineNo">1162</span><a id="line.1162">        for (int x = Math.max(0, viewerX - 62); x &lt;= Math.min(viewerX + 62, width - 1); x++) {</a>
<span class="sourceLineNo">1163</span><a id="line.1163">            for (int y = Math.max(0, viewerY - 62); y &lt;= Math.min(viewerY + 62, height - 1); y++) {</a>
<span class="sourceLineNo">1164</span><a id="line.1164">                if (losUnpacked[x][y])</a>
<span class="sourceLineNo">1165</span><a id="line.1165">                    continue;</a>
<span class="sourceLineNo">1166</span><a id="line.1166">                if(losCache[x + y * width] == ALL_WALL)</a>
<span class="sourceLineNo">1167</span><a id="line.1167">                    continue;</a>
<span class="sourceLineNo">1168</span><a id="line.1168">                if (distance(x - viewerX, y - viewerY) / 2 &gt; 62)</a>
<span class="sourceLineNo">1169</span><a id="line.1169">                    continue;</a>
<span class="sourceLineNo">1170</span><a id="line.1170">                if (queryPackedHilbert(losCache[x + y * width], myHilbert))</a>
<span class="sourceLineNo">1171</span><a id="line.1171">                    packing.add((short) posToHilbert(x, y));</a>
<span class="sourceLineNo">1172</span><a id="line.1172">            }</a>
<span class="sourceLineNo">1173</span><a id="line.1173">        }</a>
<span class="sourceLineNo">1174</span><a id="line.1174">        */</a>
<span class="sourceLineNo">1175</span><a id="line.1175">        losCache[viewerX + viewerY * width] = insertSeveralPacked(losCached, packing.asInts());</a>
<span class="sourceLineNo">1176</span><a id="line.1176"></a>
<span class="sourceLineNo">1177</span><a id="line.1177"></a>
<span class="sourceLineNo">1178</span><a id="line.1178">        for (int l = 0; l &lt;= maxRadius; l++) {</a>
<span class="sourceLineNo">1179</span><a id="line.1179">            packing.clear();</a>
<span class="sourceLineNo">1180</span><a id="line.1180">            xr = Math.max(0, viewerX - l);</a>
<span class="sourceLineNo">1181</span><a id="line.1181">            yr = Math.max(0, viewerY - l);</a>
<span class="sourceLineNo">1182</span><a id="line.1182">            wr = Math.min(width - viewerX + l, l * 2 + 1);</a>
<span class="sourceLineNo">1183</span><a id="line.1183">            hr = Math.min(height - viewerY + l, l * 2 + 1);</a>
<span class="sourceLineNo">1184</span><a id="line.1184">            perimeter = rectangleHilbert(xr, yr, wr, hr);</a>
<span class="sourceLineNo">1185</span><a id="line.1185"></a>
<span class="sourceLineNo">1186</span><a id="line.1186">            //short p_x, p_y;</a>
<span class="sourceLineNo">1187</span><a id="line.1187">            for (int i = 0; i &lt; perimeter.length; i++) {</a>
<span class="sourceLineNo">1188</span><a id="line.1188">                if(queryPackedHilbert(cached[maxRadius - l], perimeter[i])) {</a>
<span class="sourceLineNo">1189</span><a id="line.1189">                    packing.add(perimeter[i]);</a>
<span class="sourceLineNo">1190</span><a id="line.1190">                    continue;</a>
<span class="sourceLineNo">1191</span><a id="line.1191">                }</a>
<span class="sourceLineNo">1192</span><a id="line.1192">                p_x = hilbertX[perimeter[i] &amp; 0xffff];</a>
<span class="sourceLineNo">1193</span><a id="line.1193">                p_y = hilbertY[perimeter[i] &amp; 0xffff];</a>
<span class="sourceLineNo">1194</span><a id="line.1194"></a>
<span class="sourceLineNo">1195</span><a id="line.1195">                if(p_y &gt;= height || p_x &gt;= width || cache[p_x + p_y * width] == ALL_WALLS)</a>
<span class="sourceLineNo">1196</span><a id="line.1196">                    continue;</a>
<span class="sourceLineNo">1197</span><a id="line.1197"></a>
<span class="sourceLineNo">1198</span><a id="line.1198">                if (distance(p_x - viewerX, p_y - viewerY) &gt;&gt; 1 &gt; l)</a>
<span class="sourceLineNo">1199</span><a id="line.1199">                    continue;</a>
<span class="sourceLineNo">1200</span><a id="line.1200">                if (queryPackedHilbert(cache[p_x + p_y * width][maxRadius - l], myHilbert))</a>
<span class="sourceLineNo">1201</span><a id="line.1201">                    packing.add(perimeter[i]);</a>
<span class="sourceLineNo">1202</span><a id="line.1202">            }</a>
<span class="sourceLineNo">1203</span><a id="line.1203">            /*</a>
<span class="sourceLineNo">1204</span><a id="line.1204">            knownSeen = cached[maxRadius - l];</a>
<span class="sourceLineNo">1205</span><a id="line.1205">            for (int x = Math.max(0, viewerX - l); x &lt;= Math.min(viewerX + l, width - 1); x++) {</a>
<span class="sourceLineNo">1206</span><a id="line.1206">                for (int y = Math.max(0, viewerY - l); y &lt;= Math.min(viewerY + l, height - 1); y++) {</a>
<span class="sourceLineNo">1207</span><a id="line.1207">                    if(cache[x + y * width] == ALL_WALLS)</a>
<span class="sourceLineNo">1208</span><a id="line.1208">                        continue;</a>
<span class="sourceLineNo">1209</span><a id="line.1209">                    if (distance(x - viewerX, y - viewerY) / 2 &gt; l)</a>
<span class="sourceLineNo">1210</span><a id="line.1210">                        continue;</a>
<span class="sourceLineNo">1211</span><a id="line.1211">                    short i = (short) posToHilbert(x, y);</a>
<span class="sourceLineNo">1212</span><a id="line.1212">                    if (queryPackedHilbert(knownSeen, i))</a>
<span class="sourceLineNo">1213</span><a id="line.1213">                        continue;</a>
<span class="sourceLineNo">1214</span><a id="line.1214">                    if (queryPackedHilbert(cache[x + y * width][maxRadius - l], myHilbert))</a>
<span class="sourceLineNo">1215</span><a id="line.1215">                        packing.add(i);</a>
<span class="sourceLineNo">1216</span><a id="line.1216">                }</a>
<span class="sourceLineNo">1217</span><a id="line.1217">            }*/</a>
<span class="sourceLineNo">1218</span><a id="line.1218">            packed[maxRadius - l] = packSeveral(packing.asInts());</a>
<span class="sourceLineNo">1219</span><a id="line.1219">            Coord light;</a>
<span class="sourceLineNo">1220</span><a id="line.1220">            for (int i = 0; i &lt; lightSources.length; i++) {</a>
<span class="sourceLineNo">1221</span><a id="line.1221">                light = lightSources[i];</a>
<span class="sourceLineNo">1222</span><a id="line.1222">                packed[maxRadius - l] = unionPacked(packed[maxRadius - l], differencePacked(intersectPacked(losCached,</a>
<span class="sourceLineNo">1223</span><a id="line.1223">                        cache[light.x + light.y * width][maxRadius - lightBrightnesses[i]]), wallMap));</a>
<span class="sourceLineNo">1224</span><a id="line.1224">            }</a>
<span class="sourceLineNo">1225</span><a id="line.1225">        }</a>
<span class="sourceLineNo">1226</span><a id="line.1226"></a>
<span class="sourceLineNo">1227</span><a id="line.1227">        return packed;</a>
<span class="sourceLineNo">1228</span><a id="line.1228">    }</a>
<span class="sourceLineNo">1229</span><a id="line.1229"></a>
<span class="sourceLineNo">1230</span><a id="line.1230">    /**</a>
<span class="sourceLineNo">1231</span><a id="line.1231">     * Runs FOV calculations on another thread, without interrupting this one. Before using the cache, you should call</a>
<span class="sourceLineNo">1232</span><a id="line.1232">     * awaitCachePerformance() to ensure this method has finished on its own thread, but be aware that this will cause</a>
<span class="sourceLineNo">1233</span><a id="line.1233">     * the thread that calls awaitCachePerformance() to essentially freeze until FOV calculations are over.</a>
<span class="sourceLineNo">1234</span><a id="line.1234">     */</a>
<span class="sourceLineNo">1235</span><a id="line.1235">    private void cacheAllPerformance() {</a>
<span class="sourceLineNo">1236</span><a id="line.1236">        if(performanceThread != null || complete)</a>
<span class="sourceLineNo">1237</span><a id="line.1237">            return;</a>
<span class="sourceLineNo">1238</span><a id="line.1238">        performanceThread = new Thread(new PerformanceUnit());</a>
<span class="sourceLineNo">1239</span><a id="line.1239">        performanceThread.start();</a>
<span class="sourceLineNo">1240</span><a id="line.1240">    }</a>
<span class="sourceLineNo">1241</span><a id="line.1241"></a>
<span class="sourceLineNo">1242</span><a id="line.1242">    /**</a>
<span class="sourceLineNo">1243</span><a id="line.1243">     * If FOV calculations from cacheAllPerformance() are being done on another thread, calling this method will make</a>
<span class="sourceLineNo">1244</span><a id="line.1244">     * the current thread wait for the FOV calculations' thread to finish, "freezing" the current thread until it does.</a>
<span class="sourceLineNo">1245</span><a id="line.1245">     * This ensures the cache will be complete after this method returns true, and if this method returns false, then</a>
<span class="sourceLineNo">1246</span><a id="line.1246">     * something has gone wrong.</a>
<span class="sourceLineNo">1247</span><a id="line.1247">     * @return true if cacheAllPerformance() has successfully completed, false otherwise.</a>
<span class="sourceLineNo">1248</span><a id="line.1248">     */</a>
<span class="sourceLineNo">1249</span><a id="line.1249">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">1250</span><a id="line.1250">        private boolean awaitCachePerformance()</a>
<span class="sourceLineNo">1251</span><a id="line.1251">    {</a>
<span class="sourceLineNo">1252</span><a id="line.1252">        if(performanceThread == null &amp;&amp; !complete)</a>
<span class="sourceLineNo">1253</span><a id="line.1253">            cacheAllPerformance();</a>
<span class="sourceLineNo">1254</span><a id="line.1254">        if(complete) return true;</a>
<span class="sourceLineNo">1255</span><a id="line.1255">        try {</a>
<span class="sourceLineNo">1256</span><a id="line.1256">            performanceThread.join();</a>
<span class="sourceLineNo">1257</span><a id="line.1257">        } catch (InterruptedException e) {</a>
<span class="sourceLineNo">1258</span><a id="line.1258">            return false;</a>
<span class="sourceLineNo">1259</span><a id="line.1259">        }</a>
<span class="sourceLineNo">1260</span><a id="line.1260">        return complete;</a>
<span class="sourceLineNo">1261</span><a id="line.1261">    }</a>
<span class="sourceLineNo">1262</span><a id="line.1262"></a>
<span class="sourceLineNo">1263</span><a id="line.1263">    /**</a>
<span class="sourceLineNo">1264</span><a id="line.1264">     * Runs FOV calculations on another thread, without interrupting this one, then performs additional quality tweaks</a>
<span class="sourceLineNo">1265</span><a id="line.1265">     * and adds any distant lights, if there were any in the constructor. Before using the cache, you should call</a>
<span class="sourceLineNo">1266</span><a id="line.1266">     * awaitCache() to ensure this method has finished on its own thread, but be aware that this will cause</a>
<span class="sourceLineNo">1267</span><a id="line.1267">     * the thread that calls awaitCache() to essentially freeze until FOV calculations are over.</a>
<span class="sourceLineNo">1268</span><a id="line.1268">     */</a>
<span class="sourceLineNo">1269</span><a id="line.1269">    public void cacheAll()</a>
<span class="sourceLineNo">1270</span><a id="line.1270">    {</a>
<span class="sourceLineNo">1271</span><a id="line.1271">        if(qualityThread != null || qualityComplete)</a>
<span class="sourceLineNo">1272</span><a id="line.1272">            return;</a>
<span class="sourceLineNo">1273</span><a id="line.1273">        if(!complete) {</a>
<span class="sourceLineNo">1274</span><a id="line.1274">            cacheAllPerformance();</a>
<span class="sourceLineNo">1275</span><a id="line.1275">            try {</a>
<span class="sourceLineNo">1276</span><a id="line.1276">                performanceThread.join();</a>
<span class="sourceLineNo">1277</span><a id="line.1277">            } catch (InterruptedException e) {</a>
<span class="sourceLineNo">1278</span><a id="line.1278">                return;</a>
<span class="sourceLineNo">1279</span><a id="line.1279">            }</a>
<span class="sourceLineNo">1280</span><a id="line.1280">        }</a>
<span class="sourceLineNo">1281</span><a id="line.1281"></a>
<span class="sourceLineNo">1282</span><a id="line.1282">        qualityThread = new Thread(new QualityUnit());</a>
<span class="sourceLineNo">1283</span><a id="line.1283">        qualityThread.start();</a>
<span class="sourceLineNo">1284</span><a id="line.1284">    }</a>
<span class="sourceLineNo">1285</span><a id="line.1285"></a>
<span class="sourceLineNo">1286</span><a id="line.1286">    /**</a>
<span class="sourceLineNo">1287</span><a id="line.1287">     * If FOV calculations from cacheAll() are being done on another thread, calling this method will make</a>
<span class="sourceLineNo">1288</span><a id="line.1288">     * the current thread wait for the FOV calculations' thread to finish, "freezing" the current thread until it does.</a>
<span class="sourceLineNo">1289</span><a id="line.1289">     * This ensures the cache will be complete with the additional quality improvements such as distant lights after</a>
<span class="sourceLineNo">1290</span><a id="line.1290">     * this method returns true, and if this method returns false, then something has gone wrong.</a>
<span class="sourceLineNo">1291</span><a id="line.1291">     * @return true if cacheAll() has successfully completed, false otherwise.</a>
<span class="sourceLineNo">1292</span><a id="line.1292">     */</a>
<span class="sourceLineNo">1293</span><a id="line.1293">    public boolean awaitCache()</a>
<span class="sourceLineNo">1294</span><a id="line.1294">    {</a>
<span class="sourceLineNo">1295</span><a id="line.1295">        if(performanceThread == null || !complete || (qualityThread == null &amp;&amp; !qualityComplete))</a>
<span class="sourceLineNo">1296</span><a id="line.1296">            cacheAll();</a>
<span class="sourceLineNo">1297</span><a id="line.1297">        if(qualityComplete) return true;</a>
<span class="sourceLineNo">1298</span><a id="line.1298">        try {</a>
<span class="sourceLineNo">1299</span><a id="line.1299">            qualityThread.join();</a>
<span class="sourceLineNo">1300</span><a id="line.1300">        } catch (Exception e) {</a>
<span class="sourceLineNo">1301</span><a id="line.1301">            return false;</a>
<span class="sourceLineNo">1302</span><a id="line.1302">        }</a>
<span class="sourceLineNo">1303</span><a id="line.1303">        return qualityComplete;</a>
<span class="sourceLineNo">1304</span><a id="line.1304">    }</a>
<span class="sourceLineNo">1305</span><a id="line.1305"></a>
<span class="sourceLineNo">1306</span><a id="line.1306">    /**</a>
<span class="sourceLineNo">1307</span><a id="line.1307">     * Runs FOV calculations for any cells that were changed as a result of newMap being different from the map passed</a>
<span class="sourceLineNo">1308</span><a id="line.1308">     * to the FOVCache constructor. It runs these on another thread, without interrupting this one. Before using the</a>
<span class="sourceLineNo">1309</span><a id="line.1309">     * cache, you should call awaitRefresh() to ensure this method has finished on its own thread, but be aware that</a>
<span class="sourceLineNo">1310</span><a id="line.1310">     * this will cause the thread that calls awaitRefresh() to essentially freeze until FOV calculations are over.</a>
<span class="sourceLineNo">1311</span><a id="line.1311">     */</a>
<span class="sourceLineNo">1312</span><a id="line.1312">    public void refreshCache(char[][] newMap)</a>
<span class="sourceLineNo">1313</span><a id="line.1313">    {</a>
<span class="sourceLineNo">1314</span><a id="line.1314">        performanceThread = new Thread(new RefreshUnit(newMap));</a>
<span class="sourceLineNo">1315</span><a id="line.1315">        performanceThread.start();</a>
<span class="sourceLineNo">1316</span><a id="line.1316">    }</a>
<span class="sourceLineNo">1317</span><a id="line.1317"></a>
<span class="sourceLineNo">1318</span><a id="line.1318">    /**</a>
<span class="sourceLineNo">1319</span><a id="line.1319">     * If FOV calculations from refreshCache() are being done on another thread, calling this method will make</a>
<span class="sourceLineNo">1320</span><a id="line.1320">     * the current thread wait for the FOV calculations' thread to finish, "freezing" the current thread until it does.</a>
<span class="sourceLineNo">1321</span><a id="line.1321">     * This ensures the cache will be complete with the updates from things like opening a door after</a>
<span class="sourceLineNo">1322</span><a id="line.1322">     * this method returns true, and if this method returns false, then something has gone wrong.</a>
<span class="sourceLineNo">1323</span><a id="line.1323">     * @return true if refreshCache() has successfully completed, false otherwise.</a>
<span class="sourceLineNo">1324</span><a id="line.1324">     */</a>
<span class="sourceLineNo">1325</span><a id="line.1325">    public boolean awaitRefresh(char[][] newMap)</a>
<span class="sourceLineNo">1326</span><a id="line.1326">    {</a>
<span class="sourceLineNo">1327</span><a id="line.1327">        if(!performanceThread.isAlive() &amp;&amp; !refreshComplete)</a>
<span class="sourceLineNo">1328</span><a id="line.1328">            refreshCache(newMap);</a>
<span class="sourceLineNo">1329</span><a id="line.1329">        if(refreshComplete) return true;</a>
<span class="sourceLineNo">1330</span><a id="line.1330">        try {</a>
<span class="sourceLineNo">1331</span><a id="line.1331">            performanceThread.join();</a>
<span class="sourceLineNo">1332</span><a id="line.1332">        } catch (InterruptedException e) {</a>
<span class="sourceLineNo">1333</span><a id="line.1333">            return false;</a>
<span class="sourceLineNo">1334</span><a id="line.1334">        }</a>
<span class="sourceLineNo">1335</span><a id="line.1335">        if(refreshComplete)</a>
<span class="sourceLineNo">1336</span><a id="line.1336">        {</a>
<span class="sourceLineNo">1337</span><a id="line.1337">            refreshComplete = false;</a>
<span class="sourceLineNo">1338</span><a id="line.1338">            return true;</a>
<span class="sourceLineNo">1339</span><a id="line.1339">        }</a>
<span class="sourceLineNo">1340</span><a id="line.1340">        else return false;</a>
<span class="sourceLineNo">1341</span><a id="line.1341">    }</a>
<span class="sourceLineNo">1342</span><a id="line.1342"></a>
<span class="sourceLineNo">1343</span><a id="line.1343"></a>
<span class="sourceLineNo">1344</span><a id="line.1344">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">1345</span><a id="line.1345">        private byte heuristic(Direction target) {</a>
<span class="sourceLineNo">1346</span><a id="line.1346">        switch (radiusKind) {</a>
<span class="sourceLineNo">1347</span><a id="line.1347">            case CIRCLE:</a>
<span class="sourceLineNo">1348</span><a id="line.1348">            case SPHERE:</a>
<span class="sourceLineNo">1349</span><a id="line.1349">                switch (target) {</a>
<span class="sourceLineNo">1350</span><a id="line.1350">                    case DOWN_LEFT:</a>
<span class="sourceLineNo">1351</span><a id="line.1351">                    case DOWN_RIGHT:</a>
<span class="sourceLineNo">1352</span><a id="line.1352">                    case UP_LEFT:</a>
<span class="sourceLineNo">1353</span><a id="line.1353">                    case UP_RIGHT:</a>
<span class="sourceLineNo">1354</span><a id="line.1354">                        return 3;</a>
<span class="sourceLineNo">1355</span><a id="line.1355">                    default:</a>
<span class="sourceLineNo">1356</span><a id="line.1356">                        return 2;</a>
<span class="sourceLineNo">1357</span><a id="line.1357">                }</a>
<span class="sourceLineNo">1358</span><a id="line.1358">            default:</a>
<span class="sourceLineNo">1359</span><a id="line.1359">                return 2;</a>
<span class="sourceLineNo">1360</span><a id="line.1360">        }</a>
<span class="sourceLineNo">1361</span><a id="line.1361">    }</a>
<span class="sourceLineNo">1362</span><a id="line.1362">    private short distance(int xPos, int yPos) {</a>
<span class="sourceLineNo">1363</span><a id="line.1363">        int x = Math.abs(xPos), y = Math.abs(yPos);</a>
<span class="sourceLineNo">1364</span><a id="line.1364">        switch (radiusKind) {</a>
<span class="sourceLineNo">1365</span><a id="line.1365">            case CIRCLE:</a>
<span class="sourceLineNo">1366</span><a id="line.1366">            case SPHERE:</a>
<span class="sourceLineNo">1367</span><a id="line.1367">            {</a>
<span class="sourceLineNo">1368</span><a id="line.1368">                if(x == y)</a>
<span class="sourceLineNo">1369</span><a id="line.1369">                    return (short)(3 * x);</a>
<span class="sourceLineNo">1370</span><a id="line.1370">                else if(x &lt; y)</a>
<span class="sourceLineNo">1371</span><a id="line.1371">                    return (short)(3 * x + 2 * (y - x));</a>
<span class="sourceLineNo">1372</span><a id="line.1372">                else</a>
<span class="sourceLineNo">1373</span><a id="line.1373">                    return (short)(3 * y + 2 * (x - y));</a>
<span class="sourceLineNo">1374</span><a id="line.1374">            }</a>
<span class="sourceLineNo">1375</span><a id="line.1375">            case DIAMOND:</a>
<span class="sourceLineNo">1376</span><a id="line.1376">            case OCTAHEDRON:</a>
<span class="sourceLineNo">1377</span><a id="line.1377">                return (short)(2 * (x + y));</a>
<span class="sourceLineNo">1378</span><a id="line.1378">            default:</a>
<span class="sourceLineNo">1379</span><a id="line.1379">                return (short)(2 * Math.max(x, y));</a>
<span class="sourceLineNo">1380</span><a id="line.1380">        }</a>
<span class="sourceLineNo">1381</span><a id="line.1381">    }</a>
<span class="sourceLineNo">1382</span><a id="line.1382"></a>
<span class="sourceLineNo">1383</span><a id="line.1383">    /**</a>
<span class="sourceLineNo">1384</span><a id="line.1384">     * Calculates the Field Of View for the provided map from the given x, y</a>
<span class="sourceLineNo">1385</span><a id="line.1385">     * coordinates. Returns a light map where the values are either 1.0 or 0.0.</a>
<span class="sourceLineNo">1386</span><a id="line.1386">     * Takes a double[][] resistance map that will be disregarded.</a>
<span class="sourceLineNo">1387</span><a id="line.1387">     * &lt;br&gt;</a>
<span class="sourceLineNo">1388</span><a id="line.1388">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1389</span><a id="line.1389">     * of the origin cell. Radius determinations are based on the radiusKind given</a>
<span class="sourceLineNo">1390</span><a id="line.1390">     * in construction. The light will be treated as having radius 62, regardless</a>
<span class="sourceLineNo">1391</span><a id="line.1391">     * of the maxRadius passed to the constructor; this should in most cases be</a>
<span class="sourceLineNo">1392</span><a id="line.1392">     * suitable when limitless light is desired.</a>
<span class="sourceLineNo">1393</span><a id="line.1393">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1394</span><a id="line.1394">     * map using Shadow FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1395</span><a id="line.1395">     * be cached.</a>
<span class="sourceLineNo">1396</span><a id="line.1396">     *</a>
<span class="sourceLineNo">1397</span><a id="line.1397">     * @param resistanceMap the grid of cells to calculate on</a>
<span class="sourceLineNo">1398</span><a id="line.1398">     * @param startx        the horizontal component of the starting location</a>
<span class="sourceLineNo">1399</span><a id="line.1399">     * @param starty        the vertical component of the starting location</a>
<span class="sourceLineNo">1400</span><a id="line.1400">     * @return the computed light grid</a>
<span class="sourceLineNo">1401</span><a id="line.1401">     */</a>
<span class="sourceLineNo">1402</span><a id="line.1402">    @Override</a>
<span class="sourceLineNo">1403</span><a id="line.1403">    public double[][] calculateFOV(double[][] resistanceMap, int startx, int starty) {</a>
<span class="sourceLineNo">1404</span><a id="line.1404">        if(qualityComplete || complete)</a>
<span class="sourceLineNo">1405</span><a id="line.1405">            return unpackDouble(losCache[startx + starty * width], width, height);</a>
<span class="sourceLineNo">1406</span><a id="line.1406">        else</a>
<span class="sourceLineNo">1407</span><a id="line.1407">            return fov.calculateFOV(resMap, startx, starty, maxRadius, radiusKind);</a>
<span class="sourceLineNo">1408</span><a id="line.1408">    }</a>
<span class="sourceLineNo">1409</span><a id="line.1409"></a>
<span class="sourceLineNo">1410</span><a id="line.1410">    /*</a>
<span class="sourceLineNo">1411</span><a id="line.1411">     * Calculates the Field Of View for the provided map from the given x, y</a>
<span class="sourceLineNo">1412</span><a id="line.1412">     * coordinates. Returns a light map where the values are either 1.0 or 0.0.</a>
<span class="sourceLineNo">1413</span><a id="line.1413">     * Takes a double radius to extend out to (rounded to the nearest int) and</a>
<span class="sourceLineNo">1414</span><a id="line.1414">     * a double[][] resistance map that will be disregarded.</a>
<span class="sourceLineNo">1415</span><a id="line.1415">     * &lt;br&gt;</a>
<span class="sourceLineNo">1416</span><a id="line.1416">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1417</span><a id="line.1417">     * of the origin cell. Radius determinations are based on the radiusKind given</a>
<span class="sourceLineNo">1418</span><a id="line.1418">     * in construction. The light will be treated as having the given radius, but</a>
<span class="sourceLineNo">1419</span><a id="line.1419">     * if that is higher than the maximum possible radius stored by this FOVCache,</a>
<span class="sourceLineNo">1420</span><a id="line.1420">     * it will compute a new FOV map using Shadow FOV instead of using the cache.</a>
<span class="sourceLineNo">1421</span><a id="line.1421">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1422</span><a id="line.1422">     * map using Shadow FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1423</span><a id="line.1423">     * be cached.</a>
<span class="sourceLineNo">1424</span><a id="line.1424">     *</a>
<span class="sourceLineNo">1425</span><a id="line.1425">     * @param resistanceMap the grid of cells to calculate on</a>
<span class="sourceLineNo">1426</span><a id="line.1426">     * @param startx        the horizontal component of the starting location</a>
<span class="sourceLineNo">1427</span><a id="line.1427">     * @param starty        the vertical component of the starting location</a>
<span class="sourceLineNo">1428</span><a id="line.1428">     * @param radius        the distance the light will extend to</a>
<span class="sourceLineNo">1429</span><a id="line.1429">     * @return the computed light grid</a>
<span class="sourceLineNo">1430</span><a id="line.1430">     */</a>
<span class="sourceLineNo">1431</span><a id="line.1431">    /*</a>
<span class="sourceLineNo">1432</span><a id="line.1432">    @Override</a>
<span class="sourceLineNo">1433</span><a id="line.1433">    public double[][] calculateFOV(double[][] resistanceMap, int startx, int starty, double radius) {</a>
<span class="sourceLineNo">1434</span><a id="line.1434">        if((qualityComplete || complete) &amp;&amp; radius &gt;= 0 &amp;&amp; radius &lt;= maxRadius)</a>
<span class="sourceLineNo">1435</span><a id="line.1435">            return unpackDouble(cache[startx + starty * width][maxRadius - (int) Math.round(radius)], width, height);</a>
<span class="sourceLineNo">1436</span><a id="line.1436">        else</a>
<span class="sourceLineNo">1437</span><a id="line.1437">            return fov.calculateFOV(resMap, startx, starty, radius, radiusKind);</a>
<span class="sourceLineNo">1438</span><a id="line.1438">    }*/</a>
<span class="sourceLineNo">1439</span><a id="line.1439"></a>
<span class="sourceLineNo">1440</span><a id="line.1440"></a>
<span class="sourceLineNo">1441</span><a id="line.1441">    /*</a>
<span class="sourceLineNo">1442</span><a id="line.1442">     * Calculates the Field Of View for the provided map from the given x, y</a>
<span class="sourceLineNo">1443</span><a id="line.1443">     * coordinates. Returns a light map where the values are either 1.0 or 0.0.</a>
<span class="sourceLineNo">1444</span><a id="line.1444">     * Takes a double radius to extend out to (rounded to the nearest int), a</a>
<span class="sourceLineNo">1445</span><a id="line.1445">     * Radius enum that should match the Radius this FOVCache was constructed</a>
<span class="sourceLineNo">1446</span><a id="line.1446">     * with, and a double[][] resistance map that will be disregarded.</a>
<span class="sourceLineNo">1447</span><a id="line.1447">     * &lt;br&gt;</a>
<span class="sourceLineNo">1448</span><a id="line.1448">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1449</span><a id="line.1449">     * of the origin cell. Radius determinations are based on the radiusTechnique</a>
<span class="sourceLineNo">1450</span><a id="line.1450">     * passed to this method, but will only use the cache if the Radius given is</a>
<span class="sourceLineNo">1451</span><a id="line.1451">     * the same kind as the one given in construction. The light will be treated</a>
<span class="sourceLineNo">1452</span><a id="line.1452">     * as having the given radius, but if that is higher than the maximum possible</a>
<span class="sourceLineNo">1453</span><a id="line.1453">     * radius stored by this FOVCache, it will compute a new FOV map using Shadow</a>
<span class="sourceLineNo">1454</span><a id="line.1454">     * FOV instead of using the cache.</a>
<span class="sourceLineNo">1455</span><a id="line.1455">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1456</span><a id="line.1456">     * map using Shadow FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1457</span><a id="line.1457">     * be cached.</a>
<span class="sourceLineNo">1458</span><a id="line.1458">     *</a>
<span class="sourceLineNo">1459</span><a id="line.1459">     * @param resistanceMap   the grid of cells to calculate on</a>
<span class="sourceLineNo">1460</span><a id="line.1460">     * @param startX          the horizontal component of the starting location</a>
<span class="sourceLineNo">1461</span><a id="line.1461">     * @param startY          the vertical component of the starting location</a>
<span class="sourceLineNo">1462</span><a id="line.1462">     * @param radius          the distance the light will extend to</a>
<span class="sourceLineNo">1463</span><a id="line.1463">     * @param radiusTechnique provides a means to calculate the radius as desired</a>
<span class="sourceLineNo">1464</span><a id="line.1464">     * @return the computed light grid</a>
<span class="sourceLineNo">1465</span><a id="line.1465">     */</a>
<span class="sourceLineNo">1466</span><a id="line.1466">    /*</a>
<span class="sourceLineNo">1467</span><a id="line.1467">    @Override</a>
<span class="sourceLineNo">1468</span><a id="line.1468">    public double[][] calculateFOV(double[][] resistanceMap, int startX, int startY, double radius,</a>
<span class="sourceLineNo">1469</span><a id="line.1469">                                   Radius radiusTechnique) {</a>
<span class="sourceLineNo">1470</span><a id="line.1470">        if((qualityComplete || complete) &amp;&amp; radius &gt;= 0 &amp;&amp; radius &lt;= maxRadius &amp;&amp;</a>
<span class="sourceLineNo">1471</span><a id="line.1471">                radiusKind.equals2D(radiusTechnique))</a>
<span class="sourceLineNo">1472</span><a id="line.1472">            return unpackDouble(cache[startX + startY * width][maxRadius - (int) Math.round(radius)], width, height);</a>
<span class="sourceLineNo">1473</span><a id="line.1473">        else</a>
<span class="sourceLineNo">1474</span><a id="line.1474">            return fov.calculateFOV(resMap, startX, startY, radius, radiusTechnique);</a>
<span class="sourceLineNo">1475</span><a id="line.1475">    }*/</a>
<span class="sourceLineNo">1476</span><a id="line.1476"></a>
<span class="sourceLineNo">1477</span><a id="line.1477">    /*</a>
<span class="sourceLineNo">1478</span><a id="line.1478">     * Calculates the conical Field Of View for the provided map from the given</a>
<span class="sourceLineNo">1479</span><a id="line.1479">     * x, y coordinates. Returns a light map where the values are either 1.0 or</a>
<span class="sourceLineNo">1480</span><a id="line.1480">     * 0.0. Takes a double radius to extend out to (rounded to the nearest int),</a>
<span class="sourceLineNo">1481</span><a id="line.1481">     * a Radius enum that should match the Radius this FOVCache was constructed</a>
<span class="sourceLineNo">1482</span><a id="line.1482">     * with, a double[][] resistance map that will be disregarded, an angle to</a>
<span class="sourceLineNo">1483</span><a id="line.1483">     * center the conical FOV on (in degrees), and the total span in degrees</a>
<span class="sourceLineNo">1484</span><a id="line.1484">     * for the FOV to cover.</a>
<span class="sourceLineNo">1485</span><a id="line.1485">     * &lt;br&gt;</a>
<span class="sourceLineNo">1486</span><a id="line.1486">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1487</span><a id="line.1487">     * of the origin cell. Radius determinations are based on the radiusTechnique</a>
<span class="sourceLineNo">1488</span><a id="line.1488">     * passed to this method, but will only use the cache if the Radius given is</a>
<span class="sourceLineNo">1489</span><a id="line.1489">     * the same kind as the one given in construction. The light will be treated</a>
<span class="sourceLineNo">1490</span><a id="line.1490">     * as having the given radius, but if that is higher than the maximum possible</a>
<span class="sourceLineNo">1491</span><a id="line.1491">     * radius stored by this FOVCache, it will compute a new FOV map using Shadow</a>
<span class="sourceLineNo">1492</span><a id="line.1492">     * FOV instead of using the cache. A conical section of FOV is lit by this</a>
<span class="sourceLineNo">1493</span><a id="line.1493">     * method if span is greater than 0.</a>
<span class="sourceLineNo">1494</span><a id="line.1494">     *</a>
<span class="sourceLineNo">1495</span><a id="line.1495">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1496</span><a id="line.1496">     * map using Shadow FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1497</span><a id="line.1497">     * be cached.</a>
<span class="sourceLineNo">1498</span><a id="line.1498">     *</a>
<span class="sourceLineNo">1499</span><a id="line.1499">     * @param resistanceMap   the grid of cells to calculate on</a>
<span class="sourceLineNo">1500</span><a id="line.1500">     * @param startX          the horizontal component of the starting location</a>
<span class="sourceLineNo">1501</span><a id="line.1501">     * @param startY          the vertical component of the starting location</a>
<span class="sourceLineNo">1502</span><a id="line.1502">     * @param radius          the distance the light will extend to</a>
<span class="sourceLineNo">1503</span><a id="line.1503">     * @param radiusTechnique provides a means to calculate the radius as desired</a>
<span class="sourceLineNo">1504</span><a id="line.1504">     * @param angle           the angle in degrees that will be the center of the FOV cone, 0 points right</a>
<span class="sourceLineNo">1505</span><a id="line.1505">     * @param span            the angle in degrees that measures the full arc contained in the FOV cone</a>
<span class="sourceLineNo">1506</span><a id="line.1506">     * @return the computed light grid</a>
<span class="sourceLineNo">1507</span><a id="line.1507">     */</a>
<span class="sourceLineNo">1508</span><a id="line.1508">/*    @Override</a>
<span class="sourceLineNo">1509</span><a id="line.1509">    public double[][] calculateFOV(double[][] resistanceMap, int startX, int startY, double radius,</a>
<span class="sourceLineNo">1510</span><a id="line.1510">                                   Radius radiusTechnique, double angle, double span) {</a>
<span class="sourceLineNo">1511</span><a id="line.1511">        if((qualityComplete || complete) &amp;&amp; radius &gt;= 0 &amp;&amp; radius &lt;= maxRadius &amp;&amp;</a>
<span class="sourceLineNo">1512</span><a id="line.1512">                radiusKind.equals2D(radiusTechnique))</a>
<span class="sourceLineNo">1513</span><a id="line.1513">            return unpackDoubleConical(cache[startX + startY * width][maxRadius - (int) Math.round(radius)], width, height,</a>
<span class="sourceLineNo">1514</span><a id="line.1514">                    startX, startY, angle, span);</a>
<span class="sourceLineNo">1515</span><a id="line.1515">        else</a>
<span class="sourceLineNo">1516</span><a id="line.1516">            return fov.calculateFOV(resMap, startX, startY, radius, radiusTechnique, angle, span);</a>
<span class="sourceLineNo">1517</span><a id="line.1517">    }</a>
<span class="sourceLineNo">1518</span><a id="line.1518">*/</a>
<span class="sourceLineNo">1519</span><a id="line.1519">    /**</a>
<span class="sourceLineNo">1520</span><a id="line.1520">     * Calculates the Field Of View for the provided map from the given x, y</a>
<span class="sourceLineNo">1521</span><a id="line.1521">     * coordinates. Returns a light map where the values range from 1.0 (center</a>
<span class="sourceLineNo">1522</span><a id="line.1522">     * of the FOV) to 0.0 (not seen), with values between those two extremes</a>
<span class="sourceLineNo">1523</span><a id="line.1523">     * for the rest of the seen area.</a>
<span class="sourceLineNo">1524</span><a id="line.1524">     * Takes a double radius to extend out to (rounded to the nearest int), and</a>
<span class="sourceLineNo">1525</span><a id="line.1525">     * a double[][] resistance map that will be disregarded.</a>
<span class="sourceLineNo">1526</span><a id="line.1526">     * &lt;br&gt;</a>
<span class="sourceLineNo">1527</span><a id="line.1527">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1528</span><a id="line.1528">     * of the origin cell. Radius determinations are based on the radiusKind given</a>
<span class="sourceLineNo">1529</span><a id="line.1529">     * in construction. The light will be treated as having the given radius, but</a>
<span class="sourceLineNo">1530</span><a id="line.1530">     * if that is higher than the maximum possible radius stored by this FOVCache,</a>
<span class="sourceLineNo">1531</span><a id="line.1531">     * it will compute a new FOV map using Ripple FOV instead of using the cache.</a>
<span class="sourceLineNo">1532</span><a id="line.1532">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1533</span><a id="line.1533">     * map using Ripple FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1534</span><a id="line.1534">     * be cached.</a>
<span class="sourceLineNo">1535</span><a id="line.1535">     *</a>
<span class="sourceLineNo">1536</span><a id="line.1536">     * @param resistanceMap the grid of cells to calculate on</a>
<span class="sourceLineNo">1537</span><a id="line.1537">     * @param startx        the horizontal component of the starting location</a>
<span class="sourceLineNo">1538</span><a id="line.1538">     * @param starty        the vertical component of the starting location</a>
<span class="sourceLineNo">1539</span><a id="line.1539">     * @param radius        the distance the light will extend to</a>
<span class="sourceLineNo">1540</span><a id="line.1540">     * @return the computed light grid</a>
<span class="sourceLineNo">1541</span><a id="line.1541">     */</a>
<span class="sourceLineNo">1542</span><a id="line.1542">    @Override</a>
<span class="sourceLineNo">1543</span><a id="line.1543">        public double[][] calculateFOV(double[][] resistanceMap, int startx, int starty, double radius) {</a>
<span class="sourceLineNo">1544</span><a id="line.1544">        if((qualityComplete || complete) &amp;&amp; radius &gt; 0 &amp;&amp; radius &lt;= maxRadius)</a>
<span class="sourceLineNo">1545</span><a id="line.1545">            return unpackMultiDoublePartial(cache[startx + starty * width], width, height,</a>
<span class="sourceLineNo">1546</span><a id="line.1546">                    levels[(int) Math.round(radius)], (int) Math.round(radius));</a>
<span class="sourceLineNo">1547</span><a id="line.1547">        else</a>
<span class="sourceLineNo">1548</span><a id="line.1548">            return gradedFOV.calculateFOV(resMap, startx, starty, radius, radiusKind);</a>
<span class="sourceLineNo">1549</span><a id="line.1549">    }</a>
<span class="sourceLineNo">1550</span><a id="line.1550"></a>
<span class="sourceLineNo">1551</span><a id="line.1551"></a>
<span class="sourceLineNo">1552</span><a id="line.1552">    /**</a>
<span class="sourceLineNo">1553</span><a id="line.1553">     * Calculates the Field Of View for the provided map from the given x, y</a>
<span class="sourceLineNo">1554</span><a id="line.1554">     * coordinates. Returns a light map where the values range from 1.0 (center</a>
<span class="sourceLineNo">1555</span><a id="line.1555">     * of the FOV) to 0.0 (not seen), with values between those two extremes</a>
<span class="sourceLineNo">1556</span><a id="line.1556">     * for the rest of the seen area.</a>
<span class="sourceLineNo">1557</span><a id="line.1557">     * Takes a double radius to extend out to (rounded to the nearest int), a</a>
<span class="sourceLineNo">1558</span><a id="line.1558">     * Radius enum that should match the Radius this FOVCache was constructed</a>
<span class="sourceLineNo">1559</span><a id="line.1559">     * with, and a double[][] resistance map that will be disregarded.</a>
<span class="sourceLineNo">1560</span><a id="line.1560">     * &lt;br&gt;</a>
<span class="sourceLineNo">1561</span><a id="line.1561">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1562</span><a id="line.1562">     * of the origin cell. Radius determinations are based on the radiusTechnique</a>
<span class="sourceLineNo">1563</span><a id="line.1563">     * passed to this method, but will only use the cache if the Radius given is</a>
<span class="sourceLineNo">1564</span><a id="line.1564">     * the same kind as the one given in construction. The light will be treated</a>
<span class="sourceLineNo">1565</span><a id="line.1565">     * as having the given radius, but if that is higher than the maximum possible</a>
<span class="sourceLineNo">1566</span><a id="line.1566">     * radius stored by this FOVCache, it will compute a new FOV map using Ripple</a>
<span class="sourceLineNo">1567</span><a id="line.1567">     * FOV instead of using the cache.</a>
<span class="sourceLineNo">1568</span><a id="line.1568">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1569</span><a id="line.1569">     * map using Ripple FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1570</span><a id="line.1570">     * be cached.</a>
<span class="sourceLineNo">1571</span><a id="line.1571">     *</a>
<span class="sourceLineNo">1572</span><a id="line.1572">     * @param resistanceMap   the grid of cells to calculate on</a>
<span class="sourceLineNo">1573</span><a id="line.1573">     * @param startX          the horizontal component of the starting location</a>
<span class="sourceLineNo">1574</span><a id="line.1574">     * @param startY          the vertical component of the starting location</a>
<span class="sourceLineNo">1575</span><a id="line.1575">     * @param radius          the distance the light will extend to</a>
<span class="sourceLineNo">1576</span><a id="line.1576">     * @param radiusTechnique provides a means to calculate the radius as desired</a>
<span class="sourceLineNo">1577</span><a id="line.1577">     * @return the computed light grid</a>
<span class="sourceLineNo">1578</span><a id="line.1578">     */</a>
<span class="sourceLineNo">1579</span><a id="line.1579">    @Override</a>
<span class="sourceLineNo">1580</span><a id="line.1580">        public double[][] calculateFOV(double[][] resistanceMap, int startX, int startY, double radius,</a>
<span class="sourceLineNo">1581</span><a id="line.1581">                                   Radius radiusTechnique) {</a>
<span class="sourceLineNo">1582</span><a id="line.1582">        if((qualityComplete || complete) &amp;&amp; radius &gt; 0 &amp;&amp; radius &lt;= maxRadius &amp;&amp;</a>
<span class="sourceLineNo">1583</span><a id="line.1583">                radiusKind.equals2D(radiusTechnique))</a>
<span class="sourceLineNo">1584</span><a id="line.1584">            return unpackMultiDoublePartial(cache[startX + startY * width], width, height,</a>
<span class="sourceLineNo">1585</span><a id="line.1585">                    levels[(int) Math.round(radius)], (int) Math.round(radius));</a>
<span class="sourceLineNo">1586</span><a id="line.1586">        else</a>
<span class="sourceLineNo">1587</span><a id="line.1587">            return gradedFOV.calculateFOV(resMap, startX, startY, radius, radiusTechnique);</a>
<span class="sourceLineNo">1588</span><a id="line.1588">    }</a>
<span class="sourceLineNo">1589</span><a id="line.1589"></a>
<span class="sourceLineNo">1590</span><a id="line.1590">    /**</a>
<span class="sourceLineNo">1591</span><a id="line.1591">     * Calculates the conical Field Of View for the provided map from the given</a>
<span class="sourceLineNo">1592</span><a id="line.1592">     * x, y coordinates. Returns a light map where the values range from 1.0</a>
<span class="sourceLineNo">1593</span><a id="line.1593">     * (center of the FOV) to 0.0 (not seen), with values between those two</a>
<span class="sourceLineNo">1594</span><a id="line.1594">     * extremes for the rest of the seen area.</a>
<span class="sourceLineNo">1595</span><a id="line.1595">     * Takes a double radius to extend out to (rounded to the nearest int), a</a>
<span class="sourceLineNo">1596</span><a id="line.1596">     * Radius enum that should match the Radius this FOVCache was constructed</a>
<span class="sourceLineNo">1597</span><a id="line.1597">     * with, a double[][] resistance map that will be disregarded, an angle to</a>
<span class="sourceLineNo">1598</span><a id="line.1598">     * center the conical FOV on (in degrees), and the total span in degrees</a>
<span class="sourceLineNo">1599</span><a id="line.1599">     * for the FOV to cover.</a>
<span class="sourceLineNo">1600</span><a id="line.1600">     * &lt;br&gt;</a>
<span class="sourceLineNo">1601</span><a id="line.1601">     * The starting point for the calculation is considered to be at the center</a>
<span class="sourceLineNo">1602</span><a id="line.1602">     * of the origin cell. Radius determinations are based on the radiusTechnique</a>
<span class="sourceLineNo">1603</span><a id="line.1603">     * passed to this method, but will only use the cache if the Radius given is</a>
<span class="sourceLineNo">1604</span><a id="line.1604">     * the same kind as the one given in construction. The light will be treated</a>
<span class="sourceLineNo">1605</span><a id="line.1605">     * as having the given radius, but if that is higher than the maximum possible</a>
<span class="sourceLineNo">1606</span><a id="line.1606">     * radius stored by this FOVCache, it will compute a new FOV map using Ripple</a>
<span class="sourceLineNo">1607</span><a id="line.1607">     * FOV instead of using the cache. A conical section of FOV is lit by this</a>
<span class="sourceLineNo">1608</span><a id="line.1608">     * method if span is greater than 0.</a>
<span class="sourceLineNo">1609</span><a id="line.1609">     *</a>
<span class="sourceLineNo">1610</span><a id="line.1610">     * If the cache has not been fully constructed, this will compute a new FOV</a>
<span class="sourceLineNo">1611</span><a id="line.1611">     * map using Ripple FOV instead of using the cache, and the result will not</a>
<span class="sourceLineNo">1612</span><a id="line.1612">     * be cached.</a>
<span class="sourceLineNo">1613</span><a id="line.1613">     *</a>
<span class="sourceLineNo">1614</span><a id="line.1614">     * @param resistanceMap   the grid of cells to calculate on</a>
<span class="sourceLineNo">1615</span><a id="line.1615">     * @param startX          the horizontal component of the starting location</a>
<span class="sourceLineNo">1616</span><a id="line.1616">     * @param startY          the vertical component of the starting location</a>
<span class="sourceLineNo">1617</span><a id="line.1617">     * @param radius          the distance the light will extend to</a>
<span class="sourceLineNo">1618</span><a id="line.1618">     * @param radiusTechnique provides a means to calculate the radius as desired</a>
<span class="sourceLineNo">1619</span><a id="line.1619">     * @param angle           the angle in degrees that will be the center of the FOV cone, 0 points right</a>
<span class="sourceLineNo">1620</span><a id="line.1620">     * @param span            the angle in degrees that measures the full arc contained in the FOV cone</a>
<span class="sourceLineNo">1621</span><a id="line.1621">     * @return the computed light grid</a>
<span class="sourceLineNo">1622</span><a id="line.1622">     */</a>
<span class="sourceLineNo">1623</span><a id="line.1623">    @Override</a>
<span class="sourceLineNo">1624</span><a id="line.1624">        public double[][] calculateFOV(double[][] resistanceMap, int startX, int startY, double radius,</a>
<span class="sourceLineNo">1625</span><a id="line.1625">                                   Radius radiusTechnique, double angle, double span) {</a>
<span class="sourceLineNo">1626</span><a id="line.1626">        if((qualityComplete || complete) &amp;&amp; radius &gt; 0 &amp;&amp; radius &lt;= maxRadius &amp;&amp;</a>
<span class="sourceLineNo">1627</span><a id="line.1627">                radiusKind.equals2D(radiusTechnique))</a>
<span class="sourceLineNo">1628</span><a id="line.1628">            return unpackMultiDoublePartialConical(cache[startX + startY * width], width, height,</a>
<span class="sourceLineNo">1629</span><a id="line.1629">                    levels[(int) Math.round(radius)], (int) Math.round(radius), startX, startY, angle, span);</a>
<span class="sourceLineNo">1630</span><a id="line.1630">        else</a>
<span class="sourceLineNo">1631</span><a id="line.1631">            return gradedFOV.calculateFOV(resMap, startX, startY, radius, radiusTechnique, angle, span);</a>
<span class="sourceLineNo">1632</span><a id="line.1632">    }</a>
<span class="sourceLineNo">1633</span><a id="line.1633"></a>
<span class="sourceLineNo">1634</span><a id="line.1634">    /**</a>
<span class="sourceLineNo">1635</span><a id="line.1635">     * Calculates an array of Coord positions that can be seen along the line from the given start point and end point.</a>
<span class="sourceLineNo">1636</span><a id="line.1636">     * Does not order the array. Uses the pre-computed LOS cache to determine obstacles, and tends to draw a</a>
<span class="sourceLineNo">1637</span><a id="line.1637">     * thicker line than Bresenham lines will. This uses the same radiusKind the FOVCache was created with, but the line</a>
<span class="sourceLineNo">1638</span><a id="line.1638">     * this draws doesn't necessarily travel along valid directions for creatures (in particular, Radius.DIAMOND should</a>
<span class="sourceLineNo">1639</span><a id="line.1639">     * only allow orthogonal movement, but if you request a 45-degree line, the LOS will have Coords on a perfect</a>
<span class="sourceLineNo">1640</span><a id="line.1640">     * diagonal, though they won't travel through walls that occupy a thin perpendicular diagonal).</a>
<span class="sourceLineNo">1641</span><a id="line.1641">     * @param startX the x position of the starting point; must be within bounds of the map</a>
<span class="sourceLineNo">1642</span><a id="line.1642">     * @param startY the y position of the starting point; must be within bounds of the map</a>
<span class="sourceLineNo">1643</span><a id="line.1643">     * @param endX the x position of the endpoint; does not need to be within bounds (will stop LOS at the edge)</a>
<span class="sourceLineNo">1644</span><a id="line.1644">     * @param endY the y position of the endpoint; does not need to be within bounds (will stop LOS at the edge)</a>
<span class="sourceLineNo">1645</span><a id="line.1645">     * @return a Coord[], unordered, that can be seen along the line of sight; limited to maxLOSRadius, default 62</a>
<span class="sourceLineNo">1646</span><a id="line.1646">     */</a>
<span class="sourceLineNo">1647</span><a id="line.1647">    public Coord[] calculateLOS(int startX, int startY, int endX, int endY)</a>
<span class="sourceLineNo">1648</span><a id="line.1648">    {</a>
<span class="sourceLineNo">1649</span><a id="line.1649">        if(!complete || startX &lt; 0 || startX &gt;= width || startY &lt; 0 || startY &gt;= height)</a>
<span class="sourceLineNo">1650</span><a id="line.1650">            return new Coord[0];</a>
<span class="sourceLineNo">1651</span><a id="line.1651">        int max = distance(endX - startX, endY - startY);</a>
<span class="sourceLineNo">1652</span><a id="line.1652">        ArrayList&lt;Coord&gt; path = new ArrayList&lt;&gt;(max / 2 + 1);</a>
<span class="sourceLineNo">1653</span><a id="line.1653">        short[] losCached = losCache[startX + startY * width];</a>
<span class="sourceLineNo">1654</span><a id="line.1654">        if(losCached.length == 0)</a>
<span class="sourceLineNo">1655</span><a id="line.1655">            return new Coord[0];</a>
<span class="sourceLineNo">1656</span><a id="line.1656">        boolean on = false;</a>
<span class="sourceLineNo">1657</span><a id="line.1657">        int idx = 0, xt, yt;</a>
<span class="sourceLineNo">1658</span><a id="line.1658">        short x =0, y = 0;</a>
<span class="sourceLineNo">1659</span><a id="line.1659">        path.add(Coord.get(startX, startY));</a>
<span class="sourceLineNo">1660</span><a id="line.1660">        if(startX == endX &amp;&amp; startY == endY)</a>
<span class="sourceLineNo">1661</span><a id="line.1661">            return path.toArray(new Coord[0]);</a>
<span class="sourceLineNo">1662</span><a id="line.1662"></a>
<span class="sourceLineNo">1663</span><a id="line.1663">        double angle = NumberTools.atan2(endY - startY, endX - startX);</a>
<span class="sourceLineNo">1664</span><a id="line.1664">        double x2 = Math.sin(angle) * 0.5, y2 = Math.cos(angle) * 0.5;</a>
<span class="sourceLineNo">1665</span><a id="line.1665">        boolean[][] mask = new boolean[width][height];</a>
<span class="sourceLineNo">1666</span><a id="line.1666">        for (int d = 2; d &lt;= max; d++) {</a>
<span class="sourceLineNo">1667</span><a id="line.1667">            xt = startX + (int)(x2 * d + 0.5);</a>
<span class="sourceLineNo">1668</span><a id="line.1668">            yt = startY + (int)(y2 * d + 0.5);</a>
<span class="sourceLineNo">1669</span><a id="line.1669">            if(xt &lt; 0 || xt &gt;= width || yt &lt; 0 || yt &gt;= height)</a>
<span class="sourceLineNo">1670</span><a id="line.1670">                break;</a>
<span class="sourceLineNo">1671</span><a id="line.1671">            mask[xt][yt] = true;</a>
<span class="sourceLineNo">1672</span><a id="line.1672">        }</a>
<span class="sourceLineNo">1673</span><a id="line.1673"></a>
<span class="sourceLineNo">1674</span><a id="line.1674">        for(int p = 0; p &lt; losCached.length; p++, on = !on) {</a>
<span class="sourceLineNo">1675</span><a id="line.1675">            if (on) {</a>
<span class="sourceLineNo">1676</span><a id="line.1676">                for (int toSkip = idx +(losCached[p] &amp; 0xffff); idx &lt; toSkip &amp;&amp; idx &lt; limit; idx++) {</a>
<span class="sourceLineNo">1677</span><a id="line.1677">                    x = hilbertX[idx];</a>
<span class="sourceLineNo">1678</span><a id="line.1678">                    y = hilbertY[idx];</a>
<span class="sourceLineNo">1679</span><a id="line.1679">                    // this should never be possible, removing tentatively</a>
<span class="sourceLineNo">1680</span><a id="line.1680">                    //if(x &gt;= width || y &gt;= height)</a>
<span class="sourceLineNo">1681</span><a id="line.1681">                    //    continue;</a>
<span class="sourceLineNo">1682</span><a id="line.1682">                    if(mask[x][y])</a>
<span class="sourceLineNo">1683</span><a id="line.1683">                        path.add(Coord.get(x, y));</a>
<span class="sourceLineNo">1684</span><a id="line.1684">                }</a>
<span class="sourceLineNo">1685</span><a id="line.1685">            } else {</a>
<span class="sourceLineNo">1686</span><a id="line.1686">                idx += losCached[p] &amp; 0xffff;</a>
<span class="sourceLineNo">1687</span><a id="line.1687">            }</a>
<span class="sourceLineNo">1688</span><a id="line.1688">        }</a>
<span class="sourceLineNo">1689</span><a id="line.1689">        return path.toArray(new Coord[0]);</a>
<span class="sourceLineNo">1690</span><a id="line.1690">    }</a>
<span class="sourceLineNo">1691</span><a id="line.1691"></a>
<span class="sourceLineNo">1692</span><a id="line.1692">    /**</a>
<span class="sourceLineNo">1693</span><a id="line.1693">     * Calculates an array of Coord positions that can be seen along the line from the given start point and end point.</a>
<span class="sourceLineNo">1694</span><a id="line.1694">     * Sorts the array, starting from the closest Coord to start and ending close to end. Uses the pre-computed LOS</a>
<span class="sourceLineNo">1695</span><a id="line.1695">     * cache to determine obstacles, and tends to draw a thicker line than Bresenham lines will. This uses the same</a>
<span class="sourceLineNo">1696</span><a id="line.1696">     * radiusKind the FOVCache was created with, but the line this draws doesn't necessarily travel along valid</a>
<span class="sourceLineNo">1697</span><a id="line.1697">     * directions for creatures (in particular, Radius.DIAMOND should only allow orthogonal movement, but if you request</a>
<span class="sourceLineNo">1698</span><a id="line.1698">     * a 45-degree line, the LOS will have Coords on a perfect diagonal, though they won't travel through walls that</a>
<span class="sourceLineNo">1699</span><a id="line.1699">     * occupy a thin perpendicular diagonal).</a>
<span class="sourceLineNo">1700</span><a id="line.1700">     * @param startX the x position of the starting point; must be within bounds of the map</a>
<span class="sourceLineNo">1701</span><a id="line.1701">     * @param startY the y position of the starting point; must be within bounds of the map</a>
<span class="sourceLineNo">1702</span><a id="line.1702">     * @param endX the x position of the endpoint; does not need to be within bounds (will stop LOS at the edge)</a>
<span class="sourceLineNo">1703</span><a id="line.1703">     * @param endY the y position of the endpoint; does not need to be within bounds (will stop LOS at the edge)</a>
<span class="sourceLineNo">1704</span><a id="line.1704">     * @return a Coord[], sorted, that can be seen along the line of sight; limited to max LOS range, 62</a>
<span class="sourceLineNo">1705</span><a id="line.1705">     */</a>
<span class="sourceLineNo">1706</span><a id="line.1706">    public Coord[] sortedLOS(int startX, int startY, int endX, int endY) {</a>
<span class="sourceLineNo">1707</span><a id="line.1707">        Coord[] path = calculateLOS(startX, startY, endX, endY);</a>
<span class="sourceLineNo">1708</span><a id="line.1708">        SortedMap&lt;Double, Coord&gt; sorted = new TreeMap&lt;&gt;();</a>
<span class="sourceLineNo">1709</span><a id="line.1709">        double modifier = 0.0001;</a>
<span class="sourceLineNo">1710</span><a id="line.1710">        Coord c;</a>
<span class="sourceLineNo">1711</span><a id="line.1711">        for (int i = 0; i &lt; path.length; i++, modifier += 0.0001) {</a>
<span class="sourceLineNo">1712</span><a id="line.1712">            c = path[i];</a>
<span class="sourceLineNo">1713</span><a id="line.1713">            sorted.put(distance(c.x, c.y) + modifier, c);</a>
<span class="sourceLineNo">1714</span><a id="line.1714">        }</a>
<span class="sourceLineNo">1715</span><a id="line.1715">        return sorted.values().toArray(new Coord[sorted.size()]);</a>
<span class="sourceLineNo">1716</span><a id="line.1716">    }</a>
<span class="sourceLineNo">1717</span><a id="line.1717">    /**</a>
<span class="sourceLineNo">1718</span><a id="line.1718">     * Given a path as a List of Coords (such as one produced by DijkstraMap.getPath()), this method will look up the</a>
<span class="sourceLineNo">1719</span><a id="line.1719">     * FOV for the given fovRange at each Coord, and returns an array of packed FOV maps where each map is the union</a>
<span class="sourceLineNo">1720</span><a id="line.1720">     * of the FOV centered on a Coord in path with all FOVs centered on previous Coords in path. The purpose of this is</a>
<span class="sourceLineNo">1721</span><a id="line.1721">     * mainly to have an efficient way to show the progressively expanding seen area of a character who moves multiple</a>
<span class="sourceLineNo">1722</span><a id="line.1722">     * tiles. It may be desirable to add the entire path's cumulative FOV (stored in the last element of the returned</a>
<span class="sourceLineNo">1723</span><a id="line.1723">     * short[][]) to the history of what a character has seen, removing the path's FOV from the currently visible cells</a>
<span class="sourceLineNo">1724</span><a id="line.1724">     * either after the character has finished their action, or even immediately after moving if, for instance, the</a>
<span class="sourceLineNo">1725</span><a id="line.1725">     * movement was part of a rapid leap that wouldn't let the character spot details while moving (but the general</a>
<span class="sourceLineNo">1726</span><a id="line.1726">     * layout provided by the seen-cell history could suffice). This method never unpacks any packed data.</a>
<span class="sourceLineNo">1727</span><a id="line.1727">     * @param path a List of Coords that will be added, in order, to multiple packed FOVs for the path so far</a>
<span class="sourceLineNo">1728</span><a id="line.1728">     * @param fovRange the radius the creature or thing taking the path can see (or possibly light up).</a>
<span class="sourceLineNo">1729</span><a id="line.1729">     * @return a packed short[][], each short[] encoding the FOV around an additional Coord merged with those before</a>
<span class="sourceLineNo">1730</span><a id="line.1730">     */</a>
<span class="sourceLineNo">1731</span><a id="line.1731">    public short[][] pathFOVPacked(List&lt;Coord&gt; path, int fovRange)</a>
<span class="sourceLineNo">1732</span><a id="line.1732">    {</a>
<span class="sourceLineNo">1733</span><a id="line.1733">        if(!complete)</a>
<span class="sourceLineNo">1734</span><a id="line.1734">            throw new IllegalStateException("Cache is not yet constructed");</a>
<span class="sourceLineNo">1735</span><a id="line.1735">        if(fovRange &gt; maxRadius)</a>
<span class="sourceLineNo">1736</span><a id="line.1736">            throw new UnsupportedOperationException("Given fovRange parameter exceeds maximum cached range");</a>
<span class="sourceLineNo">1737</span><a id="line.1737">        short[][] fovSteps = new short[path.size()][];</a>
<span class="sourceLineNo">1738</span><a id="line.1738">        int idx = 0;</a>
<span class="sourceLineNo">1739</span><a id="line.1739">        for (Coord c : path)</a>
<span class="sourceLineNo">1740</span><a id="line.1740">        {</a>
<span class="sourceLineNo">1741</span><a id="line.1741">            if(c.x &lt; 0 || c.y &lt; 0 || c.x &gt;= width || c.y &gt;= height)</a>
<span class="sourceLineNo">1742</span><a id="line.1742">                throw new ArrayIndexOutOfBoundsException("Along given path, encountered an invalid Coord: "</a>
<span class="sourceLineNo">1743</span><a id="line.1743">                + c);</a>
<span class="sourceLineNo">1744</span><a id="line.1744">            if(idx == 0)</a>
<span class="sourceLineNo">1745</span><a id="line.1745">            {</a>
<span class="sourceLineNo">1746</span><a id="line.1746">                fovSteps[idx] = cache[c.x + c.y * width][maxRadius - fovRange];</a>
<span class="sourceLineNo">1747</span><a id="line.1747">            }</a>
<span class="sourceLineNo">1748</span><a id="line.1748">            else</a>
<span class="sourceLineNo">1749</span><a id="line.1749">            {</a>
<span class="sourceLineNo">1750</span><a id="line.1750">                fovSteps[idx] = unionPacked(fovSteps[idx - 1], cache[c.x + c.y * width][maxRadius - fovRange]);</a>
<span class="sourceLineNo">1751</span><a id="line.1751">            }</a>
<span class="sourceLineNo">1752</span><a id="line.1752">            idx++;</a>
<span class="sourceLineNo">1753</span><a id="line.1753">        }</a>
<span class="sourceLineNo">1754</span><a id="line.1754">        return fovSteps;</a>
<span class="sourceLineNo">1755</span><a id="line.1755">    }</a>
<span class="sourceLineNo">1756</span><a id="line.1756"></a>
<span class="sourceLineNo">1757</span><a id="line.1757">    /**</a>
<span class="sourceLineNo">1758</span><a id="line.1758">     * Given a path as a List of Coords (such as one produced by DijkstraMap.getPath()), this method will look up the</a>
<span class="sourceLineNo">1759</span><a id="line.1759">     * FOV for the given fovRange at each Coord, and returns an array of full FOV maps where each map is the union</a>
<span class="sourceLineNo">1760</span><a id="line.1760">     * of the FOV centered on a Coord in path with all FOVs centered on previous Coords in path. The purpose of this is</a>
<span class="sourceLineNo">1761</span><a id="line.1761">     * mainly to have a way to show the progressively expanding seen area of a character who moves multiple</a>
<span class="sourceLineNo">1762</span><a id="line.1762">     * tiles. It may be desirable to add the entire path's cumulative FOV (stored in the last element of the returned</a>
<span class="sourceLineNo">1763</span><a id="line.1763">     * double[][][]) to the history of what a character has seen, removing the path's FOV from the currently visible</a>
<span class="sourceLineNo">1764</span><a id="line.1764">     * cells either after the character has finished their action, or even immediately after moving if, for instance,</a>
<span class="sourceLineNo">1765</span><a id="line.1765">     * the movement was part of a rapid leap that wouldn't let the character spot details while moving (but the general</a>
<span class="sourceLineNo">1766</span><a id="line.1766">     * layout provided by the seen-cell history could suffice). This method computes the union of the FOV without</a>
<span class="sourceLineNo">1767</span><a id="line.1767">     * unpacking, but then unpacks each step along the path into a double[][] of 1.0 and 0.0 values.</a>
<span class="sourceLineNo">1768</span><a id="line.1768">     * @param path a List of Coords that will be added, in order, to multiple FOVs for the path so far</a>
<span class="sourceLineNo">1769</span><a id="line.1769">     * @param fovRange the radius the creature or thing taking the path can see (or possibly light up).</a>
<span class="sourceLineNo">1770</span><a id="line.1770">     * @return a packed double[][][]; each double[][] is the FOV around an additional Coord merged with those before</a>
<span class="sourceLineNo">1771</span><a id="line.1771">     */</a>
<span class="sourceLineNo">1772</span><a id="line.1772">    public double[][][] pathFOV(List&lt;Coord&gt; path, int fovRange)</a>
<span class="sourceLineNo">1773</span><a id="line.1773">    {</a>
<span class="sourceLineNo">1774</span><a id="line.1774">        short[][] compressed = pathFOVPacked(path, fovRange);</a>
<span class="sourceLineNo">1775</span><a id="line.1775">        double[][][] fovSteps = new double[compressed.length][][];</a>
<span class="sourceLineNo">1776</span><a id="line.1776">        for (int i = 0; i &lt; compressed.length; i++) {</a>
<span class="sourceLineNo">1777</span><a id="line.1777">            fovSteps[i] = unpackDouble(compressed[i], width, height);</a>
<span class="sourceLineNo">1778</span><a id="line.1778">        }</a>
<span class="sourceLineNo">1779</span><a id="line.1779">        return fovSteps;</a>
<span class="sourceLineNo">1780</span><a id="line.1780">    }</a>
<span class="sourceLineNo">1781</span><a id="line.1781"></a>
<span class="sourceLineNo">1782</span><a id="line.1782">    /**</a>
<span class="sourceLineNo">1783</span><a id="line.1783">     * In games that have multiple characters who should share one FOV map, this method should provide optimal</a>
<span class="sourceLineNo">1784</span><a id="line.1784">     * performance when collecting several cached FOV maps into one packed map. It takes a Map of Coord keys to Integer</a>
<span class="sourceLineNo">1785</span><a id="line.1785">     * values, and since it does not modify its parameter, nor does it need a particular iteration order, it doesn't</a>
<span class="sourceLineNo">1786</span><a id="line.1786">     * perform a defensive copy of the team parameter. Each Coord key should correspond to the position of a character,</a>
<span class="sourceLineNo">1787</span><a id="line.1787">     * and each Integer value should be the FOV range of that character. This returns a short[] as a packed FOV map for</a>
<span class="sourceLineNo">1788</span><a id="line.1788">     * all characters in team as a collective.</a>
<span class="sourceLineNo">1789</span><a id="line.1789">     * @param team a Map of Coord keys for characters' positions to Integer values for the FOV range of each character</a>
<span class="sourceLineNo">1790</span><a id="line.1790">     * @return a packed FOV map that can be used with other packed data using CoordPacker.</a>
<span class="sourceLineNo">1791</span><a id="line.1791">     */</a>
<span class="sourceLineNo">1792</span><a id="line.1792">    public short[] teamFOVPacked(Map&lt;Coord, Integer&gt; team)</a>
<span class="sourceLineNo">1793</span><a id="line.1793">    {</a>
<span class="sourceLineNo">1794</span><a id="line.1794">        if(!complete)</a>
<span class="sourceLineNo">1795</span><a id="line.1795">            throw new IllegalStateException("Cache is not yet constructed");</a>
<span class="sourceLineNo">1796</span><a id="line.1796">        short[] packing = new short[0];</a>
<span class="sourceLineNo">1797</span><a id="line.1797">        int idx = 0;</a>
<span class="sourceLineNo">1798</span><a id="line.1798">        Coord c;</a>
<span class="sourceLineNo">1799</span><a id="line.1799">        int range;</a>
<span class="sourceLineNo">1800</span><a id="line.1800">        for (Map.Entry&lt;Coord, Integer&gt; kv : team.entrySet())</a>
<span class="sourceLineNo">1801</span><a id="line.1801">        {</a>
<span class="sourceLineNo">1802</span><a id="line.1802">            c = kv.getKey();</a>
<span class="sourceLineNo">1803</span><a id="line.1803">            range = kv.getValue();</a>
<span class="sourceLineNo">1804</span><a id="line.1804">            if(c.x &lt; 0 || c.y &lt; 0 || c.x &gt;= width || c.y &gt;= height)</a>
<span class="sourceLineNo">1805</span><a id="line.1805">                throw new ArrayIndexOutOfBoundsException("Among team, encountered an invalid Coord: "</a>
<span class="sourceLineNo">1806</span><a id="line.1806">                        + c);</a>
<span class="sourceLineNo">1807</span><a id="line.1807">            if(idx == 0)</a>
<span class="sourceLineNo">1808</span><a id="line.1808">            {</a>
<span class="sourceLineNo">1809</span><a id="line.1809">                packing = cache[c.x + c.y * width][maxRadius - range];</a>
<span class="sourceLineNo">1810</span><a id="line.1810">            }</a>
<span class="sourceLineNo">1811</span><a id="line.1811">            else</a>
<span class="sourceLineNo">1812</span><a id="line.1812">            {</a>
<span class="sourceLineNo">1813</span><a id="line.1813">                packing = unionPacked(packing, cache[c.x + c.y * width][maxRadius - range]);</a>
<span class="sourceLineNo">1814</span><a id="line.1814">            }</a>
<span class="sourceLineNo">1815</span><a id="line.1815">            idx++;</a>
<span class="sourceLineNo">1816</span><a id="line.1816">        }</a>
<span class="sourceLineNo">1817</span><a id="line.1817">        return packing;</a>
<span class="sourceLineNo">1818</span><a id="line.1818">    }</a>
<span class="sourceLineNo">1819</span><a id="line.1819"></a>
<span class="sourceLineNo">1820</span><a id="line.1820">    /**</a>
<span class="sourceLineNo">1821</span><a id="line.1821">     * In games that have multiple characters who should share one FOV map, this method should provide optimal</a>
<span class="sourceLineNo">1822</span><a id="line.1822">     * performance when collecting several cached FOV maps into one full map. It takes a Map of Coord keys to Integer</a>
<span class="sourceLineNo">1823</span><a id="line.1823">     * values, and since it does not modify its parameter, nor does it need a particular iteration order, it doesn't</a>
<span class="sourceLineNo">1824</span><a id="line.1824">     * perform a defensive copy of the team parameter. Each Coord key should correspond to the position of a character,</a>
<span class="sourceLineNo">1825</span><a id="line.1825">     * and each Integer value should be the FOV range of that character. This returns a double[][] as a full FOV map,</a>
<span class="sourceLineNo">1826</span><a id="line.1826">     * with values of either 1.0 or 0.0, for all characters in team as a collective.</a>
<span class="sourceLineNo">1827</span><a id="line.1827">     * @param team a Map of Coord keys for characters' positions to Integer values for the FOV range of each character</a>
<span class="sourceLineNo">1828</span><a id="line.1828">     * @return a double[][] FOV map with 1.0 and 0.0 as values, combining all characters' FOV maps.</a>
<span class="sourceLineNo">1829</span><a id="line.1829">     */</a>
<span class="sourceLineNo">1830</span><a id="line.1830">    public double[][] teamFOV(Map&lt;Coord, Integer&gt; team)</a>
<span class="sourceLineNo">1831</span><a id="line.1831">    {</a>
<span class="sourceLineNo">1832</span><a id="line.1832">        return unpackDouble(teamFOVPacked(team), width, height);</a>
<span class="sourceLineNo">1833</span><a id="line.1833">    }</a>
<span class="sourceLineNo">1834</span><a id="line.1834"></a>
<span class="sourceLineNo">1835</span><a id="line.1835">    /**</a>
<span class="sourceLineNo">1836</span><a id="line.1836">     * When you have some packed on/off data and want to make sure it does not include walls, you can use this. It does</a>
<span class="sourceLineNo">1837</span><a id="line.1837">     * not need to unpack the given packed short[] to get the subset of it without walls. Of course, this needs the</a>
<span class="sourceLineNo">1838</span><a id="line.1838">     * FOVCache to be</a>
<span class="sourceLineNo">1839</span><a id="line.1839">     * @param packed a short[] produced by some CoordPacker method or obtained by getLOSEntry() or getCacheEntry().</a>
<span class="sourceLineNo">1840</span><a id="line.1840">     * @return another packed array containing only the non-wall "on" cells in packed</a>
<span class="sourceLineNo">1841</span><a id="line.1841">     */</a>
<span class="sourceLineNo">1842</span><a id="line.1842">    public short[] removeWalls(short[] packed)</a>
<span class="sourceLineNo">1843</span><a id="line.1843">    {</a>
<span class="sourceLineNo">1844</span><a id="line.1844">        return differencePacked(packed, wallMap);</a>
<span class="sourceLineNo">1845</span><a id="line.1845">    }</a>
<span class="sourceLineNo">1846</span><a id="line.1846"></a>
<span class="sourceLineNo">1847</span><a id="line.1847">    public int getMaxRadius() {</a>
<span class="sourceLineNo">1848</span><a id="line.1848">        return maxRadius;</a>
<span class="sourceLineNo">1849</span><a id="line.1849">    }</a>
<span class="sourceLineNo">1850</span><a id="line.1850"></a>
<span class="sourceLineNo">1851</span><a id="line.1851">    public Radius getRadiusKind() {</a>
<span class="sourceLineNo">1852</span><a id="line.1852">        return radiusKind;</a>
<span class="sourceLineNo">1853</span><a id="line.1853">    }</a>
<span class="sourceLineNo">1854</span><a id="line.1854"></a>
<span class="sourceLineNo">1855</span><a id="line.1855">    public int getWidth() {</a>
<span class="sourceLineNo">1856</span><a id="line.1856">        return width;</a>
<span class="sourceLineNo">1857</span><a id="line.1857">    }</a>
<span class="sourceLineNo">1858</span><a id="line.1858"></a>
<span class="sourceLineNo">1859</span><a id="line.1859">    public int getHeight() {</a>
<span class="sourceLineNo">1860</span><a id="line.1860">        return height;</a>
<span class="sourceLineNo">1861</span><a id="line.1861">    }</a>
<span class="sourceLineNo">1862</span><a id="line.1862"></a>
<span class="sourceLineNo">1863</span><a id="line.1863">    @GwtIncompatible</a>
<span class="sourceLineNo">1864</span><a id="line.1864">    protected class PerformanceUnit implements Runnable</a>
<span class="sourceLineNo">1865</span><a id="line.1865">    {</a>
<span class="sourceLineNo">1866</span><a id="line.1866"></a>
<span class="sourceLineNo">1867</span><a id="line.1867">        /**</a>
<span class="sourceLineNo">1868</span><a id="line.1868">         * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</a>
<span class="sourceLineNo">1869</span><a id="line.1869">         * to create a thread, starting the thread causes the object's</a>
<span class="sourceLineNo">1870</span><a id="line.1870">         * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</a>
<span class="sourceLineNo">1871</span><a id="line.1871">         * thread.</a>
<span class="sourceLineNo">1872</span><a id="line.1872">         * &lt;p&gt;</a>
<span class="sourceLineNo">1873</span><a id="line.1873">         * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</a>
<span class="sourceLineNo">1874</span><a id="line.1874">         * take any action whatsoever.</a>
<span class="sourceLineNo">1875</span><a id="line.1875">         *</a>
<span class="sourceLineNo">1876</span><a id="line.1876">         * @see Thread#run()</a>
<span class="sourceLineNo">1877</span><a id="line.1877">         */</a>
<span class="sourceLineNo">1878</span><a id="line.1878">        @Override</a>
<span class="sourceLineNo">1879</span><a id="line.1879">        public void run() {</a>
<span class="sourceLineNo">1880</span><a id="line.1880">            ArrayList&lt;ArrayList&lt;LOSUnit&gt;&gt; losUnits = new ArrayList&lt;&gt;(24);</a>
<span class="sourceLineNo">1881</span><a id="line.1881">            ArrayList&lt;ArrayList&lt;FOVUnit&gt;&gt; fovUnits = new ArrayList&lt;&gt;(24);</a>
<span class="sourceLineNo">1882</span><a id="line.1882">            for (int p = 0; p &lt; 24; p++) {</a>
<span class="sourceLineNo">1883</span><a id="line.1883">                losUnits.add(new ArrayList&lt;LOSUnit&gt;(mapLimit / 20));</a>
<span class="sourceLineNo">1884</span><a id="line.1884">                fovUnits.add(new ArrayList&lt;FOVUnit&gt;(mapLimit / 20));</a>
<span class="sourceLineNo">1885</span><a id="line.1885">            }</a>
<span class="sourceLineNo">1886</span><a id="line.1886">            for (int i = 0, p = 0; i &lt; mapLimit; i++, p = (p+1) % 24) {</a>
<span class="sourceLineNo">1887</span><a id="line.1887">                losUnits.get(p).add(new LOSUnit(i));</a>
<span class="sourceLineNo">1888</span><a id="line.1888">                fovUnits.get(p).add(new FOVUnit(i));</a>
<span class="sourceLineNo">1889</span><a id="line.1889">            }</a>
<span class="sourceLineNo">1890</span><a id="line.1890">            //long totalTime = System.currentTimeMillis(), threadTime = 0L;</a>
<span class="sourceLineNo">1891</span><a id="line.1891">            for (int p = 23; p &gt;= 0; p--) {</a>
<span class="sourceLineNo">1892</span><a id="line.1892">                try {</a>
<span class="sourceLineNo">1893</span><a id="line.1893">                    final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(losUnits.get(p));</a>
<span class="sourceLineNo">1894</span><a id="line.1894">                    for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">1895</span><a id="line.1895">                        future.get();</a>
<span class="sourceLineNo">1896</span><a id="line.1896">                        future.cancel(false);</a>
<span class="sourceLineNo">1897</span><a id="line.1897">                        //long t = future.get();</a>
<span class="sourceLineNo">1898</span><a id="line.1898">                        //threadTime += t;</a>
<span class="sourceLineNo">1899</span><a id="line.1899">                        //System.out.println(t);</a>
<span class="sourceLineNo">1900</span><a id="line.1900">                    }</a>
<span class="sourceLineNo">1901</span><a id="line.1901">                } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">1902</span><a id="line.1902">                    e.printStackTrace();</a>
<span class="sourceLineNo">1903</span><a id="line.1903">                }</a>
<span class="sourceLineNo">1904</span><a id="line.1904">                losUnits.remove(p);</a>
<span class="sourceLineNo">1905</span><a id="line.1905">            }</a>
<span class="sourceLineNo">1906</span><a id="line.1906">            for (int p = 23; p &gt;= 0; p--) {</a>
<span class="sourceLineNo">1907</span><a id="line.1907">                try {</a>
<span class="sourceLineNo">1908</span><a id="line.1908">                    final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(fovUnits.get(p));</a>
<span class="sourceLineNo">1909</span><a id="line.1909">                    for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">1910</span><a id="line.1910">                        future.get();</a>
<span class="sourceLineNo">1911</span><a id="line.1911">                        future.cancel(false);</a>
<span class="sourceLineNo">1912</span><a id="line.1912">                        //long t = future.get();</a>
<span class="sourceLineNo">1913</span><a id="line.1913">                        //threadTime += t;</a>
<span class="sourceLineNo">1914</span><a id="line.1914">                        //System.out.println(t);</a>
<span class="sourceLineNo">1915</span><a id="line.1915">                    }</a>
<span class="sourceLineNo">1916</span><a id="line.1916">                } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">1917</span><a id="line.1917">                    e.printStackTrace();</a>
<span class="sourceLineNo">1918</span><a id="line.1918">                }</a>
<span class="sourceLineNo">1919</span><a id="line.1919">                fovUnits.remove(p);</a>
<span class="sourceLineNo">1920</span><a id="line.1920">            }</a>
<span class="sourceLineNo">1921</span><a id="line.1921">            //totalTime = System.currentTimeMillis() - totalTime;</a>
<span class="sourceLineNo">1922</span><a id="line.1922">            //System.out.println("Total real time elapsed: " + totalTime);</a>
<span class="sourceLineNo">1923</span><a id="line.1923">            //System.out.println("Total CPU time elapsed, on " + NUM_THREADS + " threads: " + threadTime);</a>
<span class="sourceLineNo">1924</span><a id="line.1924">        /*</a>
<span class="sourceLineNo">1925</span><a id="line.1925">        long totalRAM = 0;</a>
<span class="sourceLineNo">1926</span><a id="line.1926">        for (int c = 0; c &lt; width * height; c++) {</a>
<span class="sourceLineNo">1927</span><a id="line.1927">            long ctr = 0, losCtr = 0;</a>
<span class="sourceLineNo">1928</span><a id="line.1928">            for (int i = 0; i &lt; cache[c].length; i++) {</a>
<span class="sourceLineNo">1929</span><a id="line.1929">                ctr += (((2 * cache[c][i].length + 12 - 1) / 8) + 1) * 8L;</a>
<span class="sourceLineNo">1930</span><a id="line.1930">            }</a>
<span class="sourceLineNo">1931</span><a id="line.1931">            totalRAM += (((ctr + 12 - 1) / 8) + 1) * 8;</a>
<span class="sourceLineNo">1932</span><a id="line.1932"></a>
<span class="sourceLineNo">1933</span><a id="line.1933">            losCtr = (((2 * losCache[c].length + 12 - 1) / 8) + 1) * 8L;</a>
<span class="sourceLineNo">1934</span><a id="line.1934">            totalRAM += (((losCtr + 12 - 1) / 8) + 1) * 8;</a>
<span class="sourceLineNo">1935</span><a id="line.1935">        }</a>
<span class="sourceLineNo">1936</span><a id="line.1936">        System.out.println("Total memory used by cache: " + totalRAM);</a>
<span class="sourceLineNo">1937</span><a id="line.1937">        */</a>
<span class="sourceLineNo">1938</span><a id="line.1938">            complete = true;</a>
<span class="sourceLineNo">1939</span><a id="line.1939"></a>
<span class="sourceLineNo">1940</span><a id="line.1940">        }</a>
<span class="sourceLineNo">1941</span><a id="line.1941">    }</a>
<span class="sourceLineNo">1942</span><a id="line.1942"></a>
<span class="sourceLineNo">1943</span><a id="line.1943">    @GwtIncompatible</a>
<span class="sourceLineNo">1944</span><a id="line.1944">    protected class QualityUnit implements Runnable</a>
<span class="sourceLineNo">1945</span><a id="line.1945">    {</a>
<span class="sourceLineNo">1946</span><a id="line.1946"></a>
<span class="sourceLineNo">1947</span><a id="line.1947">        /**</a>
<span class="sourceLineNo">1948</span><a id="line.1948">         * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</a>
<span class="sourceLineNo">1949</span><a id="line.1949">         * to create a thread, starting the thread causes the object's</a>
<span class="sourceLineNo">1950</span><a id="line.1950">         * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</a>
<span class="sourceLineNo">1951</span><a id="line.1951">         * thread.</a>
<span class="sourceLineNo">1952</span><a id="line.1952">         * &lt;p&gt;</a>
<span class="sourceLineNo">1953</span><a id="line.1953">         * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</a>
<span class="sourceLineNo">1954</span><a id="line.1954">         * take any action whatsoever.</a>
<span class="sourceLineNo">1955</span><a id="line.1955">         *</a>
<span class="sourceLineNo">1956</span><a id="line.1956">         * @see Thread#run()</a>
<span class="sourceLineNo">1957</span><a id="line.1957">         */</a>
<span class="sourceLineNo">1958</span><a id="line.1958">        @Override</a>
<span class="sourceLineNo">1959</span><a id="line.1959">        public void run() {</a>
<span class="sourceLineNo">1960</span><a id="line.1960">            //long totalTime = System.currentTimeMillis(), threadTime = 0L;</a>
<span class="sourceLineNo">1961</span><a id="line.1961">            ArrayList&lt;ArrayList&lt;SymmetryUnit&gt;&gt; symUnits = new ArrayList&lt;&gt;(4);</a>
<span class="sourceLineNo">1962</span><a id="line.1962">            for (int p = 0; p &lt; 4; p++) {</a>
<span class="sourceLineNo">1963</span><a id="line.1963">                symUnits.add(new ArrayList&lt;SymmetryUnit&gt;(mapLimit / 3));</a>
<span class="sourceLineNo">1964</span><a id="line.1964">            }</a>
<span class="sourceLineNo">1965</span><a id="line.1965">            for (int i = 0, p = 0; i &lt; mapLimit; i++, p = (p+1) % 4) {</a>
<span class="sourceLineNo">1966</span><a id="line.1966">                symUnits.get(p).add(new SymmetryUnit(i));</a>
<span class="sourceLineNo">1967</span><a id="line.1967">            }</a>
<span class="sourceLineNo">1968</span><a id="line.1968"></a>
<span class="sourceLineNo">1969</span><a id="line.1969">            for (int p = 3; p &gt;= 0; p--) {</a>
<span class="sourceLineNo">1970</span><a id="line.1970">                try {</a>
<span class="sourceLineNo">1971</span><a id="line.1971">                    final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(symUnits.get(p));</a>
<span class="sourceLineNo">1972</span><a id="line.1972">                    for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">1973</span><a id="line.1973">                        //threadTime +=</a>
<span class="sourceLineNo">1974</span><a id="line.1974">                        future.get();</a>
<span class="sourceLineNo">1975</span><a id="line.1975">                        future.cancel(false);</a>
<span class="sourceLineNo">1976</span><a id="line.1976">                        //System.out.println(t);</a>
<span class="sourceLineNo">1977</span><a id="line.1977">                    }</a>
<span class="sourceLineNo">1978</span><a id="line.1978">                } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">1979</span><a id="line.1979">                    e.printStackTrace();</a>
<span class="sourceLineNo">1980</span><a id="line.1980">                }</a>
<span class="sourceLineNo">1981</span><a id="line.1981">                symUnits.remove(p);</a>
<span class="sourceLineNo">1982</span><a id="line.1982">            }</a>
<span class="sourceLineNo">1983</span><a id="line.1983">            cache = tmpCache;</a>
<span class="sourceLineNo">1984</span><a id="line.1984">            qualityComplete = true;</a>
<span class="sourceLineNo">1985</span><a id="line.1985">            /*</a>
<span class="sourceLineNo">1986</span><a id="line.1986">            totalTime = System.currentTimeMillis() - totalTime;</a>
<span class="sourceLineNo">1987</span><a id="line.1987">            System.out.println("Total real time elapsed : " + totalTime);</a>
<span class="sourceLineNo">1988</span><a id="line.1988">            System.out.println("Total CPU time elapsed, on " + NUM_THREADS + " threads: " + threadTime);</a>
<span class="sourceLineNo">1989</span><a id="line.1989"></a>
<span class="sourceLineNo">1990</span><a id="line.1990">            long totalRAM = 0;</a>
<span class="sourceLineNo">1991</span><a id="line.1991">            for (int c = 0; c &lt; width * height; c++) {</a>
<span class="sourceLineNo">1992</span><a id="line.1992">                long ctr = 0, losCtr = 0;</a>
<span class="sourceLineNo">1993</span><a id="line.1993">                for (int i = 0; i &lt; cache[c].length; i++) {</a>
<span class="sourceLineNo">1994</span><a id="line.1994">                    ctr += (((2 * cache[c][i].length + 12 - 1) / 8) + 1) * 8L;</a>
<span class="sourceLineNo">1995</span><a id="line.1995">                }</a>
<span class="sourceLineNo">1996</span><a id="line.1996">                totalRAM += (((ctr + 12 - 1) / 8) + 1) * 8;</a>
<span class="sourceLineNo">1997</span><a id="line.1997"></a>
<span class="sourceLineNo">1998</span><a id="line.1998">                losCtr = (((2 * losCache[c].length + 12 - 1) / 8) + 1) * 8L;</a>
<span class="sourceLineNo">1999</span><a id="line.1999">                totalRAM += (((losCtr + 12 - 1) / 8) + 1) * 8;</a>
<span class="sourceLineNo">2000</span><a id="line.2000">            }</a>
<span class="sourceLineNo">2001</span><a id="line.2001">            System.out.println("Total memory used by cache: " + totalRAM);</a>
<span class="sourceLineNo">2002</span><a id="line.2002"></a>
<span class="sourceLineNo">2003</span><a id="line.2003">            System.out.println("FOV Map stored for every cell, booleans or bytes, "+width+"x"+height+": " +</a>
<span class="sourceLineNo">2004</span><a id="line.2004">                    ((((((((((((height + 12 - 1) / 8) + 1) * 8L * width + 12 - 1) / 8) + 1) * 8L</a>
<span class="sourceLineNo">2005</span><a id="line.2005">                            * height + 12 - 1) / 8) + 1) * 8L * width + 12 - 1) / 8) + 1) * 8L);</a>
<span class="sourceLineNo">2006</span><a id="line.2006">            */</a>
<span class="sourceLineNo">2007</span><a id="line.2007">        }</a>
<span class="sourceLineNo">2008</span><a id="line.2008">    }</a>
<span class="sourceLineNo">2009</span><a id="line.2009"></a>
<span class="sourceLineNo">2010</span><a id="line.2010">    @GwtIncompatible</a>
<span class="sourceLineNo">2011</span><a id="line.2011">    protected class RefreshUnit implements Runnable</a>
<span class="sourceLineNo">2012</span><a id="line.2012">    {</a>
<span class="sourceLineNo">2013</span><a id="line.2013">        protected double[][] res;</a>
<span class="sourceLineNo">2014</span><a id="line.2014">        protected RefreshUnit(char[][] newMap)</a>
<span class="sourceLineNo">2015</span><a id="line.2015">        {</a>
<span class="sourceLineNo">2016</span><a id="line.2016">            res = DungeonUtility.generateResistances(newMap);</a>
<span class="sourceLineNo">2017</span><a id="line.2017"></a>
<span class="sourceLineNo">2018</span><a id="line.2018">        }</a>
<span class="sourceLineNo">2019</span><a id="line.2019"></a>
<span class="sourceLineNo">2020</span><a id="line.2020">        /**</a>
<span class="sourceLineNo">2021</span><a id="line.2021">         * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</a>
<span class="sourceLineNo">2022</span><a id="line.2022">         * to create a thread, starting the thread causes the object's</a>
<span class="sourceLineNo">2023</span><a id="line.2023">         * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</a>
<span class="sourceLineNo">2024</span><a id="line.2024">         * thread.</a>
<span class="sourceLineNo">2025</span><a id="line.2025">         * &lt;p&gt;</a>
<span class="sourceLineNo">2026</span><a id="line.2026">         * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</a>
<span class="sourceLineNo">2027</span><a id="line.2027">         * take any action whatsoever.</a>
<span class="sourceLineNo">2028</span><a id="line.2028">         *</a>
<span class="sourceLineNo">2029</span><a id="line.2029">         * @see Thread#run()</a>
<span class="sourceLineNo">2030</span><a id="line.2030">         */</a>
<span class="sourceLineNo">2031</span><a id="line.2031">        @Override</a>
<span class="sourceLineNo">2032</span><a id="line.2032">        public void run() {</a>
<span class="sourceLineNo">2033</span><a id="line.2033">            System.arraycopy(cache, 0, tmpCache, 0, tmpCache.length);</a>
<span class="sourceLineNo">2034</span><a id="line.2034">            short[] needsChange = new short[0];</a>
<span class="sourceLineNo">2035</span><a id="line.2035">            for (int i = 0; i &lt; width; i++) {</a>
<span class="sourceLineNo">2036</span><a id="line.2036">                for (int j = 0; j &lt; height; j++) {</a>
<span class="sourceLineNo">2037</span><a id="line.2037">                    if(resMap[i][j] != res[i][j])</a>
<span class="sourceLineNo">2038</span><a id="line.2038">                    {</a>
<span class="sourceLineNo">2039</span><a id="line.2039">                        needsChange = unionPacked(needsChange, losCache[i + j * width]);</a>
<span class="sourceLineNo">2040</span><a id="line.2040">                    }</a>
<span class="sourceLineNo">2041</span><a id="line.2041">                }</a>
<span class="sourceLineNo">2042</span><a id="line.2042">            }</a>
<span class="sourceLineNo">2043</span><a id="line.2043">            needsChange = differencePacked(needsChange, wallMap);</a>
<span class="sourceLineNo">2044</span><a id="line.2044">            resMap = res;</a>
<span class="sourceLineNo">2045</span><a id="line.2045">            Coord[] changingCoords = allPacked(needsChange);</a>
<span class="sourceLineNo">2046</span><a id="line.2046">            List&lt;LOSUnit&gt; losUnits = new ArrayList&lt;&gt;(changingCoords.length);</a>
<span class="sourceLineNo">2047</span><a id="line.2047">            List&lt;FOVUnit&gt; fovUnits = new ArrayList&lt;&gt;(changingCoords.length);</a>
<span class="sourceLineNo">2048</span><a id="line.2048">            List&lt;SymmetryUnit&gt; symUnits = new ArrayList&lt;&gt;(changingCoords.length);</a>
<span class="sourceLineNo">2049</span><a id="line.2049"></a>
<span class="sourceLineNo">2050</span><a id="line.2050">            for (int i = 0, idx; i &lt; changingCoords.length; i++)</a>
<span class="sourceLineNo">2051</span><a id="line.2051">            {</a>
<span class="sourceLineNo">2052</span><a id="line.2052">                idx = changingCoords[i].x + changingCoords[i].y * width;</a>
<span class="sourceLineNo">2053</span><a id="line.2053">                losUnits.add(new LOSUnit(idx));</a>
<span class="sourceLineNo">2054</span><a id="line.2054">                fovUnits.add(new FOVUnit(idx));</a>
<span class="sourceLineNo">2055</span><a id="line.2055">                symUnits.add(new SymmetryUnit(idx));</a>
<span class="sourceLineNo">2056</span><a id="line.2056">            }</a>
<span class="sourceLineNo">2057</span><a id="line.2057"></a>
<span class="sourceLineNo">2058</span><a id="line.2058">            try {</a>
<span class="sourceLineNo">2059</span><a id="line.2059">                final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(losUnits);</a>
<span class="sourceLineNo">2060</span><a id="line.2060">                for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">2061</span><a id="line.2061">                    //threadTime +=</a>
<span class="sourceLineNo">2062</span><a id="line.2062">                    future.get();</a>
<span class="sourceLineNo">2063</span><a id="line.2063">                    future.cancel(false);</a>
<span class="sourceLineNo">2064</span><a id="line.2064">                    //System.out.println(t);</a>
<span class="sourceLineNo">2065</span><a id="line.2065">                }</a>
<span class="sourceLineNo">2066</span><a id="line.2066">            } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">2067</span><a id="line.2067">                e.printStackTrace();</a>
<span class="sourceLineNo">2068</span><a id="line.2068">            }</a>
<span class="sourceLineNo">2069</span><a id="line.2069">            try {</a>
<span class="sourceLineNo">2070</span><a id="line.2070">                final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(fovUnits);</a>
<span class="sourceLineNo">2071</span><a id="line.2071">                for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">2072</span><a id="line.2072">                    //threadTime +=</a>
<span class="sourceLineNo">2073</span><a id="line.2073">                    future.get();</a>
<span class="sourceLineNo">2074</span><a id="line.2074">                    future.cancel(false);</a>
<span class="sourceLineNo">2075</span><a id="line.2075">                    //System.out.println(t);</a>
<span class="sourceLineNo">2076</span><a id="line.2076">                }</a>
<span class="sourceLineNo">2077</span><a id="line.2077">            } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">2078</span><a id="line.2078">                e.printStackTrace();</a>
<span class="sourceLineNo">2079</span><a id="line.2079">            }</a>
<span class="sourceLineNo">2080</span><a id="line.2080">            try {</a>
<span class="sourceLineNo">2081</span><a id="line.2081">                final List&lt;Future&lt;Long&gt;&gt; invoke = executor.invokeAll(symUnits);</a>
<span class="sourceLineNo">2082</span><a id="line.2082">                for (Future&lt;Long&gt; future : invoke) {</a>
<span class="sourceLineNo">2083</span><a id="line.2083">                    //threadTime +=</a>
<span class="sourceLineNo">2084</span><a id="line.2084">                    future.get();</a>
<span class="sourceLineNo">2085</span><a id="line.2085">                    future.cancel(false);</a>
<span class="sourceLineNo">2086</span><a id="line.2086">                    //System.out.println(t);</a>
<span class="sourceLineNo">2087</span><a id="line.2087">                }</a>
<span class="sourceLineNo">2088</span><a id="line.2088">            } catch (InterruptedException | ExecutionException e) {</a>
<span class="sourceLineNo">2089</span><a id="line.2089">                e.printStackTrace();</a>
<span class="sourceLineNo">2090</span><a id="line.2090">            }</a>
<span class="sourceLineNo">2091</span><a id="line.2091">            cache = tmpCache;</a>
<span class="sourceLineNo">2092</span><a id="line.2092">            refreshComplete = true;</a>
<span class="sourceLineNo">2093</span><a id="line.2093">        }</a>
<span class="sourceLineNo">2094</span><a id="line.2094">    }</a>
<span class="sourceLineNo">2095</span><a id="line.2095"></a>
<span class="sourceLineNo">2096</span><a id="line.2096">    @GwtIncompatible</a>
<span class="sourceLineNo">2097</span><a id="line.2097">    protected class FOVUnit implements Callable&lt;Long&gt;</a>
<span class="sourceLineNo">2098</span><a id="line.2098">    {</a>
<span class="sourceLineNo">2099</span><a id="line.2099">        protected int index;</a>
<span class="sourceLineNo">2100</span><a id="line.2100">        public FOVUnit(int index)</a>
<span class="sourceLineNo">2101</span><a id="line.2101">        {</a>
<span class="sourceLineNo">2102</span><a id="line.2102">            this.index = index;</a>
<span class="sourceLineNo">2103</span><a id="line.2103">        }</a>
<span class="sourceLineNo">2104</span><a id="line.2104"></a>
<span class="sourceLineNo">2105</span><a id="line.2105">        /**</a>
<span class="sourceLineNo">2106</span><a id="line.2106">         * Computes a result, or throws an exception if unable to do so.</a>
<span class="sourceLineNo">2107</span><a id="line.2107">         *</a>
<span class="sourceLineNo">2108</span><a id="line.2108">         * @return computed result</a>
<span class="sourceLineNo">2109</span><a id="line.2109">         * @throws Exception if unable to compute a result</a>
<span class="sourceLineNo">2110</span><a id="line.2110">         */</a>
<span class="sourceLineNo">2111</span><a id="line.2111">        @Override</a>
<span class="sourceLineNo">2112</span><a id="line.2112">        public Long call() throws Exception {</a>
<span class="sourceLineNo">2113</span><a id="line.2113">            return storeCellFOV(index);</a>
<span class="sourceLineNo">2114</span><a id="line.2114">        }</a>
<span class="sourceLineNo">2115</span><a id="line.2115">    }</a>
<span class="sourceLineNo">2116</span><a id="line.2116"></a>
<span class="sourceLineNo">2117</span><a id="line.2117">    @GwtIncompatible</a>
<span class="sourceLineNo">2118</span><a id="line.2118">    protected class LOSUnit implements Callable&lt;Long&gt;</a>
<span class="sourceLineNo">2119</span><a id="line.2119">    {</a>
<span class="sourceLineNo">2120</span><a id="line.2120">        protected int index;</a>
<span class="sourceLineNo">2121</span><a id="line.2121">        public LOSUnit(int index)</a>
<span class="sourceLineNo">2122</span><a id="line.2122">        {</a>
<span class="sourceLineNo">2123</span><a id="line.2123">            this.index = index;</a>
<span class="sourceLineNo">2124</span><a id="line.2124">        }</a>
<span class="sourceLineNo">2125</span><a id="line.2125"></a>
<span class="sourceLineNo">2126</span><a id="line.2126">        /**</a>
<span class="sourceLineNo">2127</span><a id="line.2127">         * Computes a result, or throws an exception if unable to do so.</a>
<span class="sourceLineNo">2128</span><a id="line.2128">         *</a>
<span class="sourceLineNo">2129</span><a id="line.2129">         * @return computed result</a>
<span class="sourceLineNo">2130</span><a id="line.2130">         * @throws Exception if unable to compute a result</a>
<span class="sourceLineNo">2131</span><a id="line.2131">         */</a>
<span class="sourceLineNo">2132</span><a id="line.2132">        @Override</a>
<span class="sourceLineNo">2133</span><a id="line.2133">        public Long call() throws Exception {</a>
<span class="sourceLineNo">2134</span><a id="line.2134">            return storeCellLOS(index);</a>
<span class="sourceLineNo">2135</span><a id="line.2135">        }</a>
<span class="sourceLineNo">2136</span><a id="line.2136">    }</a>
<span class="sourceLineNo">2137</span><a id="line.2137"></a>
<span class="sourceLineNo">2138</span><a id="line.2138">    @GwtIncompatible</a>
<span class="sourceLineNo">2139</span><a id="line.2139">    protected class SymmetryUnit implements Callable&lt;Long&gt;</a>
<span class="sourceLineNo">2140</span><a id="line.2140">    {</a>
<span class="sourceLineNo">2141</span><a id="line.2141">        protected int index;</a>
<span class="sourceLineNo">2142</span><a id="line.2142">        public SymmetryUnit(int index)</a>
<span class="sourceLineNo">2143</span><a id="line.2143">        {</a>
<span class="sourceLineNo">2144</span><a id="line.2144">            this.index = index;</a>
<span class="sourceLineNo">2145</span><a id="line.2145">        }</a>
<span class="sourceLineNo">2146</span><a id="line.2146"></a>
<span class="sourceLineNo">2147</span><a id="line.2147">        /**</a>
<span class="sourceLineNo">2148</span><a id="line.2148">         * Computes a result, or throws an exception if unable to do so.</a>
<span class="sourceLineNo">2149</span><a id="line.2149">         *</a>
<span class="sourceLineNo">2150</span><a id="line.2150">         * @return computed result</a>
<span class="sourceLineNo">2151</span><a id="line.2151">         * @throws Exception if unable to compute a result</a>
<span class="sourceLineNo">2152</span><a id="line.2152">         */</a>
<span class="sourceLineNo">2153</span><a id="line.2153">        @Override</a>
<span class="sourceLineNo">2154</span><a id="line.2154">        public Long call() throws Exception {</a>
<span class="sourceLineNo">2155</span><a id="line.2155">            return storeCellSymmetry(index);</a>
<span class="sourceLineNo">2156</span><a id="line.2156">        }</a>
<span class="sourceLineNo">2157</span><a id="line.2157">    }</a>
<span class="sourceLineNo">2158</span><a id="line.2158"></a>
<span class="sourceLineNo">2159</span><a id="line.2159">    /**</a>
<span class="sourceLineNo">2160</span><a id="line.2160">     * Shuts down any threads that may prevent the game from closing properly.</a>
<span class="sourceLineNo">2161</span><a id="line.2161">     * It is recommended you call this at the end of the program to avoid threads lingering too long.</a>
<span class="sourceLineNo">2162</span><a id="line.2162">     * You don't have to do anything special after you call this, other than not using this FOVCache any more.</a>
<span class="sourceLineNo">2163</span><a id="line.2163">     */</a>
<span class="sourceLineNo">2164</span><a id="line.2164">    public void destroy()</a>
<span class="sourceLineNo">2165</span><a id="line.2165">    {</a>
<span class="sourceLineNo">2166</span><a id="line.2166">        performanceThread.interrupt();</a>
<span class="sourceLineNo">2167</span><a id="line.2167">        qualityThread.interrupt();</a>
<span class="sourceLineNo">2168</span><a id="line.2168">        executor.shutdown();</a>
<span class="sourceLineNo">2169</span><a id="line.2169">    }</a>
<span class="sourceLineNo">2170</span><a id="line.2170">}</a>




























































</pre>
</div>
</main>
</body>
</html>
