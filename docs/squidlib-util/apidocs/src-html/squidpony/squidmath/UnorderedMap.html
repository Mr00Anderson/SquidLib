<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/*<a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (C) 2002-2015 Sebastiano Vigna<a name="line.2"></a>
<span class="sourceLineNo">003</span> *<a name="line.3"></a>
<span class="sourceLineNo">004</span> * Licensed under the Apache License, Version 2.0 (the "License");<a name="line.4"></a>
<span class="sourceLineNo">005</span> * you may not use this file except in compliance with the License.<a name="line.5"></a>
<span class="sourceLineNo">006</span> * You may obtain a copy of the License at<a name="line.6"></a>
<span class="sourceLineNo">007</span> *<a name="line.7"></a>
<span class="sourceLineNo">008</span> *     http://www.apache.org/licenses/LICENSE-2.0<a name="line.8"></a>
<span class="sourceLineNo">009</span> *<a name="line.9"></a>
<span class="sourceLineNo">010</span> * Unless required by applicable law or agreed to in writing, software<a name="line.10"></a>
<span class="sourceLineNo">011</span> * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.11"></a>
<span class="sourceLineNo">012</span> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.12"></a>
<span class="sourceLineNo">013</span> * See the License for the specific language governing permissions and<a name="line.13"></a>
<span class="sourceLineNo">014</span> * limitations under the License. <a name="line.14"></a>
<span class="sourceLineNo">015</span> */<a name="line.15"></a>
<span class="sourceLineNo">016</span>package squidpony.squidmath;<a name="line.16"></a>
<span class="sourceLineNo">017</span><a name="line.17"></a>
<span class="sourceLineNo">018</span>import squidpony.annotation.GwtIncompatible;<a name="line.18"></a>
<span class="sourceLineNo">019</span><a name="line.19"></a>
<span class="sourceLineNo">020</span>import java.io.Serializable;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import java.util.*;<a name="line.21"></a>
<span class="sourceLineNo">022</span><a name="line.22"></a>
<span class="sourceLineNo">023</span>/**<a name="line.23"></a>
<span class="sourceLineNo">024</span> * A generic unordered hash map with with a fast implementation, originally from fastutil as<a name="line.24"></a>
<span class="sourceLineNo">025</span> * Object2ObjectOpenCustomHashMap but modified to support SquidLib's {@link squidpony.squidmath.CrossHash.IHasher}<a name="line.25"></a>
<span class="sourceLineNo">026</span> * interface for custom hashing instead of fastutil's Strategy interface.<a name="line.26"></a>
<span class="sourceLineNo">027</span> * &lt;br&gt;<a name="line.27"></a>
<span class="sourceLineNo">028</span> * Instances of this class use a hash table to represent a map. The table is filled up to a specified &lt;em&gt;load factor&lt;/em&gt;, and then doubled in size to accommodate new entries. If the table is<a name="line.28"></a>
<span class="sourceLineNo">029</span> * emptied below &lt;em&gt;one fourth&lt;/em&gt; of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration<a name="line.29"></a>
<span class="sourceLineNo">030</span> * process.<a name="line.30"></a>
<span class="sourceLineNo">031</span> * &lt;br&gt;<a name="line.31"></a>
<span class="sourceLineNo">032</span> * Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if<a name="line.32"></a>
<span class="sourceLineNo">033</span> * you reuse instances of this class.<a name="line.33"></a>
<span class="sourceLineNo">034</span> * &lt;br&gt;<a name="line.34"></a>
<span class="sourceLineNo">035</span> * You can pass a {@link CrossHash.IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to<a name="line.35"></a>
<span class="sourceLineNo">036</span> * most of this class' constructors, which allows the OrderedMap to use arrays (usually primitive arrays) as keys. If<a name="line.36"></a>
<span class="sourceLineNo">037</span> * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or<a name="line.37"></a>
<span class="sourceLineNo">038</span> * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).<a name="line.38"></a>
<span class="sourceLineNo">039</span> * If you aren't using arrays as keys, you don't need to give an IHasher to the constructor and can ignore this feature<a name="line.39"></a>
<span class="sourceLineNo">040</span> * most of the time. However, the default IHasher this uses if none is specified performs a small but significant<a name="line.40"></a>
<span class="sourceLineNo">041</span> * "mixing" step to make the default generated hashCode() implementation many classes use into a higher-quality<a name="line.41"></a>
<span class="sourceLineNo">042</span> * random-like value. This isn't always optimal; if you plan to insert 1000 sequential Integer keys with some small<a name="line.42"></a>
<span class="sourceLineNo">043</span> * amount of random Integers after them, then the mixing actually increases the likelihood of a collision and takes time<a name="line.43"></a>
<span class="sourceLineNo">044</span> * to calculate. You could use a very simple IHasher in that case, relying on the fact that only Integers will be added:<a name="line.44"></a>
<span class="sourceLineNo">045</span> * &lt;pre&gt;<a name="line.45"></a>
<span class="sourceLineNo">046</span> * new CrossHash.IHasher() {<a name="line.46"></a>
<span class="sourceLineNo">047</span> *     public int hash(Object data) { return (int)data; }<a name="line.47"></a>
<span class="sourceLineNo">048</span> *     public boolean areEqual(Object left, Object right) { return Objects.equals(left, right); }<a name="line.48"></a>
<span class="sourceLineNo">049</span> * };<a name="line.49"></a>
<span class="sourceLineNo">050</span> * &lt;/pre&gt;<a name="line.50"></a>
<span class="sourceLineNo">051</span> * This is just one example of a case where a custom IHasher can be useful for performance reasons; there are also cases<a name="line.51"></a>
<span class="sourceLineNo">052</span> * where an IHasher is needed to enforce hashing by identity or by value, which affect program logic. Note that the<a name="line.52"></a>
<span class="sourceLineNo">053</span> * given IHasher is likely to be sub-optimal for many situations with Integer keys, and you may want to try a few<a name="line.53"></a>
<span class="sourceLineNo">054</span> * different approaches if you know OrderedMap is a bottleneck in your application. If the IHasher is a performance<a name="line.54"></a>
<span class="sourceLineNo">055</span> * problem, it will be at its worst if the OrderedMap needs to resize, and thus rehash, many times; this won't happen if<a name="line.55"></a>
<span class="sourceLineNo">056</span> * the capacity is set correctly when the OrderedMap is created (with the capacity equal to or greater than the maximum<a name="line.56"></a>
<span class="sourceLineNo">057</span> * number of entries that will be added).<a name="line.57"></a>
<span class="sourceLineNo">058</span> * &lt;br&gt;<a name="line.58"></a>
<span class="sourceLineNo">059</span> * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.<a name="line.59"></a>
<span class="sourceLineNo">060</span> * &lt;br&gt;<a name="line.60"></a>
<span class="sourceLineNo">061</span> * See https://github.com/vigna/fastutil for the original library.<a name="line.61"></a>
<span class="sourceLineNo">062</span> * @author Sebastiano Vigna (responsible for all the hard parts)<a name="line.62"></a>
<span class="sourceLineNo">063</span> * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)<a name="line.63"></a>
<span class="sourceLineNo">064</span> */<a name="line.64"></a>
<span class="sourceLineNo">065</span>public class UnorderedMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Serializable, Cloneable {<a name="line.65"></a>
<span class="sourceLineNo">066</span>    private static final long serialVersionUID = 0L;<a name="line.66"></a>
<span class="sourceLineNo">067</span>    /**<a name="line.67"></a>
<span class="sourceLineNo">068</span>     * The array of keys.<a name="line.68"></a>
<span class="sourceLineNo">069</span>     */<a name="line.69"></a>
<span class="sourceLineNo">070</span>    protected K[] key;<a name="line.70"></a>
<span class="sourceLineNo">071</span>    /**<a name="line.71"></a>
<span class="sourceLineNo">072</span>     * The array of values.<a name="line.72"></a>
<span class="sourceLineNo">073</span>     */<a name="line.73"></a>
<span class="sourceLineNo">074</span>    protected V[] value;<a name="line.74"></a>
<span class="sourceLineNo">075</span>    /**<a name="line.75"></a>
<span class="sourceLineNo">076</span>     * The mask for wrapping a position counter.<a name="line.76"></a>
<span class="sourceLineNo">077</span>     */<a name="line.77"></a>
<span class="sourceLineNo">078</span>    protected int mask;<a name="line.78"></a>
<span class="sourceLineNo">079</span>    /**<a name="line.79"></a>
<span class="sourceLineNo">080</span>     * Whether this set contains the key zero.<a name="line.80"></a>
<span class="sourceLineNo">081</span>     */<a name="line.81"></a>
<span class="sourceLineNo">082</span>    protected boolean containsNullKey;<a name="line.82"></a>
<span class="sourceLineNo">083</span>    /**<a name="line.83"></a>
<span class="sourceLineNo">084</span>     * The current table size.<a name="line.84"></a>
<span class="sourceLineNo">085</span>     */<a name="line.85"></a>
<span class="sourceLineNo">086</span>    protected int n;<a name="line.86"></a>
<span class="sourceLineNo">087</span>    /**<a name="line.87"></a>
<span class="sourceLineNo">088</span>     * Threshold after which we rehash. It must be the table size times {@link #f}.<a name="line.88"></a>
<span class="sourceLineNo">089</span>     */<a name="line.89"></a>
<span class="sourceLineNo">090</span>    protected int maxFill;<a name="line.90"></a>
<span class="sourceLineNo">091</span>    /**<a name="line.91"></a>
<span class="sourceLineNo">092</span>     * Number of entries in the set (including the key zero, if present).<a name="line.92"></a>
<span class="sourceLineNo">093</span>     */<a name="line.93"></a>
<span class="sourceLineNo">094</span>    protected int size;<a name="line.94"></a>
<span class="sourceLineNo">095</span>    /**<a name="line.95"></a>
<span class="sourceLineNo">096</span>     * The acceptable load factor.<a name="line.96"></a>
<span class="sourceLineNo">097</span>     */<a name="line.97"></a>
<span class="sourceLineNo">098</span>    public final float f;<a name="line.98"></a>
<span class="sourceLineNo">099</span>    /**<a name="line.99"></a>
<span class="sourceLineNo">100</span>     * Cached set of entries.<a name="line.100"></a>
<span class="sourceLineNo">101</span>     */<a name="line.101"></a>
<span class="sourceLineNo">102</span>    protected volatile MapEntrySet entries;<a name="line.102"></a>
<span class="sourceLineNo">103</span>    /**<a name="line.103"></a>
<span class="sourceLineNo">104</span>     * Cached set of keys.<a name="line.104"></a>
<span class="sourceLineNo">105</span>     */<a name="line.105"></a>
<span class="sourceLineNo">106</span>    protected volatile KeySet keys;<a name="line.106"></a>
<span class="sourceLineNo">107</span>    /**<a name="line.107"></a>
<span class="sourceLineNo">108</span>     * Cached collection of values.<a name="line.108"></a>
<span class="sourceLineNo">109</span>     */<a name="line.109"></a>
<span class="sourceLineNo">110</span>    protected volatile Collection&lt;V&gt; values;<a name="line.110"></a>
<span class="sourceLineNo">111</span>    /**<a name="line.111"></a>
<span class="sourceLineNo">112</span>     * Default return value.<a name="line.112"></a>
<span class="sourceLineNo">113</span>     */<a name="line.113"></a>
<span class="sourceLineNo">114</span>    protected V defRetValue = null;<a name="line.114"></a>
<span class="sourceLineNo">115</span><a name="line.115"></a>
<span class="sourceLineNo">116</span>    /**<a name="line.116"></a>
<span class="sourceLineNo">117</span>     * The initial default size of a hash table.<a name="line.117"></a>
<span class="sourceLineNo">118</span>     */<a name="line.118"></a>
<span class="sourceLineNo">119</span>    public static final int DEFAULT_INITIAL_SIZE = 16;<a name="line.119"></a>
<span class="sourceLineNo">120</span>    /**<a name="line.120"></a>
<span class="sourceLineNo">121</span>     * The default load factor of a hash table.<a name="line.121"></a>
<span class="sourceLineNo">122</span>     */<a name="line.122"></a>
<span class="sourceLineNo">123</span>    public static final float DEFAULT_LOAD_FACTOR = .75f; // .1875f; // .75f;<a name="line.123"></a>
<span class="sourceLineNo">124</span>    /**<a name="line.124"></a>
<span class="sourceLineNo">125</span>     * The load factor for a (usually small) table that is meant to be particularly fast.<a name="line.125"></a>
<span class="sourceLineNo">126</span>     */<a name="line.126"></a>
<span class="sourceLineNo">127</span>    public static final float FAST_LOAD_FACTOR = .5f;<a name="line.127"></a>
<span class="sourceLineNo">128</span>    /**<a name="line.128"></a>
<span class="sourceLineNo">129</span>     * The load factor for a (usually very small) table that is meant to be extremely fast.<a name="line.129"></a>
<span class="sourceLineNo">130</span>     */<a name="line.130"></a>
<span class="sourceLineNo">131</span>    public static final float VERY_FAST_LOAD_FACTOR = .25f;<a name="line.131"></a>
<span class="sourceLineNo">132</span><a name="line.132"></a>
<span class="sourceLineNo">133</span>    protected final CrossHash.IHasher hasher;<a name="line.133"></a>
<span class="sourceLineNo">134</span><a name="line.134"></a>
<span class="sourceLineNo">135</span>    public void defaultReturnValue(final V rv) {<a name="line.135"></a>
<span class="sourceLineNo">136</span>        defRetValue = rv;<a name="line.136"></a>
<span class="sourceLineNo">137</span>    }<a name="line.137"></a>
<span class="sourceLineNo">138</span><a name="line.138"></a>
<span class="sourceLineNo">139</span>    public V defaultReturnValue() {<a name="line.139"></a>
<span class="sourceLineNo">140</span>        return defRetValue;<a name="line.140"></a>
<span class="sourceLineNo">141</span>    }<a name="line.141"></a>
<span class="sourceLineNo">142</span><a name="line.142"></a>
<span class="sourceLineNo">143</span>    /**<a name="line.143"></a>
<span class="sourceLineNo">144</span>     * Creates a new OrderedMap.<a name="line.144"></a>
<span class="sourceLineNo">145</span>     * &lt;p&gt;<a name="line.145"></a>
<span class="sourceLineNo">146</span>     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.<a name="line.146"></a>
<span class="sourceLineNo">147</span>     *<a name="line.147"></a>
<span class="sourceLineNo">148</span>     * @param expected the expected number of elements in the hash set.<a name="line.148"></a>
<span class="sourceLineNo">149</span>     * @param f        the load factor.<a name="line.149"></a>
<span class="sourceLineNo">150</span>     */<a name="line.150"></a>
<span class="sourceLineNo">151</span><a name="line.151"></a>
<span class="sourceLineNo">152</span>    @SuppressWarnings("unchecked")<a name="line.152"></a>
<span class="sourceLineNo">153</span>    public UnorderedMap(final int expected, final float f) {<a name="line.153"></a>
<span class="sourceLineNo">154</span>        if (f &lt;= 0 || f &gt; 1)<a name="line.154"></a>
<span class="sourceLineNo">155</span>            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");<a name="line.155"></a>
<span class="sourceLineNo">156</span>        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");<a name="line.156"></a>
<span class="sourceLineNo">157</span>        this.f = f;<a name="line.157"></a>
<span class="sourceLineNo">158</span>        n = arraySize(expected, f);<a name="line.158"></a>
<span class="sourceLineNo">159</span>        mask = n - 1;<a name="line.159"></a>
<span class="sourceLineNo">160</span>        maxFill = maxFill(n, f);<a name="line.160"></a>
<span class="sourceLineNo">161</span>        key = (K[]) new Object[n + 1];<a name="line.161"></a>
<span class="sourceLineNo">162</span>        value = (V[]) new Object[n + 1];<a name="line.162"></a>
<span class="sourceLineNo">163</span>        hasher = CrossHash.mildHasher;<a name="line.163"></a>
<span class="sourceLineNo">164</span>    }<a name="line.164"></a>
<span class="sourceLineNo">165</span><a name="line.165"></a>
<span class="sourceLineNo">166</span>    /**<a name="line.166"></a>
<span class="sourceLineNo">167</span>     * Creates a new OrderedMap with 0.75f as load factor.<a name="line.167"></a>
<span class="sourceLineNo">168</span>     *<a name="line.168"></a>
<span class="sourceLineNo">169</span>     * @param expected the expected number of elements in the OrderedMap.<a name="line.169"></a>
<span class="sourceLineNo">170</span>     */<a name="line.170"></a>
<span class="sourceLineNo">171</span>    public UnorderedMap(final int expected) {<a name="line.171"></a>
<span class="sourceLineNo">172</span>        this(expected, DEFAULT_LOAD_FACTOR);<a name="line.172"></a>
<span class="sourceLineNo">173</span>    }<a name="line.173"></a>
<span class="sourceLineNo">174</span><a name="line.174"></a>
<span class="sourceLineNo">175</span>    /**<a name="line.175"></a>
<span class="sourceLineNo">176</span>     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.<a name="line.176"></a>
<span class="sourceLineNo">177</span>     */<a name="line.177"></a>
<span class="sourceLineNo">178</span>    public UnorderedMap() {<a name="line.178"></a>
<span class="sourceLineNo">179</span>        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);<a name="line.179"></a>
<span class="sourceLineNo">180</span>    }<a name="line.180"></a>
<span class="sourceLineNo">181</span><a name="line.181"></a>
<span class="sourceLineNo">182</span>    /**<a name="line.182"></a>
<span class="sourceLineNo">183</span>     * Creates a new OrderedMap copying a given one.<a name="line.183"></a>
<span class="sourceLineNo">184</span>     *<a name="line.184"></a>
<span class="sourceLineNo">185</span>     * @param m a {@link Map} to be copied into the new OrderedMap.<a name="line.185"></a>
<span class="sourceLineNo">186</span>     * @param f the load factor.<a name="line.186"></a>
<span class="sourceLineNo">187</span>     */<a name="line.187"></a>
<span class="sourceLineNo">188</span>    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f) {<a name="line.188"></a>
<span class="sourceLineNo">189</span>        this(m.size(), f, (m instanceof UnorderedMap) ? ((UnorderedMap) m).hasher : CrossHash.mildHasher);<a name="line.189"></a>
<span class="sourceLineNo">190</span>        putAll(m);<a name="line.190"></a>
<span class="sourceLineNo">191</span>    }<a name="line.191"></a>
<span class="sourceLineNo">192</span><a name="line.192"></a>
<span class="sourceLineNo">193</span>    /**<a name="line.193"></a>
<span class="sourceLineNo">194</span>     * Creates a new OrderedMap with 0.75f as load factor copying a given one.<a name="line.194"></a>
<span class="sourceLineNo">195</span>     *<a name="line.195"></a>
<span class="sourceLineNo">196</span>     * @param m a {@link Map} to be copied into the new OrderedMap.<a name="line.196"></a>
<span class="sourceLineNo">197</span>     */<a name="line.197"></a>
<span class="sourceLineNo">198</span>    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m) {<a name="line.198"></a>
<span class="sourceLineNo">199</span>        this(m, (m instanceof UnorderedMap) ? ((UnorderedMap) m).f : DEFAULT_LOAD_FACTOR, (m instanceof UnorderedMap) ? ((UnorderedMap) m).hasher : CrossHash.mildHasher);<a name="line.199"></a>
<span class="sourceLineNo">200</span>    }<a name="line.200"></a>
<span class="sourceLineNo">201</span><a name="line.201"></a>
<span class="sourceLineNo">202</span>    /**<a name="line.202"></a>
<span class="sourceLineNo">203</span>     * Creates a new OrderedMap using the elements of two parallel arrays.<a name="line.203"></a>
<span class="sourceLineNo">204</span>     *<a name="line.204"></a>
<span class="sourceLineNo">205</span>     * @param keyArray the array of keys of the new OrderedMap.<a name="line.205"></a>
<span class="sourceLineNo">206</span>     * @param valueArray the array of corresponding values in the new OrderedMap.<a name="line.206"></a>
<span class="sourceLineNo">207</span>     * @param f the load factor.<a name="line.207"></a>
<span class="sourceLineNo">208</span>     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.208"></a>
<span class="sourceLineNo">209</span>     */<a name="line.209"></a>
<span class="sourceLineNo">210</span>    public UnorderedMap(final K[] keyArray, final V[] valueArray, final float f) {<a name="line.210"></a>
<span class="sourceLineNo">211</span>        this(keyArray.length, f);<a name="line.211"></a>
<span class="sourceLineNo">212</span>        if (keyArray.length != valueArray.length)<a name="line.212"></a>
<span class="sourceLineNo">213</span>            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");<a name="line.213"></a>
<span class="sourceLineNo">214</span>        for (int i = 0; i &lt; keyArray.length; i++)<a name="line.214"></a>
<span class="sourceLineNo">215</span>            put(keyArray[i], valueArray[i]);<a name="line.215"></a>
<span class="sourceLineNo">216</span>    }<a name="line.216"></a>
<span class="sourceLineNo">217</span>    /**<a name="line.217"></a>
<span class="sourceLineNo">218</span>     * Creates a new OrderedMap using the elements of two parallel arrays.<a name="line.218"></a>
<span class="sourceLineNo">219</span>     *<a name="line.219"></a>
<span class="sourceLineNo">220</span>     * @param keyColl the collection of keys of the new OrderedMap.<a name="line.220"></a>
<span class="sourceLineNo">221</span>     * @param valueColl the collection of corresponding values in the new OrderedMap.<a name="line.221"></a>
<span class="sourceLineNo">222</span>     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.222"></a>
<span class="sourceLineNo">223</span>     */<a name="line.223"></a>
<span class="sourceLineNo">224</span>    public UnorderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl) {<a name="line.224"></a>
<span class="sourceLineNo">225</span>        this(keyColl, valueColl, DEFAULT_LOAD_FACTOR);<a name="line.225"></a>
<span class="sourceLineNo">226</span>    }<a name="line.226"></a>
<span class="sourceLineNo">227</span>        /**<a name="line.227"></a>
<span class="sourceLineNo">228</span>         * Creates a new OrderedMap using the elements of two parallel arrays.<a name="line.228"></a>
<span class="sourceLineNo">229</span>         *<a name="line.229"></a>
<span class="sourceLineNo">230</span>         * @param keyColl the collection of keys of the new OrderedMap.<a name="line.230"></a>
<span class="sourceLineNo">231</span>         * @param valueColl the collection of corresponding values in the new OrderedMap.<a name="line.231"></a>
<span class="sourceLineNo">232</span>         * @param f the load factor.<a name="line.232"></a>
<span class="sourceLineNo">233</span>         * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.233"></a>
<span class="sourceLineNo">234</span>         */<a name="line.234"></a>
<span class="sourceLineNo">235</span>    public UnorderedMap(final Collection&lt;K&gt; keyColl, final Collection&lt;V&gt; valueColl, final float f) {<a name="line.235"></a>
<span class="sourceLineNo">236</span>        this(keyColl.size(), f);<a name="line.236"></a>
<span class="sourceLineNo">237</span>        if (keyColl.size() != valueColl.size())<a name="line.237"></a>
<span class="sourceLineNo">238</span>            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyColl.size() + " and " + valueColl.size() + ")");<a name="line.238"></a>
<span class="sourceLineNo">239</span>        Iterator&lt;K&gt; ki = keyColl.iterator();<a name="line.239"></a>
<span class="sourceLineNo">240</span>        Iterator&lt;V&gt; vi = valueColl.iterator();<a name="line.240"></a>
<span class="sourceLineNo">241</span>        while (ki.hasNext() &amp;&amp; vi.hasNext())<a name="line.241"></a>
<span class="sourceLineNo">242</span>        {<a name="line.242"></a>
<span class="sourceLineNo">243</span>            put(ki.next(), vi.next());<a name="line.243"></a>
<span class="sourceLineNo">244</span>        }<a name="line.244"></a>
<span class="sourceLineNo">245</span>    }<a name="line.245"></a>
<span class="sourceLineNo">246</span><a name="line.246"></a>
<span class="sourceLineNo">247</span>    /**<a name="line.247"></a>
<span class="sourceLineNo">248</span>     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.<a name="line.248"></a>
<span class="sourceLineNo">249</span>     *<a name="line.249"></a>
<span class="sourceLineNo">250</span>     * @param keyArray the array of keys of the new OrderedMap.<a name="line.250"></a>
<span class="sourceLineNo">251</span>     * @param valueArray the array of corresponding values in the new OrderedMap.<a name="line.251"></a>
<span class="sourceLineNo">252</span>     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.252"></a>
<span class="sourceLineNo">253</span>     */<a name="line.253"></a>
<span class="sourceLineNo">254</span>    public UnorderedMap(final K[] keyArray, final V[] valueArray) {<a name="line.254"></a>
<span class="sourceLineNo">255</span>        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR);<a name="line.255"></a>
<span class="sourceLineNo">256</span>    }<a name="line.256"></a>
<span class="sourceLineNo">257</span><a name="line.257"></a>
<span class="sourceLineNo">258</span>    /**<a name="line.258"></a>
<span class="sourceLineNo">259</span>     * Creates a new OrderedMap.<a name="line.259"></a>
<span class="sourceLineNo">260</span>     * &lt;p&gt;<a name="line.260"></a>
<span class="sourceLineNo">261</span>     * &lt;p&gt;The actual table size will be the least power of two greater than &lt;code&gt;expected&lt;/code&gt;/&lt;code&gt;f&lt;/code&gt;.<a name="line.261"></a>
<span class="sourceLineNo">262</span>     *<a name="line.262"></a>
<span class="sourceLineNo">263</span>     * @param expected the expected number of elements in the hash set.<a name="line.263"></a>
<span class="sourceLineNo">264</span>     * @param f        the load factor.<a name="line.264"></a>
<span class="sourceLineNo">265</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.265"></a>
<span class="sourceLineNo">266</span>     */<a name="line.266"></a>
<span class="sourceLineNo">267</span><a name="line.267"></a>
<span class="sourceLineNo">268</span>    @SuppressWarnings("unchecked")<a name="line.268"></a>
<span class="sourceLineNo">269</span>    public UnorderedMap(final int expected, final float f, CrossHash.IHasher hasher) {<a name="line.269"></a>
<span class="sourceLineNo">270</span>        if (f &lt;= 0 || f &gt; 1)<a name="line.270"></a>
<span class="sourceLineNo">271</span>            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");<a name="line.271"></a>
<span class="sourceLineNo">272</span>        if (expected &lt; 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");<a name="line.272"></a>
<span class="sourceLineNo">273</span>        this.f = f;<a name="line.273"></a>
<span class="sourceLineNo">274</span>        n = arraySize(expected, f);<a name="line.274"></a>
<span class="sourceLineNo">275</span>        mask = n - 1;<a name="line.275"></a>
<span class="sourceLineNo">276</span>        maxFill = maxFill(n, f);<a name="line.276"></a>
<span class="sourceLineNo">277</span>        key = (K[]) new Object[n + 1];<a name="line.277"></a>
<span class="sourceLineNo">278</span>        value = (V[]) new Object[n + 1];<a name="line.278"></a>
<span class="sourceLineNo">279</span>        this.hasher = (hasher == null) ? CrossHash.mildHasher : hasher;<a name="line.279"></a>
<span class="sourceLineNo">280</span>    }<a name="line.280"></a>
<span class="sourceLineNo">281</span>    /**<a name="line.281"></a>
<span class="sourceLineNo">282</span>     * Creates a new OrderedMap with 0.75f as load factor.<a name="line.282"></a>
<span class="sourceLineNo">283</span>     *<a name="line.283"></a>
<span class="sourceLineNo">284</span>     * @param expected the expected number of elements in the OrderedMap.<a name="line.284"></a>
<span class="sourceLineNo">285</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.285"></a>
<span class="sourceLineNo">286</span>     */<a name="line.286"></a>
<span class="sourceLineNo">287</span>    public UnorderedMap(final int expected, CrossHash.IHasher hasher) {<a name="line.287"></a>
<span class="sourceLineNo">288</span>        this(expected, DEFAULT_LOAD_FACTOR, hasher);<a name="line.288"></a>
<span class="sourceLineNo">289</span>    }<a name="line.289"></a>
<span class="sourceLineNo">290</span><a name="line.290"></a>
<span class="sourceLineNo">291</span>    /**<a name="line.291"></a>
<span class="sourceLineNo">292</span>     * Creates a new OrderedMap with initial expected 16 entries and 0.75f as load factor.<a name="line.292"></a>
<span class="sourceLineNo">293</span>     */<a name="line.293"></a>
<span class="sourceLineNo">294</span>    public UnorderedMap(CrossHash.IHasher hasher) {<a name="line.294"></a>
<span class="sourceLineNo">295</span>        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);<a name="line.295"></a>
<span class="sourceLineNo">296</span>    }<a name="line.296"></a>
<span class="sourceLineNo">297</span><a name="line.297"></a>
<span class="sourceLineNo">298</span>    /**<a name="line.298"></a>
<span class="sourceLineNo">299</span>     * Creates a new OrderedMap copying a given one.<a name="line.299"></a>
<span class="sourceLineNo">300</span>     *<a name="line.300"></a>
<span class="sourceLineNo">301</span>     * @param m a {@link Map} to be copied into the new OrderedMap.<a name="line.301"></a>
<span class="sourceLineNo">302</span>     * @param f the load factor.<a name="line.302"></a>
<span class="sourceLineNo">303</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.303"></a>
<span class="sourceLineNo">304</span>     */<a name="line.304"></a>
<span class="sourceLineNo">305</span>    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, final float f, CrossHash.IHasher hasher) {<a name="line.305"></a>
<span class="sourceLineNo">306</span>        this(m.size(), f, hasher);<a name="line.306"></a>
<span class="sourceLineNo">307</span>        putAll(m);<a name="line.307"></a>
<span class="sourceLineNo">308</span>    }<a name="line.308"></a>
<span class="sourceLineNo">309</span><a name="line.309"></a>
<span class="sourceLineNo">310</span>    /**<a name="line.310"></a>
<span class="sourceLineNo">311</span>     * Creates a new OrderedMap with 0.75f as load factor copying a given one.<a name="line.311"></a>
<span class="sourceLineNo">312</span>     * @param m a {@link Map} to be copied into the new OrderedMap.<a name="line.312"></a>
<span class="sourceLineNo">313</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.313"></a>
<span class="sourceLineNo">314</span>     */<a name="line.314"></a>
<span class="sourceLineNo">315</span>    public UnorderedMap(final Map&lt;? extends K, ? extends V&gt; m, CrossHash.IHasher hasher) {<a name="line.315"></a>
<span class="sourceLineNo">316</span>        this(m, DEFAULT_LOAD_FACTOR, hasher);<a name="line.316"></a>
<span class="sourceLineNo">317</span>    }<a name="line.317"></a>
<span class="sourceLineNo">318</span><a name="line.318"></a>
<span class="sourceLineNo">319</span>    /**<a name="line.319"></a>
<span class="sourceLineNo">320</span>     * Creates a new OrderedMap using the elements of two parallel arrays.<a name="line.320"></a>
<span class="sourceLineNo">321</span>     *<a name="line.321"></a>
<span class="sourceLineNo">322</span>     * @param keyArray the array of keys of the new OrderedMap.<a name="line.322"></a>
<span class="sourceLineNo">323</span>     * @param valueArray the array of corresponding values in the new OrderedMap.<a name="line.323"></a>
<span class="sourceLineNo">324</span>     * @param f the load factor.<a name="line.324"></a>
<span class="sourceLineNo">325</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.325"></a>
<span class="sourceLineNo">326</span>     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.326"></a>
<span class="sourceLineNo">327</span>     */<a name="line.327"></a>
<span class="sourceLineNo">328</span>    public UnorderedMap(final K[] keyArray, final V[] valueArray, final float f, CrossHash.IHasher hasher) {<a name="line.328"></a>
<span class="sourceLineNo">329</span>        this(keyArray.length, f, hasher);<a name="line.329"></a>
<span class="sourceLineNo">330</span>        if (keyArray.length != valueArray.length)<a name="line.330"></a>
<span class="sourceLineNo">331</span>            throw new IllegalArgumentException("The key array and the value array have different lengths (" + keyArray.length + " and " + valueArray.length + ")");<a name="line.331"></a>
<span class="sourceLineNo">332</span>        for (int i = 0; i &lt; keyArray.length; i++)<a name="line.332"></a>
<span class="sourceLineNo">333</span>            put(keyArray[i], valueArray[i]);<a name="line.333"></a>
<span class="sourceLineNo">334</span>    }<a name="line.334"></a>
<span class="sourceLineNo">335</span>    /**<a name="line.335"></a>
<span class="sourceLineNo">336</span>     * Creates a new OrderedMap with 0.75f as load factor using the elements of two parallel arrays.<a name="line.336"></a>
<span class="sourceLineNo">337</span>     *<a name="line.337"></a>
<span class="sourceLineNo">338</span>     * @param keyArray the array of keys of the new OrderedMap.<a name="line.338"></a>
<span class="sourceLineNo">339</span>     * @param valueArray the array of corresponding values in the new OrderedMap.<a name="line.339"></a>
<span class="sourceLineNo">340</span>     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations<a name="line.340"></a>
<span class="sourceLineNo">341</span>     * @throws IllegalArgumentException if &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; have different lengths.<a name="line.341"></a>
<span class="sourceLineNo">342</span>     */<a name="line.342"></a>
<span class="sourceLineNo">343</span>    public UnorderedMap(final K[] keyArray, final V[] valueArray, CrossHash.IHasher hasher) {<a name="line.343"></a>
<span class="sourceLineNo">344</span>        this(keyArray, valueArray, DEFAULT_LOAD_FACTOR, hasher);<a name="line.344"></a>
<span class="sourceLineNo">345</span>    }<a name="line.345"></a>
<span class="sourceLineNo">346</span><a name="line.346"></a>
<span class="sourceLineNo">347</span>    private int realSize() {<a name="line.347"></a>
<span class="sourceLineNo">348</span>        return containsNullKey ? size - 1 : size;<a name="line.348"></a>
<span class="sourceLineNo">349</span>    }<a name="line.349"></a>
<span class="sourceLineNo">350</span>    private void ensureCapacity(final int capacity) {<a name="line.350"></a>
<span class="sourceLineNo">351</span>        final int needed = arraySize(capacity, f);<a name="line.351"></a>
<span class="sourceLineNo">352</span>        if (needed &gt; n)<a name="line.352"></a>
<span class="sourceLineNo">353</span>            rehash(needed);<a name="line.353"></a>
<span class="sourceLineNo">354</span>    }<a name="line.354"></a>
<span class="sourceLineNo">355</span>    private void tryCapacity(final long capacity) {<a name="line.355"></a>
<span class="sourceLineNo">356</span>        final int needed = (int) Math.min(<a name="line.356"></a>
<span class="sourceLineNo">357</span>                1 &lt;&lt; 30,<a name="line.357"></a>
<span class="sourceLineNo">358</span>                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity<a name="line.358"></a>
<span class="sourceLineNo">359</span>                        / f))));<a name="line.359"></a>
<span class="sourceLineNo">360</span>        if (needed &gt; n)<a name="line.360"></a>
<span class="sourceLineNo">361</span>            rehash(needed);<a name="line.361"></a>
<span class="sourceLineNo">362</span>    }<a name="line.362"></a>
<span class="sourceLineNo">363</span>    private V removeEntry(final int pos) {<a name="line.363"></a>
<span class="sourceLineNo">364</span>        final V oldValue = value[pos];<a name="line.364"></a>
<span class="sourceLineNo">365</span>        value[pos] = null;<a name="line.365"></a>
<span class="sourceLineNo">366</span>        size--;<a name="line.366"></a>
<span class="sourceLineNo">367</span>        shiftKeys(pos);<a name="line.367"></a>
<span class="sourceLineNo">368</span>        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)<a name="line.368"></a>
<span class="sourceLineNo">369</span>            rehash(n / 2);<a name="line.369"></a>
<span class="sourceLineNo">370</span>        return oldValue;<a name="line.370"></a>
<span class="sourceLineNo">371</span>    }<a name="line.371"></a>
<span class="sourceLineNo">372</span>    private V removeNullEntry() {<a name="line.372"></a>
<span class="sourceLineNo">373</span>        containsNullKey = false;<a name="line.373"></a>
<span class="sourceLineNo">374</span>        key[n] = null;<a name="line.374"></a>
<span class="sourceLineNo">375</span>        final V oldValue = value[n];<a name="line.375"></a>
<span class="sourceLineNo">376</span>        value[n] = null;<a name="line.376"></a>
<span class="sourceLineNo">377</span>        size--;<a name="line.377"></a>
<span class="sourceLineNo">378</span>        if (size &lt; maxFill / 4 &amp;&amp; n &gt; DEFAULT_INITIAL_SIZE)<a name="line.378"></a>
<span class="sourceLineNo">379</span>            rehash(n / 2);<a name="line.379"></a>
<span class="sourceLineNo">380</span>        return oldValue;<a name="line.380"></a>
<span class="sourceLineNo">381</span>    }<a name="line.381"></a>
<span class="sourceLineNo">382</span><a name="line.382"></a>
<span class="sourceLineNo">383</span>    /**<a name="line.383"></a>
<span class="sourceLineNo">384</span>     * Puts the first key in keyArray with the first value in valueArray, then the second in each and so on.<a name="line.384"></a>
<span class="sourceLineNo">385</span>     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,<a name="line.385"></a>
<span class="sourceLineNo">386</span>     * its value is changed at the existing position in the iteration order.<a name="line.386"></a>
<span class="sourceLineNo">387</span>     * If the lengths of the two arrays are not equal, this puts a number of entries equal to the lesser length.<a name="line.387"></a>
<span class="sourceLineNo">388</span>     * If either array is null, this returns without performing any changes.<a name="line.388"></a>
<span class="sourceLineNo">389</span>     * @param keyArray an array of K keys that should usually have the same length as valueArray<a name="line.389"></a>
<span class="sourceLineNo">390</span>     * @param valueArray an array of V values that should usually have the same length as keyArray<a name="line.390"></a>
<span class="sourceLineNo">391</span>     */<a name="line.391"></a>
<span class="sourceLineNo">392</span>    public void putAll(final K[] keyArray, final V[] valueArray)<a name="line.392"></a>
<span class="sourceLineNo">393</span>    {<a name="line.393"></a>
<span class="sourceLineNo">394</span>        if(keyArray == null || valueArray == null)<a name="line.394"></a>
<span class="sourceLineNo">395</span>            return;<a name="line.395"></a>
<span class="sourceLineNo">396</span>        for (int i = 0; i &lt; keyArray.length &amp;&amp; i &lt; valueArray.length; i++)<a name="line.396"></a>
<span class="sourceLineNo">397</span>            put(keyArray[i], valueArray[i]);<a name="line.397"></a>
<span class="sourceLineNo">398</span><a name="line.398"></a>
<span class="sourceLineNo">399</span>    }<a name="line.399"></a>
<span class="sourceLineNo">400</span><a name="line.400"></a>
<span class="sourceLineNo">401</span>    /**<a name="line.401"></a>
<span class="sourceLineNo">402</span>     * Puts all key-value pairs in the Map m into this OrderedMap.<a name="line.402"></a>
<span class="sourceLineNo">403</span>     * The entries are all appended to the end of the iteration order, unless a key was already present. Then,<a name="line.403"></a>
<span class="sourceLineNo">404</span>     * its value is changed at the existing position in the iteration order. This can take any kind of Map,<a name="line.404"></a>
<span class="sourceLineNo">405</span>     * including unordered HashMap objects; if the Map does not have stable ordering, the order in which entries<a name="line.405"></a>
<span class="sourceLineNo">406</span>     * will be appended is not stable either. For this reason, OrderedMap, LinkedHashMap, and TreeMap (or other<a name="line.406"></a>
<span class="sourceLineNo">407</span>     * SortedMap implementations) will work best when order matters.<a name="line.407"></a>
<span class="sourceLineNo">408</span>     * @param m a Map that should have the same or compatible K key and V value types; OrderedMap and TreeMap work best<a name="line.408"></a>
<span class="sourceLineNo">409</span>     */<a name="line.409"></a>
<span class="sourceLineNo">410</span>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {<a name="line.410"></a>
<span class="sourceLineNo">411</span>        if (f &lt;= .5)<a name="line.411"></a>
<span class="sourceLineNo">412</span>            ensureCapacity(m.size()); // The resulting map will be sized for<a name="line.412"></a>
<span class="sourceLineNo">413</span>            // m.size() elements<a name="line.413"></a>
<span class="sourceLineNo">414</span>        else<a name="line.414"></a>
<span class="sourceLineNo">415</span>            tryCapacity(size() + m.size()); // The resulting map will be<a name="line.415"></a>
<span class="sourceLineNo">416</span>        int n = m.size();<a name="line.416"></a>
<span class="sourceLineNo">417</span>        final Iterator&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; i = m<a name="line.417"></a>
<span class="sourceLineNo">418</span>                .entrySet().iterator();<a name="line.418"></a>
<span class="sourceLineNo">419</span>        Entry&lt;? extends K, ? extends V&gt; e;<a name="line.419"></a>
<span class="sourceLineNo">420</span>        while (n-- != 0) {<a name="line.420"></a>
<span class="sourceLineNo">421</span>            e = i.next();<a name="line.421"></a>
<span class="sourceLineNo">422</span>            put(e.getKey(), e.getValue());<a name="line.422"></a>
<span class="sourceLineNo">423</span>        }<a name="line.423"></a>
<span class="sourceLineNo">424</span>    }<a name="line.424"></a>
<span class="sourceLineNo">425</span>    private int insert(final K k, final V v) {<a name="line.425"></a>
<span class="sourceLineNo">426</span>        int pos;<a name="line.426"></a>
<span class="sourceLineNo">427</span>        if (k == null) {<a name="line.427"></a>
<span class="sourceLineNo">428</span>            if (containsNullKey)<a name="line.428"></a>
<span class="sourceLineNo">429</span>                return n;<a name="line.429"></a>
<span class="sourceLineNo">430</span>            containsNullKey = true;<a name="line.430"></a>
<span class="sourceLineNo">431</span>            pos = n;<a name="line.431"></a>
<span class="sourceLineNo">432</span>        } else {<a name="line.432"></a>
<span class="sourceLineNo">433</span>            K curr;<a name="line.433"></a>
<span class="sourceLineNo">434</span>            final K[] key = this.key;<a name="line.434"></a>
<span class="sourceLineNo">435</span>            // The starting point.<a name="line.435"></a>
<span class="sourceLineNo">436</span>            if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) != null) {<a name="line.436"></a>
<span class="sourceLineNo">437</span>                if (hasher.areEqual(curr, k))<a name="line.437"></a>
<span class="sourceLineNo">438</span>                    return pos;<a name="line.438"></a>
<span class="sourceLineNo">439</span>                while ((curr = key[pos = (pos + 1) &amp; mask]) != null)<a name="line.439"></a>
<span class="sourceLineNo">440</span>                    if (hasher.areEqual(curr, k))<a name="line.440"></a>
<span class="sourceLineNo">441</span>                        return pos;<a name="line.441"></a>
<span class="sourceLineNo">442</span>            }<a name="line.442"></a>
<span class="sourceLineNo">443</span>        }<a name="line.443"></a>
<span class="sourceLineNo">444</span>        key[pos] = k;<a name="line.444"></a>
<span class="sourceLineNo">445</span>        value[pos] = v;<a name="line.445"></a>
<span class="sourceLineNo">446</span>        if (size++ &gt;= maxFill)<a name="line.446"></a>
<span class="sourceLineNo">447</span>            rehash(arraySize(size + 1, f));<a name="line.447"></a>
<span class="sourceLineNo">448</span>        return -1;<a name="line.448"></a>
<span class="sourceLineNo">449</span>    }<a name="line.449"></a>
<span class="sourceLineNo">450</span>    public V put(final K k, final V v) {<a name="line.450"></a>
<span class="sourceLineNo">451</span>        final int pos = insert(k, v);<a name="line.451"></a>
<span class="sourceLineNo">452</span>        if (pos &lt; 0)<a name="line.452"></a>
<span class="sourceLineNo">453</span>            return defRetValue;<a name="line.453"></a>
<span class="sourceLineNo">454</span>        final V oldValue = value[pos];<a name="line.454"></a>
<span class="sourceLineNo">455</span>        value[pos] = v;<a name="line.455"></a>
<span class="sourceLineNo">456</span>        return oldValue;<a name="line.456"></a>
<span class="sourceLineNo">457</span>    }<a name="line.457"></a>
<span class="sourceLineNo">458</span>    /**<a name="line.458"></a>
<span class="sourceLineNo">459</span>     * Shifts left entries with the specified hash code, starting at the<a name="line.459"></a>
<span class="sourceLineNo">460</span>     * specified position, and empties the resulting free entry.<a name="line.460"></a>
<span class="sourceLineNo">461</span>     *<a name="line.461"></a>
<span class="sourceLineNo">462</span>     * @param pos<a name="line.462"></a>
<span class="sourceLineNo">463</span>     *            a starting position.<a name="line.463"></a>
<span class="sourceLineNo">464</span>     */<a name="line.464"></a>
<span class="sourceLineNo">465</span>    protected final void shiftKeys(int pos) {<a name="line.465"></a>
<span class="sourceLineNo">466</span>        // Shift entries with the same hash.<a name="line.466"></a>
<span class="sourceLineNo">467</span>        int last, slot;<a name="line.467"></a>
<span class="sourceLineNo">468</span>        K curr;<a name="line.468"></a>
<span class="sourceLineNo">469</span>        final K[] key = this.key;<a name="line.469"></a>
<span class="sourceLineNo">470</span>        for (;;) {<a name="line.470"></a>
<span class="sourceLineNo">471</span>            pos = ((last = pos) + 1) &amp; mask;<a name="line.471"></a>
<span class="sourceLineNo">472</span>            for (;;) {<a name="line.472"></a>
<span class="sourceLineNo">473</span>                if ((curr = key[pos]) == null) {<a name="line.473"></a>
<span class="sourceLineNo">474</span>                    key[last] = null;<a name="line.474"></a>
<span class="sourceLineNo">475</span>                    value[last] = null;<a name="line.475"></a>
<span class="sourceLineNo">476</span>                    return;<a name="line.476"></a>
<span class="sourceLineNo">477</span>                }<a name="line.477"></a>
<span class="sourceLineNo">478</span>                slot = (hasher.hash(curr))<a name="line.478"></a>
<span class="sourceLineNo">479</span>                        &amp; mask;<a name="line.479"></a>
<span class="sourceLineNo">480</span>                if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot<a name="line.480"></a>
<span class="sourceLineNo">481</span>                        &amp;&amp; slot &gt; pos)<a name="line.481"></a>
<span class="sourceLineNo">482</span>                    break;<a name="line.482"></a>
<span class="sourceLineNo">483</span>                pos = (pos + 1) &amp; mask;<a name="line.483"></a>
<span class="sourceLineNo">484</span>            }<a name="line.484"></a>
<span class="sourceLineNo">485</span>            key[last] = curr;<a name="line.485"></a>
<span class="sourceLineNo">486</span>            value[last] = value[pos];<a name="line.486"></a>
<span class="sourceLineNo">487</span>        }<a name="line.487"></a>
<span class="sourceLineNo">488</span>    }<a name="line.488"></a>
<span class="sourceLineNo">489</span>    @SuppressWarnings("unchecked")<a name="line.489"></a>
<span class="sourceLineNo">490</span>    public V remove(final Object k) {<a name="line.490"></a>
<span class="sourceLineNo">491</span>        if (k == null) {<a name="line.491"></a>
<span class="sourceLineNo">492</span>            if (containsNullKey)<a name="line.492"></a>
<span class="sourceLineNo">493</span>                return removeNullEntry();<a name="line.493"></a>
<span class="sourceLineNo">494</span>            return defRetValue;<a name="line.494"></a>
<span class="sourceLineNo">495</span>        }<a name="line.495"></a>
<span class="sourceLineNo">496</span>        K curr;<a name="line.496"></a>
<span class="sourceLineNo">497</span>        final K[] key = this.key;<a name="line.497"></a>
<span class="sourceLineNo">498</span>        int pos;<a name="line.498"></a>
<span class="sourceLineNo">499</span>        // The starting point.<a name="line.499"></a>
<span class="sourceLineNo">500</span>        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)<a name="line.500"></a>
<span class="sourceLineNo">501</span>            return defRetValue;<a name="line.501"></a>
<span class="sourceLineNo">502</span>        if (hasher.areEqual(k, curr))<a name="line.502"></a>
<span class="sourceLineNo">503</span>            return removeEntry(pos);<a name="line.503"></a>
<span class="sourceLineNo">504</span>        while (true) {<a name="line.504"></a>
<span class="sourceLineNo">505</span>            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)<a name="line.505"></a>
<span class="sourceLineNo">506</span>                return defRetValue;<a name="line.506"></a>
<span class="sourceLineNo">507</span>            if (hasher.areEqual(k, curr))<a name="line.507"></a>
<span class="sourceLineNo">508</span>                return removeEntry(pos);<a name="line.508"></a>
<span class="sourceLineNo">509</span>        }<a name="line.509"></a>
<span class="sourceLineNo">510</span>    }<a name="line.510"></a>
<span class="sourceLineNo">511</span>    private V setValue(final int pos, final V v) {<a name="line.511"></a>
<span class="sourceLineNo">512</span>        final V oldValue = value[pos];<a name="line.512"></a>
<span class="sourceLineNo">513</span>        value[pos] = v;<a name="line.513"></a>
<span class="sourceLineNo">514</span>        return oldValue;<a name="line.514"></a>
<span class="sourceLineNo">515</span>    }<a name="line.515"></a>
<span class="sourceLineNo">516</span>    public V get(final Object k) {<a name="line.516"></a>
<span class="sourceLineNo">517</span>        if (k == null)<a name="line.517"></a>
<span class="sourceLineNo">518</span>            return containsNullKey ? value[n] : defRetValue;<a name="line.518"></a>
<span class="sourceLineNo">519</span>        K curr;<a name="line.519"></a>
<span class="sourceLineNo">520</span>        final K[] key = this.key;<a name="line.520"></a>
<span class="sourceLineNo">521</span>        int pos;<a name="line.521"></a>
<span class="sourceLineNo">522</span>        // The starting point.<a name="line.522"></a>
<span class="sourceLineNo">523</span>        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)<a name="line.523"></a>
<span class="sourceLineNo">524</span>            return defRetValue;<a name="line.524"></a>
<span class="sourceLineNo">525</span>        if (hasher.areEqual(k, curr))<a name="line.525"></a>
<span class="sourceLineNo">526</span>            return value[pos];<a name="line.526"></a>
<span class="sourceLineNo">527</span>        // There's always an unused entry.<a name="line.527"></a>
<span class="sourceLineNo">528</span>        while (true) {<a name="line.528"></a>
<span class="sourceLineNo">529</span>            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)<a name="line.529"></a>
<span class="sourceLineNo">530</span>                return defRetValue;<a name="line.530"></a>
<span class="sourceLineNo">531</span>            if (hasher.areEqual(k, curr))<a name="line.531"></a>
<span class="sourceLineNo">532</span>                return value[pos];<a name="line.532"></a>
<span class="sourceLineNo">533</span>        }<a name="line.533"></a>
<span class="sourceLineNo">534</span>    }<a name="line.534"></a>
<span class="sourceLineNo">535</span><a name="line.535"></a>
<span class="sourceLineNo">536</span><a name="line.536"></a>
<span class="sourceLineNo">537</span>    public V getOrDefault(final Object k, final V defaultValue) {<a name="line.537"></a>
<span class="sourceLineNo">538</span>        if (k == null)<a name="line.538"></a>
<span class="sourceLineNo">539</span>            return containsNullKey ? value[n] : defaultValue;<a name="line.539"></a>
<span class="sourceLineNo">540</span>        K curr;<a name="line.540"></a>
<span class="sourceLineNo">541</span>        final K[] key = this.key;<a name="line.541"></a>
<span class="sourceLineNo">542</span>        int pos;<a name="line.542"></a>
<span class="sourceLineNo">543</span>        // The starting point.<a name="line.543"></a>
<span class="sourceLineNo">544</span>        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)<a name="line.544"></a>
<span class="sourceLineNo">545</span>            return defaultValue;<a name="line.545"></a>
<span class="sourceLineNo">546</span>        if (hasher.areEqual(k, curr))<a name="line.546"></a>
<span class="sourceLineNo">547</span>            return value[pos];<a name="line.547"></a>
<span class="sourceLineNo">548</span>        // There's always an unused entry.<a name="line.548"></a>
<span class="sourceLineNo">549</span>        while (true) {<a name="line.549"></a>
<span class="sourceLineNo">550</span>            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)<a name="line.550"></a>
<span class="sourceLineNo">551</span>                return defaultValue;<a name="line.551"></a>
<span class="sourceLineNo">552</span>            if (hasher.areEqual(k, curr))<a name="line.552"></a>
<span class="sourceLineNo">553</span>                return value[pos];<a name="line.553"></a>
<span class="sourceLineNo">554</span>        }<a name="line.554"></a>
<span class="sourceLineNo">555</span>    }<a name="line.555"></a>
<span class="sourceLineNo">556</span><a name="line.556"></a>
<span class="sourceLineNo">557</span>    protected int positionOf(final Object k) {<a name="line.557"></a>
<span class="sourceLineNo">558</span>        if (k == null)<a name="line.558"></a>
<span class="sourceLineNo">559</span>        {<a name="line.559"></a>
<span class="sourceLineNo">560</span>            if(containsNullKey)<a name="line.560"></a>
<span class="sourceLineNo">561</span>                return n;<a name="line.561"></a>
<span class="sourceLineNo">562</span>            else<a name="line.562"></a>
<span class="sourceLineNo">563</span>                return -1;<a name="line.563"></a>
<span class="sourceLineNo">564</span>        }<a name="line.564"></a>
<span class="sourceLineNo">565</span>        K curr;<a name="line.565"></a>
<span class="sourceLineNo">566</span>        final K[] key = this.key;<a name="line.566"></a>
<span class="sourceLineNo">567</span>        int pos;<a name="line.567"></a>
<span class="sourceLineNo">568</span>        // The starting point.<a name="line.568"></a>
<span class="sourceLineNo">569</span>        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)<a name="line.569"></a>
<span class="sourceLineNo">570</span>            return -1;<a name="line.570"></a>
<span class="sourceLineNo">571</span>        if (hasher.areEqual(k, curr))<a name="line.571"></a>
<span class="sourceLineNo">572</span>            return pos;<a name="line.572"></a>
<span class="sourceLineNo">573</span>        // There's always an unused entry.<a name="line.573"></a>
<span class="sourceLineNo">574</span>        while (true) {<a name="line.574"></a>
<span class="sourceLineNo">575</span>            if ((curr = key[pos = pos + 1 &amp; mask]) == null)<a name="line.575"></a>
<span class="sourceLineNo">576</span>                return -1;<a name="line.576"></a>
<span class="sourceLineNo">577</span>            if (hasher.areEqual(k, curr))<a name="line.577"></a>
<span class="sourceLineNo">578</span>                return pos;<a name="line.578"></a>
<span class="sourceLineNo">579</span>        }<a name="line.579"></a>
<span class="sourceLineNo">580</span>    }<a name="line.580"></a>
<span class="sourceLineNo">581</span><a name="line.581"></a>
<span class="sourceLineNo">582</span>    public boolean containsKey(final Object k) {<a name="line.582"></a>
<span class="sourceLineNo">583</span>        if (k == null)<a name="line.583"></a>
<span class="sourceLineNo">584</span>            return containsNullKey;<a name="line.584"></a>
<span class="sourceLineNo">585</span>        K curr;<a name="line.585"></a>
<span class="sourceLineNo">586</span>        final K[] key = this.key;<a name="line.586"></a>
<span class="sourceLineNo">587</span>        int pos;<a name="line.587"></a>
<span class="sourceLineNo">588</span>        // The starting point.<a name="line.588"></a>
<span class="sourceLineNo">589</span>        if ((curr = key[pos = (hasher.hash(k)) &amp; mask]) == null)<a name="line.589"></a>
<span class="sourceLineNo">590</span>            return false;<a name="line.590"></a>
<span class="sourceLineNo">591</span>        if (hasher.areEqual(k, curr))<a name="line.591"></a>
<span class="sourceLineNo">592</span>            return true;<a name="line.592"></a>
<span class="sourceLineNo">593</span>        // There's always an unused entry.<a name="line.593"></a>
<span class="sourceLineNo">594</span>        while (true) {<a name="line.594"></a>
<span class="sourceLineNo">595</span>            if ((curr = key[pos = (pos + 1) &amp; mask]) == null)<a name="line.595"></a>
<span class="sourceLineNo">596</span>                return false;<a name="line.596"></a>
<span class="sourceLineNo">597</span>            if (hasher.areEqual(k, curr))<a name="line.597"></a>
<span class="sourceLineNo">598</span>                return true;<a name="line.598"></a>
<span class="sourceLineNo">599</span>        }<a name="line.599"></a>
<span class="sourceLineNo">600</span>    }<a name="line.600"></a>
<span class="sourceLineNo">601</span>    public boolean containsValue(final Object v) {<a name="line.601"></a>
<span class="sourceLineNo">602</span>        final V[] value = this.value;<a name="line.602"></a>
<span class="sourceLineNo">603</span>        final K[] key = this.key;<a name="line.603"></a>
<span class="sourceLineNo">604</span>        if (containsNullKey<a name="line.604"></a>
<span class="sourceLineNo">605</span>                &amp;&amp; (value[n] == null ? v == null : value[n].equals(v)))<a name="line.605"></a>
<span class="sourceLineNo">606</span>            return true;<a name="line.606"></a>
<span class="sourceLineNo">607</span>        for (int i = n; i-- != 0;)<a name="line.607"></a>
<span class="sourceLineNo">608</span>            if (key[i] != null<a name="line.608"></a>
<span class="sourceLineNo">609</span>                    &amp;&amp; (value[i] == null ? v == null : value[i].equals(v)))<a name="line.609"></a>
<span class="sourceLineNo">610</span>                return true;<a name="line.610"></a>
<span class="sourceLineNo">611</span>        return false;<a name="line.611"></a>
<span class="sourceLineNo">612</span>    }<a name="line.612"></a>
<span class="sourceLineNo">613</span>    /*<a name="line.613"></a>
<span class="sourceLineNo">614</span>     * Removes all elements from this map.<a name="line.614"></a>
<span class="sourceLineNo">615</span>     *<a name="line.615"></a>
<span class="sourceLineNo">616</span>     * &lt;P&gt;To increase object reuse, this method does not change the table size.<a name="line.616"></a>
<span class="sourceLineNo">617</span>     * If you want to reduce the table size, you must use {@link #trim()}.<a name="line.617"></a>
<span class="sourceLineNo">618</span>     */<a name="line.618"></a>
<span class="sourceLineNo">619</span>    public void clear() {<a name="line.619"></a>
<span class="sourceLineNo">620</span>        if (size == 0)<a name="line.620"></a>
<span class="sourceLineNo">621</span>            return;<a name="line.621"></a>
<span class="sourceLineNo">622</span>        size = 0;<a name="line.622"></a>
<span class="sourceLineNo">623</span>        containsNullKey = false;<a name="line.623"></a>
<span class="sourceLineNo">624</span>        Arrays.fill(key, null);<a name="line.624"></a>
<span class="sourceLineNo">625</span>        Arrays.fill(value, null);<a name="line.625"></a>
<span class="sourceLineNo">626</span>    }<a name="line.626"></a>
<span class="sourceLineNo">627</span><a name="line.627"></a>
<span class="sourceLineNo">628</span>    public int size() {<a name="line.628"></a>
<span class="sourceLineNo">629</span>        return size;<a name="line.629"></a>
<span class="sourceLineNo">630</span>    }<a name="line.630"></a>
<span class="sourceLineNo">631</span><a name="line.631"></a>
<span class="sourceLineNo">632</span>    public boolean isEmpty() {<a name="line.632"></a>
<span class="sourceLineNo">633</span>        return size == 0;<a name="line.633"></a>
<span class="sourceLineNo">634</span>    }<a name="line.634"></a>
<span class="sourceLineNo">635</span><a name="line.635"></a>
<span class="sourceLineNo">636</span>    /**<a name="line.636"></a>
<span class="sourceLineNo">637</span>     * The entry class for a OrderedMap does not record key and value, but rather the position in the hash table of the corresponding entry. This is necessary so that calls to<a name="line.637"></a>
<span class="sourceLineNo">638</span>     * {@link Entry#setValue(Object)} are reflected in the map<a name="line.638"></a>
<span class="sourceLineNo">639</span>     */<a name="line.639"></a>
<span class="sourceLineNo">640</span>    final class MapEntry implements Entry&lt;K, V&gt; {<a name="line.640"></a>
<span class="sourceLineNo">641</span>        // The table index this entry refers to, or -1 if this entry has been<a name="line.641"></a>
<span class="sourceLineNo">642</span>        // deleted.<a name="line.642"></a>
<span class="sourceLineNo">643</span>        int index;<a name="line.643"></a>
<span class="sourceLineNo">644</span>        MapEntry(final int index) {<a name="line.644"></a>
<span class="sourceLineNo">645</span>            this.index = index;<a name="line.645"></a>
<span class="sourceLineNo">646</span>        }<a name="line.646"></a>
<span class="sourceLineNo">647</span>        MapEntry() {<a name="line.647"></a>
<span class="sourceLineNo">648</span>        }<a name="line.648"></a>
<span class="sourceLineNo">649</span>        public K getKey() {<a name="line.649"></a>
<span class="sourceLineNo">650</span>            return key[index];<a name="line.650"></a>
<span class="sourceLineNo">651</span>        }<a name="line.651"></a>
<span class="sourceLineNo">652</span>        public V getValue() {<a name="line.652"></a>
<span class="sourceLineNo">653</span>            return value[index];<a name="line.653"></a>
<span class="sourceLineNo">654</span>        }<a name="line.654"></a>
<span class="sourceLineNo">655</span>        public V setValue(final V v) {<a name="line.655"></a>
<span class="sourceLineNo">656</span>            final V oldValue = value[index];<a name="line.656"></a>
<span class="sourceLineNo">657</span>            value[index] = v;<a name="line.657"></a>
<span class="sourceLineNo">658</span>            return oldValue;<a name="line.658"></a>
<span class="sourceLineNo">659</span>        }<a name="line.659"></a>
<span class="sourceLineNo">660</span>        @SuppressWarnings("unchecked")<a name="line.660"></a>
<span class="sourceLineNo">661</span>        public boolean equals(final Object o) {<a name="line.661"></a>
<span class="sourceLineNo">662</span>            if (!(o instanceof Map.Entry))<a name="line.662"></a>
<span class="sourceLineNo">663</span>                return false;<a name="line.663"></a>
<span class="sourceLineNo">664</span>            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;<a name="line.664"></a>
<span class="sourceLineNo">665</span>            return (key[index] == null<a name="line.665"></a>
<span class="sourceLineNo">666</span>                    ? e.getKey() == null<a name="line.666"></a>
<span class="sourceLineNo">667</span>                    : hasher.areEqual(key[index], e.getKey()))<a name="line.667"></a>
<span class="sourceLineNo">668</span>                    &amp;&amp; (value[index] == null<a name="line.668"></a>
<span class="sourceLineNo">669</span>                    ? e.getValue() == null<a name="line.669"></a>
<span class="sourceLineNo">670</span>                    : value[index].equals(e.getValue()));<a name="line.670"></a>
<span class="sourceLineNo">671</span>        }<a name="line.671"></a>
<span class="sourceLineNo">672</span>        public int hashCode() {<a name="line.672"></a>
<span class="sourceLineNo">673</span>            return hasher.hash(key[index])<a name="line.673"></a>
<span class="sourceLineNo">674</span>                    ^ (value[index] == null ? 0 : value[index].hashCode());<a name="line.674"></a>
<span class="sourceLineNo">675</span>        }<a name="line.675"></a>
<span class="sourceLineNo">676</span>        @Override<a name="line.676"></a>
<span class="sourceLineNo">677</span>        public String toString() {<a name="line.677"></a>
<span class="sourceLineNo">678</span>            return key[index] + "=&gt;" + value[index];<a name="line.678"></a>
<span class="sourceLineNo">679</span>        }<a name="line.679"></a>
<span class="sourceLineNo">680</span>    }<a name="line.680"></a>
<span class="sourceLineNo">681</span>    <a name="line.681"></a>
<span class="sourceLineNo">682</span>    /**<a name="line.682"></a>
<span class="sourceLineNo">683</span>     * An iterator over a hash map.<a name="line.683"></a>
<span class="sourceLineNo">684</span>     */<a name="line.684"></a>
<span class="sourceLineNo">685</span>    private class MapIterator {<a name="line.685"></a>
<span class="sourceLineNo">686</span>        /**<a name="line.686"></a>
<span class="sourceLineNo">687</span>         * The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last<a name="line.687"></a>
<span class="sourceLineNo">688</span>         * &lt;p&gt;<a name="line.688"></a>
<span class="sourceLineNo">689</span>         * entry returned was that of the key of index {@code - pos - 1} from the {@link #wrapped} list.<a name="line.689"></a>
<span class="sourceLineNo">690</span>         */<a name="line.690"></a>
<span class="sourceLineNo">691</span>        int pos = n;<a name="line.691"></a>
<span class="sourceLineNo">692</span>        /**<a name="line.692"></a>
<span class="sourceLineNo">693</span>         * The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,<a name="line.693"></a>
<span class="sourceLineNo">694</span>         * &lt;p&gt;<a name="line.694"></a>
<span class="sourceLineNo">695</span>         * or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either<a name="line.695"></a>
<span class="sourceLineNo">696</span>         * &lt;p&gt;<a name="line.696"></a>
<span class="sourceLineNo">697</span>         * we did not return an entry yet, or the last returned entry has been removed.<a name="line.697"></a>
<span class="sourceLineNo">698</span>         */<a name="line.698"></a>
<span class="sourceLineNo">699</span>        int last = -1;<a name="line.699"></a>
<span class="sourceLineNo">700</span>        /**<a name="line.700"></a>
<span class="sourceLineNo">701</span>         * A downward counter measuring how many entries must still be returned.<a name="line.701"></a>
<span class="sourceLineNo">702</span>         */<a name="line.702"></a>
<span class="sourceLineNo">703</span>        int c = size;<a name="line.703"></a>
<span class="sourceLineNo">704</span>        /**<a name="line.704"></a>
<span class="sourceLineNo">705</span>         * A boolean telling us whether we should return the entry with the null key.<a name="line.705"></a>
<span class="sourceLineNo">706</span>         */<a name="line.706"></a>
<span class="sourceLineNo">707</span>        boolean mustReturnNullKey = UnorderedMap.this.containsNullKey;<a name="line.707"></a>
<span class="sourceLineNo">708</span>        /**<a name="line.708"></a>
<span class="sourceLineNo">709</span>         * A lazily allocated list containing keys of entries that have wrapped around the table because of removals.<a name="line.709"></a>
<span class="sourceLineNo">710</span>         */<a name="line.710"></a>
<span class="sourceLineNo">711</span>        ArrayList&lt;K&gt; wrapped;<a name="line.711"></a>
<span class="sourceLineNo">712</span><a name="line.712"></a>
<span class="sourceLineNo">713</span>        public boolean hasNext() {<a name="line.713"></a>
<span class="sourceLineNo">714</span>            return c != 0;<a name="line.714"></a>
<span class="sourceLineNo">715</span>        }<a name="line.715"></a>
<span class="sourceLineNo">716</span><a name="line.716"></a>
<span class="sourceLineNo">717</span>        public int nextEntry() {<a name="line.717"></a>
<span class="sourceLineNo">718</span>            if (!hasNext()) throw new NoSuchElementException();<a name="line.718"></a>
<span class="sourceLineNo">719</span>            c--;<a name="line.719"></a>
<span class="sourceLineNo">720</span>            if (mustReturnNullKey) {<a name="line.720"></a>
<span class="sourceLineNo">721</span>                mustReturnNullKey = false;<a name="line.721"></a>
<span class="sourceLineNo">722</span>                return last = n;<a name="line.722"></a>
<span class="sourceLineNo">723</span>            }<a name="line.723"></a>
<span class="sourceLineNo">724</span>            final K[] key = UnorderedMap.this.key;<a name="line.724"></a>
<span class="sourceLineNo">725</span>            for (; ; ) {<a name="line.725"></a>
<span class="sourceLineNo">726</span>                if (--pos &lt; 0) {<a name="line.726"></a>
<span class="sourceLineNo">727</span>                    // We are just enumerating elements from the wrapped list.<a name="line.727"></a>
<span class="sourceLineNo">728</span>                    last = Integer.MIN_VALUE;<a name="line.728"></a>
<span class="sourceLineNo">729</span>                    final K k = wrapped.get(-pos - 1);<a name="line.729"></a>
<span class="sourceLineNo">730</span>                    int p = hasher.hash(k) &amp; mask;<a name="line.730"></a>
<span class="sourceLineNo">731</span>                    while (!(hasher.areEqual(k, key[p]))) p = (p + 1) &amp; mask;<a name="line.731"></a>
<span class="sourceLineNo">732</span>                    return p;<a name="line.732"></a>
<span class="sourceLineNo">733</span>                }<a name="line.733"></a>
<span class="sourceLineNo">734</span>                if (!((key[pos]) == null)) return last = pos;<a name="line.734"></a>
<span class="sourceLineNo">735</span>            }<a name="line.735"></a>
<span class="sourceLineNo">736</span>        }<a name="line.736"></a>
<span class="sourceLineNo">737</span><a name="line.737"></a>
<span class="sourceLineNo">738</span>        /**<a name="line.738"></a>
<span class="sourceLineNo">739</span>         * Shifts left entries with the specified hash code, starting at the specified position,<a name="line.739"></a>
<span class="sourceLineNo">740</span>         * &lt;p&gt;<a name="line.740"></a>
<span class="sourceLineNo">741</span>         * and empties the resulting free entry.<a name="line.741"></a>
<span class="sourceLineNo">742</span>         *<a name="line.742"></a>
<span class="sourceLineNo">743</span>         * @param pos a starting position.<a name="line.743"></a>
<span class="sourceLineNo">744</span>         */<a name="line.744"></a>
<span class="sourceLineNo">745</span>        private final void shiftKeys(int pos) {<a name="line.745"></a>
<span class="sourceLineNo">746</span>            // Shift entries with the same hash.<a name="line.746"></a>
<span class="sourceLineNo">747</span>            int last, slot;<a name="line.747"></a>
<span class="sourceLineNo">748</span>            K curr;<a name="line.748"></a>
<span class="sourceLineNo">749</span>            final K[] key = UnorderedMap.this.key;<a name="line.749"></a>
<span class="sourceLineNo">750</span>            for (; ; ) {<a name="line.750"></a>
<span class="sourceLineNo">751</span>                pos = ((last = pos) + 1) &amp; mask;<a name="line.751"></a>
<span class="sourceLineNo">752</span>                for (; ; ) {<a name="line.752"></a>
<span class="sourceLineNo">753</span>                    if (((curr = key[pos]) == null)) {<a name="line.753"></a>
<span class="sourceLineNo">754</span>                        key[last] = (null);<a name="line.754"></a>
<span class="sourceLineNo">755</span>                        value[last] = null;<a name="line.755"></a>
<span class="sourceLineNo">756</span>                        return;<a name="line.756"></a>
<span class="sourceLineNo">757</span>                    }<a name="line.757"></a>
<span class="sourceLineNo">758</span>                    slot = (hasher.hash(curr)) &amp; mask;<a name="line.758"></a>
<span class="sourceLineNo">759</span>                    if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot &amp;&amp; slot &gt; pos) break;<a name="line.759"></a>
<span class="sourceLineNo">760</span>                    pos = (pos + 1) &amp; mask;<a name="line.760"></a>
<span class="sourceLineNo">761</span>                }<a name="line.761"></a>
<span class="sourceLineNo">762</span>                if (pos &lt; last) { // Wrapped entry.<a name="line.762"></a>
<span class="sourceLineNo">763</span>                    if (wrapped == null) wrapped = new ArrayList&lt;&gt;(2);<a name="line.763"></a>
<span class="sourceLineNo">764</span>                    wrapped.add(key[pos]);<a name="line.764"></a>
<span class="sourceLineNo">765</span>                }<a name="line.765"></a>
<span class="sourceLineNo">766</span>                key[last] = curr;<a name="line.766"></a>
<span class="sourceLineNo">767</span>                value[last] = value[pos];<a name="line.767"></a>
<span class="sourceLineNo">768</span>            }<a name="line.768"></a>
<span class="sourceLineNo">769</span>        }<a name="line.769"></a>
<span class="sourceLineNo">770</span><a name="line.770"></a>
<span class="sourceLineNo">771</span>        public void remove() {<a name="line.771"></a>
<span class="sourceLineNo">772</span>            if (last == -1) throw new IllegalStateException();<a name="line.772"></a>
<span class="sourceLineNo">773</span>            if (last == n) {<a name="line.773"></a>
<span class="sourceLineNo">774</span>                containsNullKey = false;<a name="line.774"></a>
<span class="sourceLineNo">775</span>                key[n] = null;<a name="line.775"></a>
<span class="sourceLineNo">776</span>                value[n] = null;<a name="line.776"></a>
<span class="sourceLineNo">777</span>            } else if (pos &gt;= 0) shiftKeys(last);<a name="line.777"></a>
<span class="sourceLineNo">778</span>            else {<a name="line.778"></a>
<span class="sourceLineNo">779</span>                // We're removing wrapped entries.<a name="line.779"></a>
<span class="sourceLineNo">780</span>                UnorderedMap.this.remove(wrapped.set(-pos - 1, null));<a name="line.780"></a>
<span class="sourceLineNo">781</span>                last = -1; // Note that we must not decrement size<a name="line.781"></a>
<span class="sourceLineNo">782</span>                return;<a name="line.782"></a>
<span class="sourceLineNo">783</span>            }<a name="line.783"></a>
<span class="sourceLineNo">784</span>            size--;<a name="line.784"></a>
<span class="sourceLineNo">785</span>            last = -1; // You can no longer remove this entry.<a name="line.785"></a>
<span class="sourceLineNo">786</span>        }<a name="line.786"></a>
<span class="sourceLineNo">787</span><a name="line.787"></a>
<span class="sourceLineNo">788</span>        public int skip(final int n) {<a name="line.788"></a>
<span class="sourceLineNo">789</span>            int i = n;<a name="line.789"></a>
<span class="sourceLineNo">790</span>            while (i-- != 0 &amp;&amp; hasNext()) nextEntry();<a name="line.790"></a>
<span class="sourceLineNo">791</span>            return n - i - 1;<a name="line.791"></a>
<span class="sourceLineNo">792</span>        }<a name="line.792"></a>
<span class="sourceLineNo">793</span>    }<a name="line.793"></a>
<span class="sourceLineNo">794</span><a name="line.794"></a>
<span class="sourceLineNo">795</span>    private class EntryIterator extends MapIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {<a name="line.795"></a>
<span class="sourceLineNo">796</span>        private MapEntry entry;<a name="line.796"></a>
<span class="sourceLineNo">797</span><a name="line.797"></a>
<span class="sourceLineNo">798</span>        public Map.Entry&lt;K, V&gt; next() {<a name="line.798"></a>
<span class="sourceLineNo">799</span>            return entry = new MapEntry(nextEntry());<a name="line.799"></a>
<span class="sourceLineNo">800</span>        }<a name="line.800"></a>
<span class="sourceLineNo">801</span><a name="line.801"></a>
<span class="sourceLineNo">802</span>        @Override<a name="line.802"></a>
<span class="sourceLineNo">803</span>        public void remove() {<a name="line.803"></a>
<span class="sourceLineNo">804</span>            super.remove();<a name="line.804"></a>
<span class="sourceLineNo">805</span>            entry.index = -1; // You cannot use a deleted entry.<a name="line.805"></a>
<span class="sourceLineNo">806</span>        }<a name="line.806"></a>
<span class="sourceLineNo">807</span>    }<a name="line.807"></a>
<span class="sourceLineNo">808</span><a name="line.808"></a>
<span class="sourceLineNo">809</span>    private final class MapEntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {<a name="line.809"></a>
<span class="sourceLineNo">810</span>        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {<a name="line.810"></a>
<span class="sourceLineNo">811</span>            return new EntryIterator();<a name="line.811"></a>
<span class="sourceLineNo">812</span>        }<a name="line.812"></a>
<span class="sourceLineNo">813</span><a name="line.813"></a>
<span class="sourceLineNo">814</span>        @SuppressWarnings("unchecked")<a name="line.814"></a>
<span class="sourceLineNo">815</span>        public boolean contains(final Object o) {<a name="line.815"></a>
<span class="sourceLineNo">816</span>            if (!(o instanceof Map.Entry)) return false;<a name="line.816"></a>
<span class="sourceLineNo">817</span>            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;<a name="line.817"></a>
<span class="sourceLineNo">818</span>            final K k = ((K) e.getKey());<a name="line.818"></a>
<span class="sourceLineNo">819</span>            final V v = ((V) e.getValue());<a name="line.819"></a>
<span class="sourceLineNo">820</span>            if (hasher.areEqual(k, null))<a name="line.820"></a>
<span class="sourceLineNo">821</span>                return UnorderedMap.this.containsNullKey &amp;&amp; (value[n] == null ? v == null : value[n].equals(v));<a name="line.821"></a>
<span class="sourceLineNo">822</span>            K curr;<a name="line.822"></a>
<span class="sourceLineNo">823</span>            final K[] key = UnorderedMap.this.key;<a name="line.823"></a>
<span class="sourceLineNo">824</span>            int pos;<a name="line.824"></a>
<span class="sourceLineNo">825</span>            // The starting point.<a name="line.825"></a>
<span class="sourceLineNo">826</span>            if (((curr = key[pos = hasher.hash(k) &amp; mask]) == null))<a name="line.826"></a>
<span class="sourceLineNo">827</span>                return false;<a name="line.827"></a>
<span class="sourceLineNo">828</span>            if (hasher.areEqual(k, curr)) return (value[pos] == null ? (v) == null : (value[pos]).equals(v));<a name="line.828"></a>
<span class="sourceLineNo">829</span>            // There's always an unused entry.<a name="line.829"></a>
<span class="sourceLineNo">830</span>            while (true) {<a name="line.830"></a>
<span class="sourceLineNo">831</span>                if (((curr = key[pos = (pos + 1) &amp; mask]) == null)) return false;<a name="line.831"></a>
<span class="sourceLineNo">832</span>                if (hasher.areEqual(k, curr))<a name="line.832"></a>
<span class="sourceLineNo">833</span>                    return (value[pos] == null ? v == null : value[pos].equals(v));<a name="line.833"></a>
<span class="sourceLineNo">834</span>            }<a name="line.834"></a>
<span class="sourceLineNo">835</span>        }<a name="line.835"></a>
<span class="sourceLineNo">836</span><a name="line.836"></a>
<span class="sourceLineNo">837</span>        @SuppressWarnings("unchecked")<a name="line.837"></a>
<span class="sourceLineNo">838</span>        @Override<a name="line.838"></a>
<span class="sourceLineNo">839</span>        public boolean remove(final Object o) {<a name="line.839"></a>
<span class="sourceLineNo">840</span>            if (!(o instanceof Map.Entry)) return false;<a name="line.840"></a>
<span class="sourceLineNo">841</span>            final Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;<a name="line.841"></a>
<span class="sourceLineNo">842</span>            final K k = ((K) e.getKey());<a name="line.842"></a>
<span class="sourceLineNo">843</span>            final V v = ((V) e.getValue());<a name="line.843"></a>
<span class="sourceLineNo">844</span>            if ((hasher.areEqual(k, null))) {<a name="line.844"></a>
<span class="sourceLineNo">845</span>                if (containsNullKey &amp;&amp; ((value[n]) == null ? (v) == null : (value[n]).equals(v))) {<a name="line.845"></a>
<span class="sourceLineNo">846</span>                    removeNullEntry();<a name="line.846"></a>
<span class="sourceLineNo">847</span>                    return true;<a name="line.847"></a>
<span class="sourceLineNo">848</span>                }<a name="line.848"></a>
<span class="sourceLineNo">849</span>                return false;<a name="line.849"></a>
<span class="sourceLineNo">850</span>            }<a name="line.850"></a>
<span class="sourceLineNo">851</span>            K curr;<a name="line.851"></a>
<span class="sourceLineNo">852</span>            final K[] key = UnorderedMap.this.key;<a name="line.852"></a>
<span class="sourceLineNo">853</span>            int pos;<a name="line.853"></a>
<span class="sourceLineNo">854</span>            // The starting point.<a name="line.854"></a>
<span class="sourceLineNo">855</span>            if (((curr = key[pos = hasher.hash(k) &amp; mask]) == null))<a name="line.855"></a>
<span class="sourceLineNo">856</span>                return false;<a name="line.856"></a>
<span class="sourceLineNo">857</span>            if (hasher.areEqual(curr, k)) {<a name="line.857"></a>
<span class="sourceLineNo">858</span>                if (((value[pos]) == null ? (v) == null : (value[pos]).equals(v))) {<a name="line.858"></a>
<span class="sourceLineNo">859</span>                    removeEntry(pos);<a name="line.859"></a>
<span class="sourceLineNo">860</span>                    return true;<a name="line.860"></a>
<span class="sourceLineNo">861</span>                }<a name="line.861"></a>
<span class="sourceLineNo">862</span>                return false;<a name="line.862"></a>
<span class="sourceLineNo">863</span>            }<a name="line.863"></a>
<span class="sourceLineNo">864</span>            while (true) {<a name="line.864"></a>
<span class="sourceLineNo">865</span>                if (((curr = key[pos = (pos + 1) &amp; mask]) == null)) return false;<a name="line.865"></a>
<span class="sourceLineNo">866</span>                if (hasher.areEqual(curr, k)) {<a name="line.866"></a>
<span class="sourceLineNo">867</span>                    if (((value[pos]) == null ? (v) == null : (value[pos]).equals(v))) {<a name="line.867"></a>
<span class="sourceLineNo">868</span>                        removeEntry(pos);<a name="line.868"></a>
<span class="sourceLineNo">869</span>                        return true;<a name="line.869"></a>
<span class="sourceLineNo">870</span>                    }<a name="line.870"></a>
<span class="sourceLineNo">871</span>                }<a name="line.871"></a>
<span class="sourceLineNo">872</span>            }<a name="line.872"></a>
<span class="sourceLineNo">873</span>        }<a name="line.873"></a>
<span class="sourceLineNo">874</span><a name="line.874"></a>
<span class="sourceLineNo">875</span>        public int size() {<a name="line.875"></a>
<span class="sourceLineNo">876</span>            return size;<a name="line.876"></a>
<span class="sourceLineNo">877</span>        }<a name="line.877"></a>
<span class="sourceLineNo">878</span><a name="line.878"></a>
<span class="sourceLineNo">879</span>        public void clear() {<a name="line.879"></a>
<span class="sourceLineNo">880</span>            UnorderedMap.this.clear();<a name="line.880"></a>
<span class="sourceLineNo">881</span>        }<a name="line.881"></a>
<span class="sourceLineNo">882</span>    }<a name="line.882"></a>
<span class="sourceLineNo">883</span><a name="line.883"></a>
<span class="sourceLineNo">884</span>    @Override<a name="line.884"></a>
<span class="sourceLineNo">885</span>    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {<a name="line.885"></a>
<span class="sourceLineNo">886</span>        if (entries == null) entries = new MapEntrySet();<a name="line.886"></a>
<span class="sourceLineNo">887</span>        return entries;<a name="line.887"></a>
<span class="sourceLineNo">888</span>    }<a name="line.888"></a>
<span class="sourceLineNo">889</span><a name="line.889"></a>
<span class="sourceLineNo">890</span><a name="line.890"></a>
<span class="sourceLineNo">891</span>    /**<a name="line.891"></a>
<span class="sourceLineNo">892</span>     * An iterator on keys.<a name="line.892"></a>
<span class="sourceLineNo">893</span>     *<a name="line.893"></a>
<span class="sourceLineNo">894</span>     *<a name="line.894"></a>
<span class="sourceLineNo">895</span>     *<a name="line.895"></a>
<span class="sourceLineNo">896</span>     * &lt;P&gt;We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods<a name="line.896"></a>
<span class="sourceLineNo">897</span>     * &lt;p&gt;<a name="line.897"></a>
<span class="sourceLineNo">898</span>     * (and possibly their type-specific counterparts) so that they return keys<a name="line.898"></a>
<span class="sourceLineNo">899</span>     * &lt;p&gt;<a name="line.899"></a>
<span class="sourceLineNo">900</span>     * instead of entries.<a name="line.900"></a>
<span class="sourceLineNo">901</span>     */<a name="line.901"></a>
<span class="sourceLineNo">902</span>    private final class KeyIterator extends MapIterator implements Iterator&lt;K&gt; {<a name="line.902"></a>
<span class="sourceLineNo">903</span>        public KeyIterator() {<a name="line.903"></a>
<span class="sourceLineNo">904</span>            super();<a name="line.904"></a>
<span class="sourceLineNo">905</span>        }<a name="line.905"></a>
<span class="sourceLineNo">906</span><a name="line.906"></a>
<span class="sourceLineNo">907</span>        public K next() {<a name="line.907"></a>
<span class="sourceLineNo">908</span>            return key[nextEntry()];<a name="line.908"></a>
<span class="sourceLineNo">909</span>        }<a name="line.909"></a>
<span class="sourceLineNo">910</span>    }<a name="line.910"></a>
<span class="sourceLineNo">911</span><a name="line.911"></a>
<span class="sourceLineNo">912</span>    private final class KeySet extends AbstractSet&lt;K&gt; {<a name="line.912"></a>
<span class="sourceLineNo">913</span>        public Iterator&lt;K&gt; iterator() {<a name="line.913"></a>
<span class="sourceLineNo">914</span>            return new KeyIterator();<a name="line.914"></a>
<span class="sourceLineNo">915</span>        }<a name="line.915"></a>
<span class="sourceLineNo">916</span><a name="line.916"></a>
<span class="sourceLineNo">917</span>        public int size() {<a name="line.917"></a>
<span class="sourceLineNo">918</span>            return size;<a name="line.918"></a>
<span class="sourceLineNo">919</span>        }<a name="line.919"></a>
<span class="sourceLineNo">920</span><a name="line.920"></a>
<span class="sourceLineNo">921</span>        public boolean contains(Object k) {<a name="line.921"></a>
<span class="sourceLineNo">922</span>            return containsKey(k);<a name="line.922"></a>
<span class="sourceLineNo">923</span>        }<a name="line.923"></a>
<span class="sourceLineNo">924</span><a name="line.924"></a>
<span class="sourceLineNo">925</span>        public boolean rem(Object k) {<a name="line.925"></a>
<span class="sourceLineNo">926</span>            final int oldSize = size;<a name="line.926"></a>
<span class="sourceLineNo">927</span>            UnorderedMap.this.remove(k);<a name="line.927"></a>
<span class="sourceLineNo">928</span>            return size != oldSize;<a name="line.928"></a>
<span class="sourceLineNo">929</span>        }<a name="line.929"></a>
<span class="sourceLineNo">930</span><a name="line.930"></a>
<span class="sourceLineNo">931</span>        public void clear() {<a name="line.931"></a>
<span class="sourceLineNo">932</span>            UnorderedMap.this.clear();<a name="line.932"></a>
<span class="sourceLineNo">933</span>        }<a name="line.933"></a>
<span class="sourceLineNo">934</span>    }<a name="line.934"></a>
<span class="sourceLineNo">935</span><a name="line.935"></a>
<span class="sourceLineNo">936</span>    public Set&lt;K&gt; keySet() {<a name="line.936"></a>
<span class="sourceLineNo">937</span>        if (keys == null) keys = new KeySet();<a name="line.937"></a>
<span class="sourceLineNo">938</span>        return keys;<a name="line.938"></a>
<span class="sourceLineNo">939</span>    }<a name="line.939"></a>
<span class="sourceLineNo">940</span><a name="line.940"></a>
<span class="sourceLineNo">941</span>    /**<a name="line.941"></a>
<span class="sourceLineNo">942</span>     * An iterator on values.<a name="line.942"></a>
<span class="sourceLineNo">943</span>     * &lt;br&gt;<a name="line.943"></a>
<span class="sourceLineNo">944</span>     * We simply override the {@link java.util.Iterator#next()} method so that it returns values instead of entries.<a name="line.944"></a>
<span class="sourceLineNo">945</span>     */<a name="line.945"></a>
<span class="sourceLineNo">946</span>    private final class ValueIterator extends MapIterator implements Iterator&lt;V&gt; {<a name="line.946"></a>
<span class="sourceLineNo">947</span>        public ValueIterator() {<a name="line.947"></a>
<span class="sourceLineNo">948</span>            super();<a name="line.948"></a>
<span class="sourceLineNo">949</span>        }<a name="line.949"></a>
<span class="sourceLineNo">950</span><a name="line.950"></a>
<span class="sourceLineNo">951</span>        public V next() {<a name="line.951"></a>
<span class="sourceLineNo">952</span>            return value[nextEntry()];<a name="line.952"></a>
<span class="sourceLineNo">953</span>        }<a name="line.953"></a>
<span class="sourceLineNo">954</span>    }<a name="line.954"></a>
<span class="sourceLineNo">955</span><a name="line.955"></a>
<span class="sourceLineNo">956</span>    public final class ValueCollection extends AbstractCollection&lt;V&gt; implements Serializable<a name="line.956"></a>
<span class="sourceLineNo">957</span>    {<a name="line.957"></a>
<span class="sourceLineNo">958</span>        private static final long serialVersionUID = 0L;<a name="line.958"></a>
<span class="sourceLineNo">959</span>        public ValueIterator iterator() {<a name="line.959"></a>
<span class="sourceLineNo">960</span>            return new ValueIterator();<a name="line.960"></a>
<span class="sourceLineNo">961</span>        }<a name="line.961"></a>
<span class="sourceLineNo">962</span>        public int size() {<a name="line.962"></a>
<span class="sourceLineNo">963</span>            return size;<a name="line.963"></a>
<span class="sourceLineNo">964</span>        }<a name="line.964"></a>
<span class="sourceLineNo">965</span>        public boolean contains(Object v) {<a name="line.965"></a>
<span class="sourceLineNo">966</span>            return containsValue(v);<a name="line.966"></a>
<span class="sourceLineNo">967</span>        }<a name="line.967"></a>
<span class="sourceLineNo">968</span>        public void clear() {<a name="line.968"></a>
<span class="sourceLineNo">969</span>            UnorderedMap.this.clear();<a name="line.969"></a>
<span class="sourceLineNo">970</span>        }<a name="line.970"></a>
<span class="sourceLineNo">971</span>    }<a name="line.971"></a>
<span class="sourceLineNo">972</span>    public Collection&lt;V&gt; values() {<a name="line.972"></a>
<span class="sourceLineNo">973</span>        if (values == null) values = new ValueCollection();<a name="line.973"></a>
<span class="sourceLineNo">974</span>        return values;<a name="line.974"></a>
<span class="sourceLineNo">975</span>    }<a name="line.975"></a>
<span class="sourceLineNo">976</span><a name="line.976"></a>
<span class="sourceLineNo">977</span>    public ArrayList&lt;V&gt; valuesAsList()<a name="line.977"></a>
<span class="sourceLineNo">978</span>    {<a name="line.978"></a>
<span class="sourceLineNo">979</span>        ArrayList&lt;V&gt; ls = new ArrayList&lt;&gt;(size);<a name="line.979"></a>
<span class="sourceLineNo">980</span>        ValueIterator vi = new ValueIterator();<a name="line.980"></a>
<span class="sourceLineNo">981</span>        while (vi.hasNext())<a name="line.981"></a>
<span class="sourceLineNo">982</span>            ls.add(vi.next());<a name="line.982"></a>
<span class="sourceLineNo">983</span>        return ls;<a name="line.983"></a>
<span class="sourceLineNo">984</span>    }<a name="line.984"></a>
<span class="sourceLineNo">985</span><a name="line.985"></a>
<span class="sourceLineNo">986</span>    /**<a name="line.986"></a>
<span class="sourceLineNo">987</span>     * Rehashes the map, making the table as small as possible.<a name="line.987"></a>
<span class="sourceLineNo">988</span>     * &lt;p&gt;<a name="line.988"></a>
<span class="sourceLineNo">989</span>     * &lt;P&gt;This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.<a name="line.989"></a>
<span class="sourceLineNo">990</span>     * &lt;p&gt;<a name="line.990"></a>
<span class="sourceLineNo">991</span>     * &lt;P&gt;If the table size is already the minimum possible, this method does nothing.<a name="line.991"></a>
<span class="sourceLineNo">992</span>     *<a name="line.992"></a>
<span class="sourceLineNo">993</span>     * @return true if there was enough memory to trim the map.<a name="line.993"></a>
<span class="sourceLineNo">994</span>     * @see #trim(int)<a name="line.994"></a>
<span class="sourceLineNo">995</span>     */<a name="line.995"></a>
<span class="sourceLineNo">996</span>    public boolean trim() {<a name="line.996"></a>
<span class="sourceLineNo">997</span>        final int l = arraySize(size, f);<a name="line.997"></a>
<span class="sourceLineNo">998</span>        if (l &gt;= n || size &gt; maxFill(l, f)) return true;<a name="line.998"></a>
<span class="sourceLineNo">999</span>        try {<a name="line.999"></a>
<span class="sourceLineNo">1000</span>            rehash(l);<a name="line.1000"></a>
<span class="sourceLineNo">1001</span>        } catch (Exception cantDoIt) {<a name="line.1001"></a>
<span class="sourceLineNo">1002</span>            return false;<a name="line.1002"></a>
<span class="sourceLineNo">1003</span>        }<a name="line.1003"></a>
<span class="sourceLineNo">1004</span>        return true;<a name="line.1004"></a>
<span class="sourceLineNo">1005</span>    }<a name="line.1005"></a>
<span class="sourceLineNo">1006</span><a name="line.1006"></a>
<span class="sourceLineNo">1007</span>    /**<a name="line.1007"></a>
<span class="sourceLineNo">1008</span>     * Rehashes this map if the table is too large.<a name="line.1008"></a>
<span class="sourceLineNo">1009</span>     * &lt;p&gt;<a name="line.1009"></a>
<span class="sourceLineNo">1010</span>     * &lt;P&gt;Let &lt;var&gt;N&lt;/var&gt; be the smallest table size that can hold &lt;code&gt;max(n,{@link #size()})&lt;/code&gt; entries, still satisfying the load factor. If the current table size is smaller than or equal to<a name="line.1010"></a>
<span class="sourceLineNo">1011</span>     * &lt;var&gt;N&lt;/var&gt;, this method does nothing. Otherwise, it rehashes this map in a table of size &lt;var&gt;N&lt;/var&gt;.<a name="line.1011"></a>
<span class="sourceLineNo">1012</span>     * &lt;p&gt;<a name="line.1012"></a>
<span class="sourceLineNo">1013</span>     * &lt;P&gt;This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical<a name="line.1013"></a>
<span class="sourceLineNo">1014</span>     * size to avoid keeping around a very large table just because of a few large transient maps.<a name="line.1014"></a>
<span class="sourceLineNo">1015</span>     *<a name="line.1015"></a>
<span class="sourceLineNo">1016</span>     * @param n the threshold for the trimming.<a name="line.1016"></a>
<span class="sourceLineNo">1017</span>     * @return true if there was enough memory to trim the map.<a name="line.1017"></a>
<span class="sourceLineNo">1018</span>     * @see #trim()<a name="line.1018"></a>
<span class="sourceLineNo">1019</span>     */<a name="line.1019"></a>
<span class="sourceLineNo">1020</span>    public boolean trim(final int n) {<a name="line.1020"></a>
<span class="sourceLineNo">1021</span>        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));<a name="line.1021"></a>
<span class="sourceLineNo">1022</span>        if (l &gt;= n || size &gt; maxFill(l, f)) return true;<a name="line.1022"></a>
<span class="sourceLineNo">1023</span>        try {<a name="line.1023"></a>
<span class="sourceLineNo">1024</span>            rehash(l);<a name="line.1024"></a>
<span class="sourceLineNo">1025</span>        } catch (Exception cantDoIt) {<a name="line.1025"></a>
<span class="sourceLineNo">1026</span>            return false;<a name="line.1026"></a>
<span class="sourceLineNo">1027</span>        }<a name="line.1027"></a>
<span class="sourceLineNo">1028</span>        return true;<a name="line.1028"></a>
<span class="sourceLineNo">1029</span>    }<a name="line.1029"></a>
<span class="sourceLineNo">1030</span><a name="line.1030"></a>
<span class="sourceLineNo">1031</span>    /**<a name="line.1031"></a>
<span class="sourceLineNo">1032</span>     * Rehashes the map.<a name="line.1032"></a>
<span class="sourceLineNo">1033</span>     *<a name="line.1033"></a>
<span class="sourceLineNo">1034</span>     * &lt;P&gt;<a name="line.1034"></a>
<span class="sourceLineNo">1035</span>     * This method implements the basic rehashing strategy, and may be overriden<a name="line.1035"></a>
<span class="sourceLineNo">1036</span>     * by subclasses implementing different rehashing strategies (e.g.,<a name="line.1036"></a>
<span class="sourceLineNo">1037</span>     * disk-based rehashing). However, you should not override this method<a name="line.1037"></a>
<span class="sourceLineNo">1038</span>     * unless you understand the internal workings of this class.<a name="line.1038"></a>
<span class="sourceLineNo">1039</span>     *<a name="line.1039"></a>
<span class="sourceLineNo">1040</span>     * @param newN<a name="line.1040"></a>
<span class="sourceLineNo">1041</span>     *            the new size<a name="line.1041"></a>
<span class="sourceLineNo">1042</span>     */<a name="line.1042"></a>
<span class="sourceLineNo">1043</span><a name="line.1043"></a>
<span class="sourceLineNo">1044</span>    @SuppressWarnings("unchecked")<a name="line.1044"></a>
<span class="sourceLineNo">1045</span>    protected void rehash(final int newN) {<a name="line.1045"></a>
<span class="sourceLineNo">1046</span>        final K[] key = this.key;<a name="line.1046"></a>
<span class="sourceLineNo">1047</span>        final V[] value = this.value;<a name="line.1047"></a>
<span class="sourceLineNo">1048</span>        final int mask = newN - 1; // Note that this is used by the hashing macro<a name="line.1048"></a>
<span class="sourceLineNo">1049</span>        final K[] newKey = (K[]) new Object[newN + 1];<a name="line.1049"></a>
<span class="sourceLineNo">1050</span>        final V[] newValue = (V[]) new Object[newN + 1];<a name="line.1050"></a>
<span class="sourceLineNo">1051</span><a name="line.1051"></a>
<span class="sourceLineNo">1052</span>        int i = n, pos;<a name="line.1052"></a>
<span class="sourceLineNo">1053</span>        for (int j = realSize(); j-- != 0; ) {<a name="line.1053"></a>
<span class="sourceLineNo">1054</span>            while (((key[--i]) == null)) ;<a name="line.1054"></a>
<span class="sourceLineNo">1055</span>            if (!((newKey[pos = hasher.hash(key[i]) &amp; mask]) == null))<a name="line.1055"></a>
<span class="sourceLineNo">1056</span>                while (!((newKey[pos = (pos + 1) &amp; mask]) == null)) ;<a name="line.1056"></a>
<span class="sourceLineNo">1057</span>            newKey[pos] = key[i];<a name="line.1057"></a>
<span class="sourceLineNo">1058</span>            newValue[pos] = value[i];<a name="line.1058"></a>
<span class="sourceLineNo">1059</span>        }<a name="line.1059"></a>
<span class="sourceLineNo">1060</span>        newValue[newN] = value[n];<a name="line.1060"></a>
<span class="sourceLineNo">1061</span>        n = newN;<a name="line.1061"></a>
<span class="sourceLineNo">1062</span>        this.mask = mask;<a name="line.1062"></a>
<span class="sourceLineNo">1063</span>        maxFill = maxFill(n, f);<a name="line.1063"></a>
<span class="sourceLineNo">1064</span>        this.key = newKey;<a name="line.1064"></a>
<span class="sourceLineNo">1065</span>        this.value = newValue;<a name="line.1065"></a>
<span class="sourceLineNo">1066</span>    }<a name="line.1066"></a>
<span class="sourceLineNo">1067</span>    /*<a name="line.1067"></a>
<span class="sourceLineNo">1068</span>    @SuppressWarnings("unchecked")<a name="line.1068"></a>
<span class="sourceLineNo">1069</span>    protected void rehash(final int newN) {<a name="line.1069"></a>
<span class="sourceLineNo">1070</span>        final K key[] = this.key;<a name="line.1070"></a>
<span class="sourceLineNo">1071</span>        final V value[] = this.value;<a name="line.1071"></a>
<span class="sourceLineNo">1072</span>        final int mask = newN - 1; // Note that this is used by the hashing<a name="line.1072"></a>
<span class="sourceLineNo">1073</span>        // macro<a name="line.1073"></a>
<span class="sourceLineNo">1074</span>        final K newKey[] = (K[]) new Object[newN + 1];<a name="line.1074"></a>
<span class="sourceLineNo">1075</span>        final V newValue[] = (V[]) new Object[newN + 1];<a name="line.1075"></a>
<span class="sourceLineNo">1076</span>        int i = first, prev = -1, newPrev = -1, t, pos;<a name="line.1076"></a>
<span class="sourceLineNo">1077</span>        final long link[] = this.link;<a name="line.1077"></a>
<span class="sourceLineNo">1078</span>        final long newLink[] = new long[newN + 1];<a name="line.1078"></a>
<span class="sourceLineNo">1079</span>        first = -1;<a name="line.1079"></a>
<span class="sourceLineNo">1080</span>        for (int j = size; j-- != 0;) {<a name="line.1080"></a>
<span class="sourceLineNo">1081</span>            if (((key[i]) == null))<a name="line.1081"></a>
<span class="sourceLineNo">1082</span>                pos = newN;<a name="line.1082"></a>
<span class="sourceLineNo">1083</span>            else {<a name="line.1083"></a>
<span class="sourceLineNo">1084</span>                pos = (((key[i]).hashCode())) &amp; mask;<a name="line.1084"></a>
<span class="sourceLineNo">1085</span>                while (!((newKey[pos]) == null))<a name="line.1085"></a>
<span class="sourceLineNo">1086</span>                    pos = (pos + 1) &amp; mask;<a name="line.1086"></a>
<span class="sourceLineNo">1087</span>            }<a name="line.1087"></a>
<span class="sourceLineNo">1088</span>            newKey[pos] = key[i];<a name="line.1088"></a>
<span class="sourceLineNo">1089</span>            newValue[pos] = value[i];<a name="line.1089"></a>
<span class="sourceLineNo">1090</span>            if (prev != -1) {<a name="line.1090"></a>
<span class="sourceLineNo">1091</span>                newLink[newPrev] ^= ((newLink[newPrev] ^ (pos &amp; 0xFFFFFFFFL)) &amp; 0xFFFFFFFFL);<a name="line.1091"></a>
<span class="sourceLineNo">1092</span>                newLink[pos] ^= ((newLink[pos] ^ ((newPrev &amp; 0xFFFFFFFFL) &lt;&lt; 32)) &amp; 0xFFFFFFFF00000000L);<a name="line.1092"></a>
<span class="sourceLineNo">1093</span>                newPrev = pos;<a name="line.1093"></a>
<span class="sourceLineNo">1094</span>            } else {<a name="line.1094"></a>
<span class="sourceLineNo">1095</span>                newPrev = first = pos;<a name="line.1095"></a>
<span class="sourceLineNo">1096</span>                // Special case of SET(newLink[ pos ], -1, -1);<a name="line.1096"></a>
<span class="sourceLineNo">1097</span>                newLink[pos] = -1L;<a name="line.1097"></a>
<span class="sourceLineNo">1098</span>            }<a name="line.1098"></a>
<span class="sourceLineNo">1099</span>            t = i;<a name="line.1099"></a>
<span class="sourceLineNo">1100</span>            i = (int) link[i];<a name="line.1100"></a>
<span class="sourceLineNo">1101</span>            prev = t;<a name="line.1101"></a>
<span class="sourceLineNo">1102</span>        }<a name="line.1102"></a>
<span class="sourceLineNo">1103</span>        this.link = newLink;<a name="line.1103"></a>
<span class="sourceLineNo">1104</span>        this.last = newPrev;<a name="line.1104"></a>
<span class="sourceLineNo">1105</span>        if (newPrev != -1)<a name="line.1105"></a>
<span class="sourceLineNo">1106</span>            // Special case of SET_NEXT( newLink[ newPrev ], -1 );<a name="line.1106"></a>
<span class="sourceLineNo">1107</span>            newLink[newPrev] |= -1 &amp; 0xFFFFFFFFL;<a name="line.1107"></a>
<span class="sourceLineNo">1108</span>        n = newN;<a name="line.1108"></a>
<span class="sourceLineNo">1109</span>        this.mask = mask;<a name="line.1109"></a>
<span class="sourceLineNo">1110</span>        maxFill = maxFill(n, f);<a name="line.1110"></a>
<span class="sourceLineNo">1111</span>        this.key = newKey;<a name="line.1111"></a>
<span class="sourceLineNo">1112</span>        this.value = newValue;<a name="line.1112"></a>
<span class="sourceLineNo">1113</span>    }<a name="line.1113"></a>
<span class="sourceLineNo">1114</span>    */<a name="line.1114"></a>
<span class="sourceLineNo">1115</span>    /**<a name="line.1115"></a>
<span class="sourceLineNo">1116</span>     * Returns a deep copy of this map.<a name="line.1116"></a>
<span class="sourceLineNo">1117</span>     *<a name="line.1117"></a>
<span class="sourceLineNo">1118</span>     * &lt;P&gt;<a name="line.1118"></a>
<span class="sourceLineNo">1119</span>     * This method performs a deep copy of this OrderedMap; the data stored in the<a name="line.1119"></a>
<span class="sourceLineNo">1120</span>     * map, however, is not cloned. Note that this makes a difference only for<a name="line.1120"></a>
<span class="sourceLineNo">1121</span>     * object keys.<a name="line.1121"></a>
<span class="sourceLineNo">1122</span>     *<a name="line.1122"></a>
<span class="sourceLineNo">1123</span>     * @return a deep copy of this map.<a name="line.1123"></a>
<span class="sourceLineNo">1124</span>     */<a name="line.1124"></a>
<span class="sourceLineNo">1125</span>    @SuppressWarnings("unchecked")<a name="line.1125"></a>
<span class="sourceLineNo">1126</span>    @GwtIncompatible<a name="line.1126"></a>
<span class="sourceLineNo">1127</span>    public UnorderedMap&lt;K, V&gt; clone() {<a name="line.1127"></a>
<span class="sourceLineNo">1128</span>        UnorderedMap&lt;K, V&gt; c;<a name="line.1128"></a>
<span class="sourceLineNo">1129</span>        try {<a name="line.1129"></a>
<span class="sourceLineNo">1130</span>            c = new UnorderedMap&lt;&gt;(hasher);<a name="line.1130"></a>
<span class="sourceLineNo">1131</span>            c.key = (K[]) new Object[n + 1];<a name="line.1131"></a>
<span class="sourceLineNo">1132</span>            System.arraycopy(key, 0, c.key, 0, n + 1);<a name="line.1132"></a>
<span class="sourceLineNo">1133</span>            c.value = (V[]) new Object[n + 1];<a name="line.1133"></a>
<span class="sourceLineNo">1134</span>            System.arraycopy(value, 0, c.value, 0, n + 1);<a name="line.1134"></a>
<span class="sourceLineNo">1135</span>            return c;<a name="line.1135"></a>
<span class="sourceLineNo">1136</span>        } catch (Exception cantHappen) {<a name="line.1136"></a>
<span class="sourceLineNo">1137</span>            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?<a name="line.1137"></a>
<span class="sourceLineNo">1138</span>                    "; " + cantHappen.getMessage() : ""));<a name="line.1138"></a>
<span class="sourceLineNo">1139</span>        }<a name="line.1139"></a>
<span class="sourceLineNo">1140</span>    }<a name="line.1140"></a>
<span class="sourceLineNo">1141</span>    /**<a name="line.1141"></a>
<span class="sourceLineNo">1142</span>     * Returns a hash code for this map.<a name="line.1142"></a>
<span class="sourceLineNo">1143</span>     *<a name="line.1143"></a>
<span class="sourceLineNo">1144</span>     * This method overrides the generic method provided by the superclass.<a name="line.1144"></a>
<span class="sourceLineNo">1145</span>     * Since &lt;code&gt;equals()&lt;/code&gt; is not overriden, it is important that the<a name="line.1145"></a>
<span class="sourceLineNo">1146</span>     * value returned by this method is the same value as the one returned by<a name="line.1146"></a>
<span class="sourceLineNo">1147</span>     * the overriden method.<a name="line.1147"></a>
<span class="sourceLineNo">1148</span>     *<a name="line.1148"></a>
<span class="sourceLineNo">1149</span>     * @return a hash code for this map.<a name="line.1149"></a>
<span class="sourceLineNo">1150</span>     */<a name="line.1150"></a>
<span class="sourceLineNo">1151</span>    public int hashCode() {<a name="line.1151"></a>
<span class="sourceLineNo">1152</span>        int h = 0;<a name="line.1152"></a>
<span class="sourceLineNo">1153</span>        for (int j = realSize(), i = 0, t = 0; j-- != 0;) {<a name="line.1153"></a>
<span class="sourceLineNo">1154</span>            while (key[i] == null)<a name="line.1154"></a>
<span class="sourceLineNo">1155</span>                i++;<a name="line.1155"></a>
<span class="sourceLineNo">1156</span>            if (this != key[i])<a name="line.1156"></a>
<span class="sourceLineNo">1157</span>                t = hasher.hash(key[i]);<a name="line.1157"></a>
<span class="sourceLineNo">1158</span>            if (this != value[i])<a name="line.1158"></a>
<span class="sourceLineNo">1159</span>                t ^= value[i] == null ? 0 : value[i].hashCode();<a name="line.1159"></a>
<span class="sourceLineNo">1160</span>            h += t;<a name="line.1160"></a>
<span class="sourceLineNo">1161</span>            i++;<a name="line.1161"></a>
<span class="sourceLineNo">1162</span>        }<a name="line.1162"></a>
<span class="sourceLineNo">1163</span>        // Zero / null keys have hash zero.<a name="line.1163"></a>
<span class="sourceLineNo">1164</span>        if (containsNullKey)<a name="line.1164"></a>
<span class="sourceLineNo">1165</span>            h += value[n] == null ? 0 : value[n].hashCode();<a name="line.1165"></a>
<span class="sourceLineNo">1166</span>        return h;<a name="line.1166"></a>
<span class="sourceLineNo">1167</span>    }<a name="line.1167"></a>
<span class="sourceLineNo">1168</span><a name="line.1168"></a>
<span class="sourceLineNo">1169</span>    public long hash64()<a name="line.1169"></a>
<span class="sourceLineNo">1170</span>    {<a name="line.1170"></a>
<span class="sourceLineNo">1171</span>        return 31L * (31L * CrossHash.hash64(key) + CrossHash.hash64(value)) + size;<a name="line.1171"></a>
<span class="sourceLineNo">1172</span>    }<a name="line.1172"></a>
<span class="sourceLineNo">1173</span>    /**<a name="line.1173"></a>
<span class="sourceLineNo">1174</span>     * Returns the maximum number of entries that can be filled before rehashing.<a name="line.1174"></a>
<span class="sourceLineNo">1175</span>     *<a name="line.1175"></a>
<span class="sourceLineNo">1176</span>     * @param n the size of the backing array.<a name="line.1176"></a>
<span class="sourceLineNo">1177</span>     * @param f the load factor.<a name="line.1177"></a>
<span class="sourceLineNo">1178</span>     * @return the maximum number of entries before rehashing.<a name="line.1178"></a>
<span class="sourceLineNo">1179</span>     */<a name="line.1179"></a>
<span class="sourceLineNo">1180</span>    public static int maxFill(final int n, final float f) {<a name="line.1180"></a>
<span class="sourceLineNo">1181</span>        /* We must guarantee that there is always at least<a name="line.1181"></a>
<span class="sourceLineNo">1182</span>                 * one free entry (even with pathological load factors). */<a name="line.1182"></a>
<span class="sourceLineNo">1183</span>        return Math.min((int)(n * f + 0.99999994f), n - 1);<a name="line.1183"></a>
<span class="sourceLineNo">1184</span>    }<a name="line.1184"></a>
<span class="sourceLineNo">1185</span><a name="line.1185"></a>
<span class="sourceLineNo">1186</span>    /**<a name="line.1186"></a>
<span class="sourceLineNo">1187</span>     * Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt; and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.<a name="line.1187"></a>
<span class="sourceLineNo">1188</span>     *re<a name="line.1188"></a>
<span class="sourceLineNo">1189</span>     * @param expected the expected number of elements in a hash table.<a name="line.1189"></a>
<span class="sourceLineNo">1190</span>     * @param f        the load factor.<a name="line.1190"></a>
<span class="sourceLineNo">1191</span>     * @return the minimum possible size for a backing array.<a name="line.1191"></a>
<span class="sourceLineNo">1192</span>     * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.<a name="line.1192"></a>
<span class="sourceLineNo">1193</span>     */<a name="line.1193"></a>
<span class="sourceLineNo">1194</span>    public static int arraySize(final int expected, final float f) {<a name="line.1194"></a>
<span class="sourceLineNo">1195</span>        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));<a name="line.1195"></a>
<span class="sourceLineNo">1196</span>        if (s &gt; (1 &lt;&lt; 30))<a name="line.1196"></a>
<span class="sourceLineNo">1197</span>            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");<a name="line.1197"></a>
<span class="sourceLineNo">1198</span>        return (int) s;<a name="line.1198"></a>
<span class="sourceLineNo">1199</span>    }<a name="line.1199"></a>
<span class="sourceLineNo">1200</span><a name="line.1200"></a>
<span class="sourceLineNo">1201</span>    /**<a name="line.1201"></a>
<span class="sourceLineNo">1202</span>     * Unwraps an iterator into an array starting at a given offset for a given number of elements.<a name="line.1202"></a>
<span class="sourceLineNo">1203</span>     * &lt;p&gt;<a name="line.1203"></a>
<span class="sourceLineNo">1204</span>     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The<a name="line.1204"></a>
<span class="sourceLineNo">1205</span>     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).<a name="line.1205"></a>
<span class="sourceLineNo">1206</span>     *<a name="line.1206"></a>
<span class="sourceLineNo">1207</span>     * @param i      a type-specific iterator.<a name="line.1207"></a>
<span class="sourceLineNo">1208</span>     * @param array  an array to contain the output of the iterator.<a name="line.1208"></a>
<span class="sourceLineNo">1209</span>     * @param offset the first element of the array to be returned.<a name="line.1209"></a>
<span class="sourceLineNo">1210</span>     * @param max    the maximum number of elements to unwrap.<a name="line.1210"></a>
<span class="sourceLineNo">1211</span>     * @return the number of elements unwrapped.<a name="line.1211"></a>
<span class="sourceLineNo">1212</span>     */<a name="line.1212"></a>
<span class="sourceLineNo">1213</span>    private int unwrap(final ValueIterator i, final Object[] array, int offset, final int max) {<a name="line.1213"></a>
<span class="sourceLineNo">1214</span>        if (max &lt; 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");<a name="line.1214"></a>
<span class="sourceLineNo">1215</span>        if (offset &lt; 0 || offset + max &gt; array.length) throw new IllegalArgumentException();<a name="line.1215"></a>
<span class="sourceLineNo">1216</span>        int j = max;<a name="line.1216"></a>
<span class="sourceLineNo">1217</span>        while (j-- != 0 &amp;&amp; i.hasNext())<a name="line.1217"></a>
<span class="sourceLineNo">1218</span>            array[offset++] = i.next();<a name="line.1218"></a>
<span class="sourceLineNo">1219</span>        return max - j - 1;<a name="line.1219"></a>
<span class="sourceLineNo">1220</span>    }<a name="line.1220"></a>
<span class="sourceLineNo">1221</span><a name="line.1221"></a>
<span class="sourceLineNo">1222</span>    /**<a name="line.1222"></a>
<span class="sourceLineNo">1223</span>     * Unwraps an iterator into an array.<a name="line.1223"></a>
<span class="sourceLineNo">1224</span>     * &lt;p&gt;<a name="line.1224"></a>
<span class="sourceLineNo">1225</span>     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end<a name="line.1225"></a>
<span class="sourceLineNo">1226</span>     * of the array has been reached.<a name="line.1226"></a>
<span class="sourceLineNo">1227</span>     *<a name="line.1227"></a>
<span class="sourceLineNo">1228</span>     * @param i     a type-specific iterator.<a name="line.1228"></a>
<span class="sourceLineNo">1229</span>     * @param array an array to contain the output of the iterator.<a name="line.1229"></a>
<span class="sourceLineNo">1230</span>     * @return the number of elements unwrapped.<a name="line.1230"></a>
<span class="sourceLineNo">1231</span>     */<a name="line.1231"></a>
<span class="sourceLineNo">1232</span>    private int unwrap(final ValueIterator i, final Object[] array) {<a name="line.1232"></a>
<span class="sourceLineNo">1233</span>        return unwrap(i, array, 0, array.length);<a name="line.1233"></a>
<span class="sourceLineNo">1234</span>    }<a name="line.1234"></a>
<span class="sourceLineNo">1235</span><a name="line.1235"></a>
<span class="sourceLineNo">1236</span><a name="line.1236"></a>
<span class="sourceLineNo">1237</span>    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.<a name="line.1237"></a>
<span class="sourceLineNo">1238</span>     *<a name="line.1238"></a>
<span class="sourceLineNo">1239</span>     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of &lt;code&gt;length&lt;/code&gt;, in the given array starting at &lt;code&gt;offset&lt;/code&gt;. The<a name="line.1239"></a>
<span class="sourceLineNo">1240</span>     * number of actually unwrapped elements is returned (it may be less than &lt;code&gt;max&lt;/code&gt; if the iterator emits less than &lt;code&gt;max&lt;/code&gt; elements).<a name="line.1240"></a>
<span class="sourceLineNo">1241</span>     *<a name="line.1241"></a>
<span class="sourceLineNo">1242</span>     * @param i a type-specific iterator.<a name="line.1242"></a>
<span class="sourceLineNo">1243</span>     * @param array an array to contain the output of the iterator.<a name="line.1243"></a>
<span class="sourceLineNo">1244</span>     * @param offset the first element of the array to be returned.<a name="line.1244"></a>
<span class="sourceLineNo">1245</span>     * @param max the maximum number of elements to unwrap.<a name="line.1245"></a>
<span class="sourceLineNo">1246</span>     * @return the number of elements unwrapped. */<a name="line.1246"></a>
<span class="sourceLineNo">1247</span>    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array, int offset, final int max ) {<a name="line.1247"></a>
<span class="sourceLineNo">1248</span>        if ( max &lt; 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );<a name="line.1248"></a>
<span class="sourceLineNo">1249</span>        if ( offset &lt; 0 || offset + max &gt; array.length ) throw new IllegalArgumentException();<a name="line.1249"></a>
<span class="sourceLineNo">1250</span>        int j = max;<a name="line.1250"></a>
<span class="sourceLineNo">1251</span>        while ( j-- != 0 &amp;&amp; i.hasNext() )<a name="line.1251"></a>
<span class="sourceLineNo">1252</span>            array[ offset++ ] = i.next();<a name="line.1252"></a>
<span class="sourceLineNo">1253</span>        return max - j - 1;<a name="line.1253"></a>
<span class="sourceLineNo">1254</span>    }<a name="line.1254"></a>
<span class="sourceLineNo">1255</span><a name="line.1255"></a>
<span class="sourceLineNo">1256</span>    /** Unwraps an iterator into an array.<a name="line.1256"></a>
<span class="sourceLineNo">1257</span>     *<a name="line.1257"></a>
<span class="sourceLineNo">1258</span>     * &lt;P&gt;This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end<a name="line.1258"></a>
<span class="sourceLineNo">1259</span>     * of the array has been reached.<a name="line.1259"></a>
<span class="sourceLineNo">1260</span>     *<a name="line.1260"></a>
<span class="sourceLineNo">1261</span>     * @param i a type-specific iterator.<a name="line.1261"></a>
<span class="sourceLineNo">1262</span>     * @param array an array to contain the output of the iterator.<a name="line.1262"></a>
<span class="sourceLineNo">1263</span>     * @return the number of elements unwrapped. */<a name="line.1263"></a>
<span class="sourceLineNo">1264</span>    private static &lt;K&gt; int objectUnwrap(final Iterator&lt;? extends K&gt; i, final K[] array) {<a name="line.1264"></a>
<span class="sourceLineNo">1265</span>        return objectUnwrap(i, array, 0, array.length );<a name="line.1265"></a>
<span class="sourceLineNo">1266</span>    }<a name="line.1266"></a>
<span class="sourceLineNo">1267</span><a name="line.1267"></a>
<span class="sourceLineNo">1268</span>    @Override<a name="line.1268"></a>
<span class="sourceLineNo">1269</span>    public String toString() {<a name="line.1269"></a>
<span class="sourceLineNo">1270</span>        final StringBuilder s = new StringBuilder();<a name="line.1270"></a>
<span class="sourceLineNo">1271</span>        final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = entrySet().iterator();<a name="line.1271"></a>
<span class="sourceLineNo">1272</span>        int n = size();<a name="line.1272"></a>
<span class="sourceLineNo">1273</span>        Map.Entry &lt;K,V&gt; e;<a name="line.1273"></a>
<span class="sourceLineNo">1274</span>        boolean first = true;<a name="line.1274"></a>
<span class="sourceLineNo">1275</span>        s.append("UnorderedMap {");<a name="line.1275"></a>
<span class="sourceLineNo">1276</span>        while(n-- != 0) {<a name="line.1276"></a>
<span class="sourceLineNo">1277</span>            if (first) first = false;<a name="line.1277"></a>
<span class="sourceLineNo">1278</span>            else s.append(", ");<a name="line.1278"></a>
<span class="sourceLineNo">1279</span>            e = i.next();<a name="line.1279"></a>
<span class="sourceLineNo">1280</span>            if (this == e.getKey()) s.append("(this map)"); else<a name="line.1280"></a>
<span class="sourceLineNo">1281</span>                s.append(String.valueOf(e.getKey()));<a name="line.1281"></a>
<span class="sourceLineNo">1282</span>            s.append("=&gt;");<a name="line.1282"></a>
<span class="sourceLineNo">1283</span>            if (this == e.getValue()) s.append("(this map)"); else<a name="line.1283"></a>
<span class="sourceLineNo">1284</span>                s.append(String.valueOf(e.getValue()));<a name="line.1284"></a>
<span class="sourceLineNo">1285</span>        }<a name="line.1285"></a>
<span class="sourceLineNo">1286</span>        s.append("}");<a name="line.1286"></a>
<span class="sourceLineNo">1287</span>        return s.toString();<a name="line.1287"></a>
<span class="sourceLineNo">1288</span>    }<a name="line.1288"></a>
<span class="sourceLineNo">1289</span>    @Override<a name="line.1289"></a>
<span class="sourceLineNo">1290</span>    public boolean equals(Object o) {<a name="line.1290"></a>
<span class="sourceLineNo">1291</span>        if (o == this)<a name="line.1291"></a>
<span class="sourceLineNo">1292</span>            return true;<a name="line.1292"></a>
<span class="sourceLineNo">1293</span>        if (!(o instanceof Map))<a name="line.1293"></a>
<span class="sourceLineNo">1294</span>            return false;<a name="line.1294"></a>
<span class="sourceLineNo">1295</span>        Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;) o;<a name="line.1295"></a>
<span class="sourceLineNo">1296</span>        if (m.size() != size())<a name="line.1296"></a>
<span class="sourceLineNo">1297</span>            return false;<a name="line.1297"></a>
<span class="sourceLineNo">1298</span>        return entrySet().containsAll(m.entrySet());<a name="line.1298"></a>
<span class="sourceLineNo">1299</span>    }<a name="line.1299"></a>
<span class="sourceLineNo">1300</span><a name="line.1300"></a>
<span class="sourceLineNo">1301</span>    @GwtIncompatible<a name="line.1301"></a>
<span class="sourceLineNo">1302</span>    private void writeObject(java.io.ObjectOutputStream s)<a name="line.1302"></a>
<span class="sourceLineNo">1303</span>            throws java.io.IOException {<a name="line.1303"></a>
<span class="sourceLineNo">1304</span>        final K[] key = this.key;<a name="line.1304"></a>
<span class="sourceLineNo">1305</span>        final V[] value = this.value;<a name="line.1305"></a>
<span class="sourceLineNo">1306</span>        final MapIterator i = new MapIterator();<a name="line.1306"></a>
<span class="sourceLineNo">1307</span>        s.defaultWriteObject();<a name="line.1307"></a>
<span class="sourceLineNo">1308</span>        for (int j = size, e; j-- != 0;) {<a name="line.1308"></a>
<span class="sourceLineNo">1309</span>            e = i.nextEntry();<a name="line.1309"></a>
<span class="sourceLineNo">1310</span>            s.writeObject(key[e]);<a name="line.1310"></a>
<span class="sourceLineNo">1311</span>            s.writeObject(value[e]);<a name="line.1311"></a>
<span class="sourceLineNo">1312</span>        }<a name="line.1312"></a>
<span class="sourceLineNo">1313</span>    }<a name="line.1313"></a>
<span class="sourceLineNo">1314</span>    @GwtIncompatible<a name="line.1314"></a>
<span class="sourceLineNo">1315</span>    @SuppressWarnings("unchecked")<a name="line.1315"></a>
<span class="sourceLineNo">1316</span>    private void readObject(java.io.ObjectInputStream s)<a name="line.1316"></a>
<span class="sourceLineNo">1317</span>            throws java.io.IOException, ClassNotFoundException {<a name="line.1317"></a>
<span class="sourceLineNo">1318</span>        s.defaultReadObject();<a name="line.1318"></a>
<span class="sourceLineNo">1319</span>        n = arraySize(size, f);<a name="line.1319"></a>
<span class="sourceLineNo">1320</span>        maxFill = maxFill(n, f);<a name="line.1320"></a>
<span class="sourceLineNo">1321</span>        mask = n - 1;<a name="line.1321"></a>
<span class="sourceLineNo">1322</span>        final K[] key = this.key = (K[]) new Object[n + 1];<a name="line.1322"></a>
<span class="sourceLineNo">1323</span>        final V[] value = this.value = (V[]) new Object[n + 1];<a name="line.1323"></a>
<span class="sourceLineNo">1324</span>        K k;<a name="line.1324"></a>
<span class="sourceLineNo">1325</span>        V v;<a name="line.1325"></a>
<span class="sourceLineNo">1326</span>        for (int i = size, pos; i-- != 0;) {<a name="line.1326"></a>
<span class="sourceLineNo">1327</span>            k = (K) s.readObject();<a name="line.1327"></a>
<span class="sourceLineNo">1328</span>            v = (V) s.readObject();<a name="line.1328"></a>
<span class="sourceLineNo">1329</span>            if (k == null) {<a name="line.1329"></a>
<span class="sourceLineNo">1330</span>                pos = n;<a name="line.1330"></a>
<span class="sourceLineNo">1331</span>                containsNullKey = true;<a name="line.1331"></a>
<span class="sourceLineNo">1332</span>            } else {<a name="line.1332"></a>
<span class="sourceLineNo">1333</span>                pos = (hasher.hash(k))<a name="line.1333"></a>
<span class="sourceLineNo">1334</span>                        &amp; mask;<a name="line.1334"></a>
<span class="sourceLineNo">1335</span>                while (key[pos] != null)<a name="line.1335"></a>
<span class="sourceLineNo">1336</span>                    pos = (pos + 1) &amp; mask;<a name="line.1336"></a>
<span class="sourceLineNo">1337</span>            }<a name="line.1337"></a>
<span class="sourceLineNo">1338</span><a name="line.1338"></a>
<span class="sourceLineNo">1339</span>            key[pos] = k;<a name="line.1339"></a>
<span class="sourceLineNo">1340</span>            value[pos] = v;<a name="line.1340"></a>
<span class="sourceLineNo">1341</span>        }<a name="line.1341"></a>
<span class="sourceLineNo">1342</span>    }<a name="line.1342"></a>
<span class="sourceLineNo">1343</span><a name="line.1343"></a>
<span class="sourceLineNo">1344</span>    public List&lt;V&gt; getMany(Collection&lt;K&gt; keys)<a name="line.1344"></a>
<span class="sourceLineNo">1345</span>    {<a name="line.1345"></a>
<span class="sourceLineNo">1346</span>        if(keys == null)<a name="line.1346"></a>
<span class="sourceLineNo">1347</span>            return new ArrayList&lt;&gt;(1);<a name="line.1347"></a>
<span class="sourceLineNo">1348</span>        ArrayList&lt;V&gt; vals = new ArrayList&lt;&gt;(keys.size());<a name="line.1348"></a>
<span class="sourceLineNo">1349</span>        for(K k : keys)<a name="line.1349"></a>
<span class="sourceLineNo">1350</span>        {<a name="line.1350"></a>
<span class="sourceLineNo">1351</span>            vals.add(get(k));<a name="line.1351"></a>
<span class="sourceLineNo">1352</span>        }<a name="line.1352"></a>
<span class="sourceLineNo">1353</span>        return vals;<a name="line.1353"></a>
<span class="sourceLineNo">1354</span>    }<a name="line.1354"></a>
<span class="sourceLineNo">1355</span>    <a name="line.1355"></a>
<span class="sourceLineNo">1356</span>    /**<a name="line.1356"></a>
<span class="sourceLineNo">1357</span>     * If the specified key is not already associated with a value (or is mapped<a name="line.1357"></a>
<span class="sourceLineNo">1358</span>     * to {@code null}) associates it with the given value and returns<a name="line.1358"></a>
<span class="sourceLineNo">1359</span>     * {@code null}, else returns the current value.<a name="line.1359"></a>
<span class="sourceLineNo">1360</span>     *<a name="line.1360"></a>
<span class="sourceLineNo">1361</span>     * @param key   key with which the specified value is to be associated<a name="line.1361"></a>
<span class="sourceLineNo">1362</span>     * @param value value to be associated with the specified key<a name="line.1362"></a>
<span class="sourceLineNo">1363</span>     * @return the previous value associated with the specified key, or<a name="line.1363"></a>
<span class="sourceLineNo">1364</span>     * {@code null} if there was no mapping for the key.<a name="line.1364"></a>
<span class="sourceLineNo">1365</span>     * (A {@code null} return can also indicate that the map<a name="line.1365"></a>
<span class="sourceLineNo">1366</span>     * previously associated {@code null} with the key.)<a name="line.1366"></a>
<span class="sourceLineNo">1367</span>     */<a name="line.1367"></a>
<span class="sourceLineNo">1368</span>    public V putIfAbsent(K key, V value) {<a name="line.1368"></a>
<span class="sourceLineNo">1369</span>        V v = get(key);<a name="line.1369"></a>
<span class="sourceLineNo">1370</span>        if(v == null)<a name="line.1370"></a>
<span class="sourceLineNo">1371</span>            v = put(key, value);<a name="line.1371"></a>
<span class="sourceLineNo">1372</span>        return v;<a name="line.1372"></a>
<span class="sourceLineNo">1373</span>    }<a name="line.1373"></a>
<span class="sourceLineNo">1374</span><a name="line.1374"></a>
<span class="sourceLineNo">1375</span>    /**<a name="line.1375"></a>
<span class="sourceLineNo">1376</span>     * Removes the entry for the specified key only if it is currently<a name="line.1376"></a>
<span class="sourceLineNo">1377</span>     * mapped to the specified value.<a name="line.1377"></a>
<span class="sourceLineNo">1378</span>     *<a name="line.1378"></a>
<span class="sourceLineNo">1379</span>     * @param key   key with which the specified value is associated<a name="line.1379"></a>
<span class="sourceLineNo">1380</span>     * @param value value expected to be associated with the specified key<a name="line.1380"></a>
<span class="sourceLineNo">1381</span>     * @return {@code true} if the value was removed<a name="line.1381"></a>
<span class="sourceLineNo">1382</span>     */<a name="line.1382"></a>
<span class="sourceLineNo">1383</span>    public boolean remove(Object key, Object value) {<a name="line.1383"></a>
<span class="sourceLineNo">1384</span>        if (containsKey(key) &amp;&amp; Objects.equals(get(key), value)) {<a name="line.1384"></a>
<span class="sourceLineNo">1385</span>            remove(key);<a name="line.1385"></a>
<span class="sourceLineNo">1386</span>            return true;<a name="line.1386"></a>
<span class="sourceLineNo">1387</span>        } else<a name="line.1387"></a>
<span class="sourceLineNo">1388</span>            return false;<a name="line.1388"></a>
<span class="sourceLineNo">1389</span>    }<a name="line.1389"></a>
<span class="sourceLineNo">1390</span><a name="line.1390"></a>
<span class="sourceLineNo">1391</span>    /**<a name="line.1391"></a>
<span class="sourceLineNo">1392</span>     * Replaces the entry for the specified key only if currently<a name="line.1392"></a>
<span class="sourceLineNo">1393</span>     * mapped to the specified value. The position in the iteration<a name="line.1393"></a>
<span class="sourceLineNo">1394</span>     * order is retained.<a name="line.1394"></a>
<span class="sourceLineNo">1395</span>     *<a name="line.1395"></a>
<span class="sourceLineNo">1396</span>     * @param key      key with which the specified value is associated<a name="line.1396"></a>
<span class="sourceLineNo">1397</span>     * @param oldValue value expected to be associated with the specified key<a name="line.1397"></a>
<span class="sourceLineNo">1398</span>     * @param newValue value to be associated with the specified key<a name="line.1398"></a>
<span class="sourceLineNo">1399</span>     * @return {@code true} if the value was replaced<a name="line.1399"></a>
<span class="sourceLineNo">1400</span>     */<a name="line.1400"></a>
<span class="sourceLineNo">1401</span>    public boolean replace(K key, V oldValue, V newValue) {<a name="line.1401"></a>
<span class="sourceLineNo">1402</span>        if (containsKey(key) &amp;&amp; Objects.equals(get(key), oldValue)) {<a name="line.1402"></a>
<span class="sourceLineNo">1403</span>            put(key, newValue);<a name="line.1403"></a>
<span class="sourceLineNo">1404</span>            return true;<a name="line.1404"></a>
<span class="sourceLineNo">1405</span>        } else<a name="line.1405"></a>
<span class="sourceLineNo">1406</span>            return false;<a name="line.1406"></a>
<span class="sourceLineNo">1407</span>    }<a name="line.1407"></a>
<span class="sourceLineNo">1408</span><a name="line.1408"></a>
<span class="sourceLineNo">1409</span>    /**<a name="line.1409"></a>
<span class="sourceLineNo">1410</span>     * Replaces the entry for the specified key only if it is<a name="line.1410"></a>
<span class="sourceLineNo">1411</span>     * currently mapped to some value. Preserves the existing key's<a name="line.1411"></a>
<span class="sourceLineNo">1412</span>     * position in the iteration order.<a name="line.1412"></a>
<span class="sourceLineNo">1413</span>     *<a name="line.1413"></a>
<span class="sourceLineNo">1414</span>     * @param key   key with which the specified value is associated<a name="line.1414"></a>
<span class="sourceLineNo">1415</span>     * @param value value to be associated with the specified key<a name="line.1415"></a>
<span class="sourceLineNo">1416</span>     * @return the previous value associated with the specified key, or<a name="line.1416"></a>
<span class="sourceLineNo">1417</span>     * {@code null} if there was no mapping for the key.<a name="line.1417"></a>
<span class="sourceLineNo">1418</span>     * (A {@code null} return can also indicate that the map<a name="line.1418"></a>
<span class="sourceLineNo">1419</span>     * previously associated {@code null} with the key.)<a name="line.1419"></a>
<span class="sourceLineNo">1420</span>     */<a name="line.1420"></a>
<span class="sourceLineNo">1421</span>    public V replace(K key, V value) {<a name="line.1421"></a>
<span class="sourceLineNo">1422</span>        if (containsKey(key)) {<a name="line.1422"></a>
<span class="sourceLineNo">1423</span>            return put(key, value);<a name="line.1423"></a>
<span class="sourceLineNo">1424</span>        } else<a name="line.1424"></a>
<span class="sourceLineNo">1425</span>            return null;<a name="line.1425"></a>
<span class="sourceLineNo">1426</span>    }<a name="line.1426"></a>
<span class="sourceLineNo">1427</span>    /**<a name="line.1427"></a>
<span class="sourceLineNo">1428</span>     * Given alternating key and value arguments in pairs, puts each key-value pair into this OrderedMap as if by<a name="line.1428"></a>
<span class="sourceLineNo">1429</span>     * calling {@link #put(Object, Object)} repeatedly for each pair. This mimics the parameter syntax used for<a name="line.1429"></a>
<span class="sourceLineNo">1430</span>     * {@link #makeMap(Object, Object, Object...)}, and can be used to retain that style of insertion after an<a name="line.1430"></a>
<span class="sourceLineNo">1431</span>     * OrderedMap has been instantiated.<a name="line.1431"></a>
<span class="sourceLineNo">1432</span>     * @param k0 the first key to add<a name="line.1432"></a>
<span class="sourceLineNo">1433</span>     * @param v0 the first value to add<a name="line.1433"></a>
<span class="sourceLineNo">1434</span>     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements<a name="line.1434"></a>
<span class="sourceLineNo">1435</span>     * @return this, after adding all viable key-value pairs given<a name="line.1435"></a>
<span class="sourceLineNo">1436</span>     */<a name="line.1436"></a>
<span class="sourceLineNo">1437</span>    @SuppressWarnings("unchecked")<a name="line.1437"></a>
<span class="sourceLineNo">1438</span>    public UnorderedMap&lt;K, V&gt; putPairs(K k0, V v0, Object... rest)<a name="line.1438"></a>
<span class="sourceLineNo">1439</span>    {<a name="line.1439"></a>
<span class="sourceLineNo">1440</span>        if(rest == null || rest.length == 0)<a name="line.1440"></a>
<span class="sourceLineNo">1441</span>        {<a name="line.1441"></a>
<span class="sourceLineNo">1442</span>            put(k0, v0);<a name="line.1442"></a>
<span class="sourceLineNo">1443</span>            return this;<a name="line.1443"></a>
<span class="sourceLineNo">1444</span>        }<a name="line.1444"></a>
<span class="sourceLineNo">1445</span>        put(k0, v0);<a name="line.1445"></a>
<span class="sourceLineNo">1446</span><a name="line.1446"></a>
<span class="sourceLineNo">1447</span>        for (int i = 0; i &lt; rest.length - 1; i+=2) {<a name="line.1447"></a>
<span class="sourceLineNo">1448</span>            try {<a name="line.1448"></a>
<span class="sourceLineNo">1449</span>                put((K) rest[i], (V) rest[i + 1]);<a name="line.1449"></a>
<span class="sourceLineNo">1450</span>            }catch (ClassCastException ignored) {<a name="line.1450"></a>
<span class="sourceLineNo">1451</span>            }<a name="line.1451"></a>
<span class="sourceLineNo">1452</span>        }<a name="line.1452"></a>
<span class="sourceLineNo">1453</span>        return this;<a name="line.1453"></a>
<span class="sourceLineNo">1454</span>    }<a name="line.1454"></a>
<span class="sourceLineNo">1455</span><a name="line.1455"></a>
<span class="sourceLineNo">1456</span>    /**<a name="line.1456"></a>
<span class="sourceLineNo">1457</span>     * Makes an OrderedMap (OM) with the given load factor (which should be between 0.1 and 0.9), key and value types<a name="line.1457"></a>
<span class="sourceLineNo">1458</span>     * inferred from the types of k0 and v0, and considers all remaining parameters key-value pairs, casting the Objects<a name="line.1458"></a>
<span class="sourceLineNo">1459</span>     * at positions 0, 2, 4... etc. to K and the objects at positions 1, 3, 5... etc. to V. If rest has an odd-number<a name="line.1459"></a>
<span class="sourceLineNo">1460</span>     * length, then it discards the last item. If any pair of items in rest cannot be cast to the correct type of K or<a name="line.1460"></a>
<span class="sourceLineNo">1461</span>     * V, then this inserts nothing for that pair. This is similar to the makeOM method in the Maker class, but does not<a name="line.1461"></a>
<span class="sourceLineNo">1462</span>     * allow setting the load factor (since that extra parameter can muddle how javac figures out which generic types<a name="line.1462"></a>
<span class="sourceLineNo">1463</span>     * the map should use), nor does it log debug information if a cast fails. The result should be the same otherwise.<a name="line.1463"></a>
<span class="sourceLineNo">1464</span>     * &lt;br&gt;<a name="line.1464"></a>
<span class="sourceLineNo">1465</span>     * This is named makeMap to indicate that it expects key and value parameters, unlike a Set or List. This convention<a name="line.1465"></a>
<span class="sourceLineNo">1466</span>     * may be extended to other data structures that also have static methods for instantiation.<a name="line.1466"></a>
<span class="sourceLineNo">1467</span>     * @param k0 the first key; used to infer the types of other keys if generic parameters aren't specified.<a name="line.1467"></a>
<span class="sourceLineNo">1468</span>     * @param v0 the first value; used to infer the types of other values if generic parameters aren't specified.<a name="line.1468"></a>
<span class="sourceLineNo">1469</span>     * @param rest an array or vararg of keys and values in pairs; should contain alternating K, V, K, V... elements<a name="line.1469"></a>
<span class="sourceLineNo">1470</span>     * @param &lt;K&gt; the type of keys in the returned OrderedMap; if not specified, will be inferred from k0<a name="line.1470"></a>
<span class="sourceLineNo">1471</span>     * @param &lt;V&gt; the type of values in the returned OrderedMap; if not specified, will be inferred from v0<a name="line.1471"></a>
<span class="sourceLineNo">1472</span>     * @return a freshly-made OrderedMap with K keys and V values, using k0, v0, and the contents of rest to fill it<a name="line.1472"></a>
<span class="sourceLineNo">1473</span>     */<a name="line.1473"></a>
<span class="sourceLineNo">1474</span>    @SuppressWarnings("unchecked")<a name="line.1474"></a>
<span class="sourceLineNo">1475</span>    public static &lt;K, V&gt; UnorderedMap&lt;K, V&gt; makeMap(K k0, V v0, Object... rest)<a name="line.1475"></a>
<span class="sourceLineNo">1476</span>    {<a name="line.1476"></a>
<span class="sourceLineNo">1477</span>        if(rest == null || rest.length == 0)<a name="line.1477"></a>
<span class="sourceLineNo">1478</span>        {<a name="line.1478"></a>
<span class="sourceLineNo">1479</span>            UnorderedMap&lt;K, V&gt; om = new UnorderedMap&lt;&gt;(2);<a name="line.1479"></a>
<span class="sourceLineNo">1480</span>            om.put(k0, v0);<a name="line.1480"></a>
<span class="sourceLineNo">1481</span>            return om;<a name="line.1481"></a>
<span class="sourceLineNo">1482</span>        }<a name="line.1482"></a>
<span class="sourceLineNo">1483</span>        UnorderedMap&lt;K, V&gt; om = new UnorderedMap&lt;&gt;(1 + (rest.length &gt;&gt; 1));<a name="line.1483"></a>
<span class="sourceLineNo">1484</span>        om.put(k0, v0);<a name="line.1484"></a>
<span class="sourceLineNo">1485</span><a name="line.1485"></a>
<span class="sourceLineNo">1486</span>        for (int i = 0; i &lt; rest.length - 1; i+=2) {<a name="line.1486"></a>
<span class="sourceLineNo">1487</span>            try {<a name="line.1487"></a>
<span class="sourceLineNo">1488</span>                om.put((K) rest[i], (V) rest[i + 1]);<a name="line.1488"></a>
<span class="sourceLineNo">1489</span>            }catch (ClassCastException ignored) {<a name="line.1489"></a>
<span class="sourceLineNo">1490</span>            }<a name="line.1490"></a>
<span class="sourceLineNo">1491</span>        }<a name="line.1491"></a>
<span class="sourceLineNo">1492</span>        return om;<a name="line.1492"></a>
<span class="sourceLineNo">1493</span>    }<a name="line.1493"></a>
<span class="sourceLineNo">1494</span><a name="line.1494"></a>
<span class="sourceLineNo">1495</span>    /**<a name="line.1495"></a>
<span class="sourceLineNo">1496</span>     * Makes an empty OrderedMap (OM); needs key and value types to be specified in order to work. For an empty<a name="line.1496"></a>
<span class="sourceLineNo">1497</span>     * OrderedMap with String keys and Coord values, you could use {@code Maker.&lt;String, Coord&gt;makeOM()}. Using<a name="line.1497"></a>
<span class="sourceLineNo">1498</span>     * the new keyword is probably just as easy in this case; this method is provided for completeness relative to<a name="line.1498"></a>
<span class="sourceLineNo">1499</span>     * makeMap() with 2 or more parameters.<a name="line.1499"></a>
<span class="sourceLineNo">1500</span>     * @param &lt;K&gt; the type of keys in the returned OrderedMap; cannot be inferred and must be specified<a name="line.1500"></a>
<span class="sourceLineNo">1501</span>     * @param &lt;V&gt; the type of values in the returned OrderedMap; cannot be inferred and must be specified<a name="line.1501"></a>
<span class="sourceLineNo">1502</span>     * @return an empty OrderedMap with the given key and value types.<a name="line.1502"></a>
<span class="sourceLineNo">1503</span>     */<a name="line.1503"></a>
<span class="sourceLineNo">1504</span>    public static &lt;K, V&gt; UnorderedMap&lt;K, V&gt; makeMap()<a name="line.1504"></a>
<span class="sourceLineNo">1505</span>    {<a name="line.1505"></a>
<span class="sourceLineNo">1506</span>        return new UnorderedMap&lt;&gt;();<a name="line.1506"></a>
<span class="sourceLineNo">1507</span>    }<a name="line.1507"></a>
<span class="sourceLineNo">1508</span><a name="line.1508"></a>
<span class="sourceLineNo">1509</span>}<a name="line.1509"></a>




























































</pre>
</div>
</body>
</html>
